{"id":"node_modules/@shapediver/viewer.shared.node-tree/dist/implementation/AbstractTree.js","dependencies":[{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.node-tree\\dist\\implementation\\AbstractTree.js.map","includedInParent":true,"mtime":1706527150233},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.node-tree\\src\\implementation\\AbstractTree.ts","includedInParent":true,"mtime":1706527150456},{"name":"D:\\projects\\myProjects\\shapeApp\\package.json","includedInParent":true,"mtime":1706533774939},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.node-tree\\package.json","includedInParent":true,"mtime":1706527150208}],"generated":{"js":"\"use strict\";\r\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _AbstractTree_root;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AbstractTree = void 0;\r\nclass AbstractTree {\r\n    // #endregion Properties (1)\r\n    // #region Constructors (1)\r\n    constructor(root) {\r\n        // #region Properties (1)\r\n        _AbstractTree_root.set(this, void 0);\r\n        __classPrivateFieldSet(this, _AbstractTree_root, root, \"f\");\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Accessors (1)\r\n    get root() {\r\n        return __classPrivateFieldGet(this, _AbstractTree_root, \"f\");\r\n    }\r\n    // #endregion Public Accessors (1)\r\n    // #region Public Methods (6)\r\n    addNode(node, parent = __classPrivateFieldGet(this, _AbstractTree_root, \"f\"), root = __classPrivateFieldGet(this, _AbstractTree_root, \"f\")) {\r\n        if (root === parent) {\r\n            root.addChild(node);\r\n            return true;\r\n        }\r\n        for (let i = 0; i < root.children.length; i++) {\r\n            const child = root.children[i];\r\n            if (child && this.addNode(node, parent, child)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    addNodeAtPath(node, path = this.root.getPath(), root = __classPrivateFieldGet(this, _AbstractTree_root, \"f\")) {\r\n        if (root.name === path) {\r\n            root.addChild(node);\r\n            return true;\r\n        }\r\n        const pathStart = path.substr(0, path.indexOf('.'));\r\n        if (root.name === pathStart) {\r\n            const shortenedPath = path.substr(pathStart.length + 1, path.length);\r\n            for (let i = 0; i < root.children.length; i++) {\r\n                const child = root.children[i];\r\n                if (child && this.addNodeAtPath(node, shortenedPath, child)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    getNodeAtPath(path = this.root.getPath(), root = __classPrivateFieldGet(this, _AbstractTree_root, \"f\")) {\r\n        if (root.name === path)\r\n            return root;\r\n        const pathStart = path.substr(0, path.indexOf('.'));\r\n        if (root.name === pathStart) {\r\n            const shortenedPath = path.substr(pathStart.length + 1, path.length);\r\n            for (let i = 0; i < root.children.length; i++) {\r\n                const child = root.children[i];\r\n                const res = this.getNodeAtPath(shortenedPath, child);\r\n                if (res)\r\n                    return res;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    removeNode(node, root = __classPrivateFieldGet(this, _AbstractTree_root, \"f\")) {\r\n        if (root.hasChild(node)) {\r\n            root.removeChild(node);\r\n            return true;\r\n        }\r\n        for (let i = 0; i < root.children.length; i++) {\r\n            const child = root.children[i];\r\n            if (child && this.removeNode(node, child)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    removeNodeAtPath(path, root = __classPrivateFieldGet(this, _AbstractTree_root, \"f\")) {\r\n        var _a;\r\n        if (root.name === path) {\r\n            (_a = root.parent) === null || _a === void 0 ? void 0 : _a.removeChild(root);\r\n            return true;\r\n        }\r\n        const pathStart = path.substr(0, path.indexOf('.'));\r\n        if (root.name === pathStart) {\r\n            const shortenedPath = path.substr(pathStart.length + 1, path.length);\r\n            for (let i = 0; i < root.children.length; i++) {\r\n                const child = root.children[i];\r\n                if (child && this.removeNodeAtPath(shortenedPath, child)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexports.AbstractTree = AbstractTree;\r\n_AbstractTree_root = new WeakMap();\r\n"},"sourceMaps":{"js":{"version":3,"file":"AbstractTree.js","sourceRoot":"","sources":["../../src/implementation/AbstractTree.ts"],"names":[],"mappings":"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","sourcesContent":["import { ITree } from '../interfaces/ITree';\r\nimport { ITreeNode } from '../interfaces/ITreeNode';\r\nimport { ITreeNodeData } from '../interfaces/ITreeNodeData';\r\n\r\nexport abstract class AbstractTree<T extends ITreeNode<any, ITreeNodeData<any>>> implements ITree<T> {\r\n  // #region Properties (1)\r\n\r\n  readonly #root: T;\r\n\r\n  // #endregion Properties (1)\r\n\r\n  // #region Constructors (1)\r\n\r\n  constructor(root: T) {\r\n    this.#root = root;\r\n  }\r\n\r\n  // #endregion Constructors (1)\r\n\r\n  // #region Public Accessors (1)\r\n\r\n  public get root(): T {\r\n    return this.#root;\r\n  }\r\n\r\n  // #endregion Public Accessors (1)\r\n\r\n  // #region Public Methods (6)\r\n\r\n  public addNode(node: T, parent: T = this.#root, root: T = this.#root): boolean {\r\n    if (root === parent) {\r\n      root.addChild(node);\r\n      return true;\r\n    }\r\n\r\n    for (let i = 0; i < root.children.length; i++) {\r\n      const child = root.children[i];\r\n      if (child && this.addNode(node, parent, child)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public addNodeAtPath(node: T, path: string = this.root.getPath(), root: T = this.#root): boolean {\r\n    if (root.name === path) {\r\n      root.addChild(node);\r\n      return true;\r\n    }\r\n\r\n    const pathStart = path.substr(0, path.indexOf('.'));\r\n    if (root.name === pathStart) {\r\n      const shortenedPath = path.substr(pathStart.length + 1, path.length);\r\n\r\n      for (let i = 0; i < root.children.length; i++) {\r\n        const child = root.children[i];\r\n        if (child && this.addNodeAtPath(node, shortenedPath, child)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  public getNodeAtPath(path: string = this.root.getPath(), root: T = this.#root): T | null {\r\n    if (root.name === path) \r\n      return root;\r\n\r\n    const pathStart = path.substr(0, path.indexOf('.'));\r\n    if (root.name === pathStart) {\r\n      const shortenedPath = path.substr(pathStart.length + 1, path.length);\r\n\r\n      for (let i = 0; i < root.children.length; i++) {\r\n        const child = root.children[i];\r\n        const res = this.getNodeAtPath(shortenedPath, child);\r\n        if(res) return res;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  public removeNode(node: T, root: T = this.#root): boolean {\r\n    if (root.hasChild(node)) {\r\n      root.removeChild(node);\r\n      return true;\r\n    }\r\n\r\n    for (let i = 0; i < root.children.length; i++) {\r\n      const child = root.children[i];\r\n      if (child && this.removeNode(node, child)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  public removeNodeAtPath(path: string, root: T = this.#root): boolean {\r\n    if (root.name === path) {\r\n      root.parent?.removeChild(root);\r\n      return true;\r\n    }\r\n\r\n    const pathStart = path.substr(0, path.indexOf('.'));\r\n    if (root.name === pathStart) {\r\n      const shortenedPath = path.substr(pathStart.length + 1, path.length);\r\n\r\n      for (let i = 0; i < root.children.length; i++) {\r\n        const child = root.children[i];\r\n        if (child && this.removeNodeAtPath(shortenedPath, child)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // #endregion Public Methods (6)\r\n}"]}},"error":null,"hash":"a4d50565f54e861966f2da69ce1ee91a","cacheData":{"env":{}}}