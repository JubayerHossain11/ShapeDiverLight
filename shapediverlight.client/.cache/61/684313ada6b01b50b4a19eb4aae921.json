{"id":"node_modules/@shapediver/viewer.rendering-engine-threejs.standard/dist/shaders/gem.js","dependencies":[{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\dist\\shaders\\gem.js.map","includedInParent":true,"mtime":1706527153221},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\src\\shaders\\gem.ts","includedInParent":true,"mtime":1706527154033},{"name":"D:\\projects\\myProjects\\shapeApp\\package.json","includedInParent":true,"mtime":1706533774939},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\package.json","includedInParent":true,"mtime":1706527152875}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.frag = exports.vert = void 0;\r\nexports.vert = `\r\n#define STANDARD\r\nvarying vec3 vViewPosition;\r\n#ifdef USE_TRANSMISSION\r\n\tvarying vec3 vWorldPosition;\r\n#endif\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <normal_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\n// CUSTOM START\r\nvarying vec3 frag_position;\r\nvarying vec3 frag_normal;\r\n// CUSTOM END\r\n\r\nvoid main() {\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\t#include <morphcolor_vertex>\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\t#include <normal_vertex>\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\tvViewPosition = - mvPosition.xyz;\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n    #ifdef USE_TRANSMISSION\r\n        vWorldPosition = worldPosition.xyz;\r\n    #endif\r\n\r\n    // CUSTOM START\r\n    frag_position = position;\r\n    frag_normal = objectNormal;\r\n    // CUSTOM END\r\n}\r\n`;\r\nexports.frag = `\r\n#define STANDARD\r\n#ifdef PHYSICAL\r\n\t#define IOR\r\n\t#define SPECULAR\r\n#endif\r\n\r\n// CUSTOM START\r\n#ifdef USE_IMPURITYMAP\r\n\tuniform sampler2D impurityMap;\r\n#endif\r\n// CUSTOM END\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float roughness;\r\nuniform float metalness;\r\nuniform float opacity;\r\n#ifdef IOR\r\n\tuniform float ior;\r\n#endif\r\n#ifdef SPECULAR\r\n\tuniform float specularIntensity;\r\n\tuniform vec3 specularColor;\r\n\t#ifdef USE_SPECULARINTENSITYMAP\r\n\t\tuniform sampler2D specularIntensityMap;\r\n\t#endif\r\n\t#ifdef USE_SPECULARCOLORMAP\r\n\t\tuniform sampler2D specularColorMap;\r\n\t#endif\r\n#endif\r\n#ifdef USE_CLEARCOAT\r\n\tuniform float clearcoat;\r\n\tuniform float clearcoatRoughness;\r\n#endif\r\n#ifdef USE_IRIDESCENCE\r\n\tuniform float iridescence;\r\n\tuniform float iridescenceIOR;\r\n\tuniform float iridescenceThicknessMinimum;\r\n\tuniform float iridescenceThicknessMaximum;\r\n#endif\r\n#ifdef USE_SHEEN\r\n\tuniform vec3 sheenColor;\r\n\tuniform float sheenRoughness;\r\n\t#ifdef USE_SHEENCOLORMAP\r\n\t\tuniform sampler2D sheenColorMap;\r\n\t#endif\r\n\t#ifdef USE_SHEENROUGHNESSMAP\r\n\t\tuniform sampler2D sheenRoughnessMap;\r\n\t#endif\r\n#endif\r\nvarying vec3 vViewPosition;\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <alphatest_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <bsdfs>\r\n#include <iridescence_fragment>\r\n#include <cube_uv_reflection_fragment>\r\n#include <envmap_common_pars_fragment>\r\n#include <envmap_physical_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <lights_pars_begin>\r\n#include <normal_pars_fragment>\r\n#include <lights_physical_pars_fragment>\r\n#include <transmission_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <clearcoat_pars_fragment>\r\n#include <iridescence_pars_fragment>\r\n#include <roughnessmap_pars_fragment>\r\n#include <metalnessmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\n\r\n\r\n// CUSTOM START\r\n\r\nvarying vec4 initialPosition;\r\nvarying vec3 initialNormal;\r\n\r\nvarying vec3 frag_position;\r\nvarying vec3 frag_normal;\r\n\r\nuniform vec3 center;\r\nuniform float radius;\r\nuniform samplerCube sphericalNormalMap;\r\nuniform mat3 normalMatrix;\r\nuniform mat4 modelMatrix;\r\n\r\nuniform float impurityScale;\r\nuniform vec3 colorTransferBegin;\r\nuniform vec3 colorTransferEnd;\r\nuniform float refractionIndex;\r\nuniform float gamma;\r\nuniform float contrast;\r\nuniform float brightness;\r\nuniform float dispersion;\r\nuniform float tracingOpacity;\r\n\r\n\r\nvec3 getIBLRadianceVariation( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\r\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\r\n\t\tvec3 reflectVec = reflect( - viewDir, normal );\r\n\t\t// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\r\n\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\r\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\r\n\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\r\n\t\treturn min(envMapColor.rgb * envMapIntensity, vec3(1.0));\r\n\t#else\r\n\t\treturn vec3( 0.0 );\r\n\t#endif\r\n}\r\n\r\nvec3 calculateReflectedLight(vec3 position, vec3 normal, vec3 viewDir, PhysicalMaterial material, int depth) {\r\n\t\r\n\tGeometricContext currentGeometry;\r\n\tcurrentGeometry.position = (modelMatrix * vec4(position, 1.0)).xyz;\r\n\tmat3 inverseTransposeModelMatrix = mat3(transpose(inverse(modelMatrix)));\r\n\tcurrentGeometry.normal = normalize(inverseTransposeModelMatrix * normal);\r\n\tcurrentGeometry.viewDir = normalize(inverseTransposeModelMatrix * -viewDir);\r\n\r\n\r\n    #ifdef USE_CLEARCOAT\r\n        currentGeometry.clearcoatNormal = clearcoatNormal;\r\n    #endif\r\n\r\n\tReflectedLight rLight;\r\n\tIncidentLight dLight;\r\n\r\n\tfloat temp = material.roughness;\r\n\tmaterial.roughness = 0.5;\r\n\r\n\t#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n\t\tPointLight pointLight;\r\n        #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\r\n            PointLightShadow pointLightShadow;\r\n        #endif\r\n\r\n\t    #pragma unroll_loop_start\r\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\t\t\tpointLight = pointLights[ i ];\r\n            getPointLightInfo( pointLight, currentGeometry, dLight );\r\n            #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\r\n                pointLightShadow = pointLightShadows[ i ];\r\n                dLight.color *= all( bvec2( dLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\r\n            #endif\r\n\t\t    RE_Direct( dLight, currentGeometry, material, rLight );\r\n\t\t}\r\n        #pragma unroll_loop_end\r\n\t#endif\r\n\t#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\r\n        SpotLight spotLight;\r\n        #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\r\n            SpotLightShadow spotLightShadow;\r\n        #endif\r\n        #pragma unroll_loop_start\r\n        for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n            spotLight = spotLights[ i ];\r\n            getSpotLightInfo( spotLight, currentGeometry, dLight );\r\n            #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\r\n                spotLightShadow = spotLightShadows[ i ];\r\n                dLight.color *= all( bvec2( dLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\r\n            #endif\r\n            RE_Direct( dLight, currentGeometry, material, rLight );\r\n        }\r\n        #pragma unroll_loop_end\r\n\t#endif\r\n\r\n    #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\r\n        DirectionalLight directionalLight;\r\n        #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\r\n            DirectionalLightShadow directionalLightShadow;\r\n        #endif\r\n        #pragma unroll_loop_start\r\n        for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n            directionalLight = directionalLights[ i ];\r\n            getDirectionalLightInfo( directionalLight, currentGeometry, dLight );\r\n            #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\r\n                directionalLightShadow = directionalLightShadows[ i ];\r\n                dLight.color *= all( bvec2( dLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n            #endif\r\n            RE_Direct( dLight, currentGeometry, material, rLight );\r\n        }\r\n        #pragma unroll_loop_end\r\n    #endif\r\n\tmaterial.roughness = temp;\r\n\t\r\n    #if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\r\n        RectAreaLight rectAreaLight;\r\n        #pragma unroll_loop_start\r\n        for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\r\n            rectAreaLight = rectAreaLights[ i ];\r\n            RE_Direct_RectArea( rectAreaLight, currentGeometry, material, rLight );\r\n        }\r\n        #pragma unroll_loop_end\r\n    #endif\r\n    #if defined( RE_IndirectDiffuse )\r\n        vec3 iblIrradiance = vec3( 0.0 );\r\n        vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\r\n        irradiance += getLightProbeIrradiance( lightProbe, currentGeometry.normal );\r\n        #if ( NUM_HEMI_LIGHTS > 0 )\r\n            #pragma unroll_loop_start\r\n            for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\r\n                irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], currentGeometry.normal );\r\n            }\r\n            #pragma unroll_loop_end\r\n        #endif\r\n    #endif\r\n    #if defined( RE_IndirectSpecular )\r\n        vec3 radiance = vec3( 0.0 );\r\n        vec3 clearcoatRadiance = vec3( 0.0 );\r\n    #endif\r\n\r\n\r\n    #if defined( RE_IndirectDiffuse )\r\n        #ifdef USE_LIGHTMAP\r\n            vec4 lightMapTexel = texture2D( lightMap, vUv2 );\r\n            vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\r\n            irradiance += lightMapIrradiance;\r\n        #endif\r\n        #if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\r\n            iblIrradiance += getIBLIrradiance( currentGeometry.normal );\r\n        #endif\r\n    #endif\r\n    #if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\r\n        radiance += getIBLRadianceVariation( currentGeometry.viewDir, currentGeometry.normal, material.roughness );\r\n        #ifdef USE_CLEARCOAT\r\n            clearcoatRadiance += getIBLRadianceVariation( currentGeometry.viewDir, currentGeometry.clearcoatNormal, material.clearcoatRoughness );\r\n        #endif\r\n    #endif\r\n\r\n    #if defined( RE_IndirectDiffuse )\r\n        RE_IndirectDiffuse( irradiance, currentGeometry, material, rLight );\r\n    #endif\r\n    #if defined( RE_IndirectSpecular )\r\n        RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, currentGeometry, material, rLight );\r\n    #endif\r\n\r\n\tif(depth >= 0) {\r\n\t\tfloat frac = float(depth) / float(TRACING_DEPTH);\r\n\t\tvec3 colorTransfer = (1.0-frac) * colorTransferBegin + frac * colorTransferEnd;\r\n\t\trLight.indirectSpecular *= colorTransfer;\r\n\t\trLight.directSpecular *= colorTransfer;\r\n\t}\r\n\r\n\tvec3 color = rLight.indirectSpecular + rLight.directSpecular + rLight.indirectDiffuse + rLight.directDiffuse;\r\n\r\n\t// gamma\r\n\tcolor = pow(color, vec3(1.0/gamma)); \r\n\r\n\t// contrast\r\n\tcolor.rgb = ((color.rgb - 0.5) * max(contrast, 0.0)) + 0.5; \r\n\r\n\t// brightness\r\n\tcolor.r = min(max(color.r + brightness, 0.0), 1.0);\r\n\tcolor.g = min(max(color.g + brightness, 0.0), 1.0);\r\n\tcolor.b = min(max(color.b + brightness, 0.0), 1.0);\r\n\r\n\treturn color;\r\n}\r\n\r\nvec3 normalLookUp(vec3 dir) {\r\n\tvec4 s = textureCube(sphericalNormalMap, dir);\r\n\tif(s.a < 1.0/256.0) {\r\n\t\treturn normalize(vec3(-s.x, -s.y, -s.z));\r\n\t} else if(s.a < 3.0/256.0) {\r\n\t\treturn normalize(vec3(-s.x, -s.y, s.z));\r\n\t} else if(s.a < 5.0/256.0) {\r\n\t\treturn normalize(vec3(-s.x, s.y, -s.z));\r\n\t} else if(s.a < 7.0/256.0) {\r\n\t\treturn normalize(vec3(s.x, -s.y, -s.z));\r\n\t} else if(s.a < 9.0/256.0) {\r\n\t\treturn normalize(vec3(-s.x, s.y, s.z));\r\n\t} else if(s.a < 11.0/256.0) {\r\n\t\treturn normalize(vec3(s.x, -s.y, s.z));\r\n\t} else if(s.a < 13.0/256.0) {\r\n\t\treturn normalize(vec3(s.x, s.y, -s.z));\r\n\t} else {\r\n\t\treturn normalize(s.xyz);\r\n\t}\r\n}\r\n\r\n#ifdef USE_IMPURITYMAP\r\n\tfloat impurityLookUp(vec3 dir) {\r\n\t\tvec3 c = textureCube(impurityMap, dir.xy).rgb;\r\n\t\treturn (c.x + c.y + c.z) / 3.0;\r\n\t}\r\n#endif\r\n\r\nvec3 raySphereIntersection(vec3 o, vec3 d) {\r\n\r\n\tvec3 oc = o - center;\r\n    float a = dot(d, d);\r\n    float b = 2.0 * dot(oc, d);\r\n    float c = dot(oc,oc) - radius*radius;\r\n    float discriminant = b*b - 4.0*a*c;\r\n    if(discriminant < 0.0){\r\n        return vec3(0.0);\r\n    }\r\n    else{\r\n        return o +( (-b + sqrt(discriminant)) / (2.0*a)) * d;\r\n    }\r\n}\r\n\r\nvec3 hueToSaturatedColor(float hue) {\r\n    float r,g,b;\r\n    if (hue < 0.25){\r\n\t\tfloat t = 1.0 - (hue / 0.25);\r\n        r = 1.0;\r\n        g = 1.0;\r\n        b = t;    \r\n\t} else if (hue < 0.5){\r\n    \tfloat t = 1.0 - (hue - 0.25 / 0.25);\r\n\t\tr = 1.0;\r\n        g = t;\r\n        b = 0.0;\r\n\t} else if (hue < 0.75){\r\n    \tfloat t = 1.0 - (hue - 0.5 / 0.25);\r\n\t\tr = t;\r\n        g = 0.0;\r\n        b = 1.0 - t;\r\n    } else {\r\n    \tfloat t = hue - 0.75 / 0.25;\r\n        r = t;\r\n        g = t;\r\n        b = 1.0;\r\n    }\r\n    return vec3(r, g, b) / 0.5 + 0.5;\r\n}\r\n// CUSTOM END\r\n\r\nvoid main() {    \r\n    // CUSTOM START\r\n    vec3 frag_normal_normalized = frag_normal;\r\n    // CUSTOM END\r\n\t#include <clipping_planes_fragment>\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <roughnessmap_fragment>\r\n\t#include <metalnessmap_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\t#include <clearcoat_normal_fragment_begin>\r\n\t#include <clearcoat_normal_fragment_maps>\r\n\t#include <emissivemap_fragment>\r\n\t#include <lights_physical_fragment>\r\n\t#include <lights_fragment_begin>\r\n\t#include <lights_fragment_maps>\r\n\t#include <lights_fragment_end>\r\n\t#include <aomap_fragment>\r\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\r\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\r\n\t#include <transmission_fragment>\r\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\r\n\t#ifdef USE_SHEEN\r\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\r\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\r\n\t#endif\r\n\t#ifdef USE_CLEARCOAT\r\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\r\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\r\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\r\n\t#endif\r\n\t#include <output_fragment>\r\n\r\n    // CUSTOM START\r\n    \r\n\tmat4 inverseMM = inverse( modelMatrix );\r\n    \r\n\tvec3 initialDirection = normalize( frag_position - (inverseMM*vec4(cameraPosition,1.0)).xyz );\r\n\r\n\tvec4 outgoingLight2;\r\n\tfloat r_0 = (1.0-refractionIndex)/(1.0+refractionIndex);\r\n\tr_0 = r_0*r_0;\r\n\r\n\tfloat cos_theta_0 = -dot(initialDirection, frag_normal_normalized);\r\n\tfloat r_0_outside = (refractionIndex-1.0)/(refractionIndex+1.0);\r\n\tr_0_outside = r_0_outside*r_0_outside;\r\n\tfloat initialProbability = r_0_outside + (1.0 - r_0_outside)*pow(1.0 - cos_theta_0, 5.0);\r\n\r\n\toutgoingLight2 = vec4(calculateReflectedLight(frag_position, frag_normal_normalized, initialDirection, material, -1), 1.0);\r\n\t// gl_FragColor = outgoingLight2;\r\n\t// return;\r\n\tif(TRACING_DEPTH > 0) \r\n\t\toutgoingLight2 *= initialProbability;\r\n\t\t\r\n\tvec3 tempColor;\r\n\r\n\t#ifdef DISPERSION\r\n\t\tconst int loop = 3;\r\n\t\tvec3 dispersionColor;\r\n\t#else\r\n\t\tconst int loop = 1;\r\n\t#endif\r\n\t\t#pragma unroll_loop_start\r\n\t\tfor(int j = 0; j < loop; j++){\r\n\t\t\tvec3 refractedDirection = refract(initialDirection, frag_normal_normalized, 1.0/refractionIndex + float(j)*dispersion * 0.025);\r\n\t\t\tvec3 newPosition = raySphereIntersection(frag_position, refractedDirection);\r\n\t\t\tvec3 lookUpVector = normalize(newPosition - center);\r\n\t\t\tvec3 newNormal = normalLookUp(lookUpVector);\r\n\t\t\tvec3 newDirection = reflect(refractedDirection, newNormal);\r\n\r\n\t\t\tfloat currentProbability = 1.0;\r\n\r\n\t\t\t#ifdef USE_IMPURITYMAP\r\n\t\t\t\tfloat impurityProbability = impurityLookUp(lookUpVector);\r\n\t\t\t\tcurrentProbability -= impurityProbability * impurityScale;\r\n\t\t\t\t// gl_FragColor = vec4(vec3(impurityProbability), 1.0);\r\n\t\t\t\t// return;\r\n\t\t\t#endif\r\n\t\t\t\r\n\t\t\t// if(0 == TRACING_DEPTH) {\r\n\t\t\t// \tgl_FragColor = vec4(0.5 * newNormal + 0.5, 1.0);\r\n\t\t\t// \treturn;\r\n\t\t\t// }\r\n\r\n\t\t\ttempColor = vec3(0.0);\r\n\t\t\t#pragma unroll_loop_start\r\n\t\t\tfor(int i = 0; i < TRACING_DEPTH; i++) {\r\n\t\t\t\t// small position correction to avoid artefacts\r\n\t\t\t\tnewPosition = newPosition - lookUpVector * 1e-6;\r\n\t\t\t\tnewPosition = raySphereIntersection(newPosition, newDirection);\r\n\t\t\t\tlookUpVector = normalize(newPosition - center);\r\n\t\t\t\tnewNormal = normalLookUp(lookUpVector);\r\n\t\t\t\r\n\t\t\t\tfloat cos_theta = dot(newDirection, newNormal);\r\n\t\t\t\tfloat ratio;\r\n\t\t\t\tif(cos_theta > 0.0) {\r\n\t\t\t\t\tratio = refractionIndex;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcos_theta = -cos_theta;\r\n\t\t\t\t\tratio = 1.0 / refractionIndex;\r\n\t\t\t\t}\r\n\t\t\t\tfloat cos_theta_2 = 1.0 - ratio*ratio * (1.0 - cos_theta*cos_theta);\r\n\t\t\t\tfloat probability = r_0 + (1.0 - r_0)*pow(1.0 - cos_theta, 5.0);\r\n\t\t\t\tif(cos_theta_2 < 0.0) probability = 0.0;\r\n\r\n\t\t\t\tvec3 refracted = refract(newDirection, newNormal*-1.0, 1.0/refractionIndex);\r\n\t\t\t\ttempColor += probability * currentProbability * calculateReflectedLight(newPosition, newNormal*-1.0, reflect(refracted, newNormal), material, i);\r\n\t\t\t\tif(i+1 == TRACING_DEPTH)\r\n\t\t\t\t\ttempColor += (1.0 - probability) * currentProbability * calculateReflectedLight(newPosition, newNormal, newDirection, material, i);\r\n\r\n\t\t\t\tnewDirection = reflect(newDirection, newNormal);\r\n\r\n\t\t\t\t// if(i+1 == TRACING_DEPTH) {\r\n\t\t\t\t// \tgl_FragColor = vec4(0.5 * newNormal + 0.5, 1.0);\r\n\t\t\t\t// \treturn;\r\n\t\t\t\t// }\r\n\r\n\t\t\t\tcurrentProbability *= (1.0 - probability);\r\n\t\t\t}\r\n\t\t\t#pragma unroll_loop_end\r\n\r\n\t\t\t#ifdef DISPERSION\r\n\t\t\t\tif(j == 0) {\r\n\t\t\t\t\tdispersionColor.r = tempColor.r;\t\r\n\t\t\t\t} else if(j == 1) {\r\n\t\t\t\t\tdispersionColor.g = tempColor.g;\t\r\n\t\t\t\t} else if(j == 2) {\r\n\t\t\t\t\tdispersionColor.b = tempColor.b;\t\r\n\t\t\t\t}\r\n\t\t\t\ttempColor = dispersionColor;\r\n\t\t\t#endif\r\n\t\t}\t\r\n\t\t#pragma unroll_loop_end\r\n\r\n\tif(TRACING_DEPTH > 0)\r\n\t\toutgoingLight2.rgb += (1.0 - initialProbability) * tempColor;\r\n\r\n\tfloat alpha = (1.0 - initialProbability) + initialProbability*tracingOpacity;\r\n\tgl_FragColor = vec4(outgoingLight2.rgb, alpha*diffuseColor.a);\r\n\r\n    // CUSTOM END\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n}\r\n\r\n`;\r\n"},"sourceMaps":{"js":{"version":3,"file":"gem.js","sourceRoot":"","sources":["../../src/shaders/gem.ts"],"names":[],"mappings":";;;AAAa,QAAA,IAAI,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuDnB,CAAC;AAEW,QAAA,IAAI,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmfnB,CAAA","sourcesContent":["export const vert = `\r\n#define STANDARD\r\nvarying vec3 vViewPosition;\r\n#ifdef USE_TRANSMISSION\r\n\tvarying vec3 vWorldPosition;\r\n#endif\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <normal_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\n// CUSTOM START\r\nvarying vec3 frag_position;\r\nvarying vec3 frag_normal;\r\n// CUSTOM END\r\n\r\nvoid main() {\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\t#include <morphcolor_vertex>\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\t#include <normal_vertex>\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\tvViewPosition = - mvPosition.xyz;\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n    #ifdef USE_TRANSMISSION\r\n        vWorldPosition = worldPosition.xyz;\r\n    #endif\r\n\r\n    // CUSTOM START\r\n    frag_position = position;\r\n    frag_normal = objectNormal;\r\n    // CUSTOM END\r\n}\r\n`;\r\n\r\nexport const frag = `\r\n#define STANDARD\r\n#ifdef PHYSICAL\r\n\t#define IOR\r\n\t#define SPECULAR\r\n#endif\r\n\r\n// CUSTOM START\r\n#ifdef USE_IMPURITYMAP\r\n\tuniform sampler2D impurityMap;\r\n#endif\r\n// CUSTOM END\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float roughness;\r\nuniform float metalness;\r\nuniform float opacity;\r\n#ifdef IOR\r\n\tuniform float ior;\r\n#endif\r\n#ifdef SPECULAR\r\n\tuniform float specularIntensity;\r\n\tuniform vec3 specularColor;\r\n\t#ifdef USE_SPECULARINTENSITYMAP\r\n\t\tuniform sampler2D specularIntensityMap;\r\n\t#endif\r\n\t#ifdef USE_SPECULARCOLORMAP\r\n\t\tuniform sampler2D specularColorMap;\r\n\t#endif\r\n#endif\r\n#ifdef USE_CLEARCOAT\r\n\tuniform float clearcoat;\r\n\tuniform float clearcoatRoughness;\r\n#endif\r\n#ifdef USE_IRIDESCENCE\r\n\tuniform float iridescence;\r\n\tuniform float iridescenceIOR;\r\n\tuniform float iridescenceThicknessMinimum;\r\n\tuniform float iridescenceThicknessMaximum;\r\n#endif\r\n#ifdef USE_SHEEN\r\n\tuniform vec3 sheenColor;\r\n\tuniform float sheenRoughness;\r\n\t#ifdef USE_SHEENCOLORMAP\r\n\t\tuniform sampler2D sheenColorMap;\r\n\t#endif\r\n\t#ifdef USE_SHEENROUGHNESSMAP\r\n\t\tuniform sampler2D sheenRoughnessMap;\r\n\t#endif\r\n#endif\r\nvarying vec3 vViewPosition;\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <alphatest_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <bsdfs>\r\n#include <iridescence_fragment>\r\n#include <cube_uv_reflection_fragment>\r\n#include <envmap_common_pars_fragment>\r\n#include <envmap_physical_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <lights_pars_begin>\r\n#include <normal_pars_fragment>\r\n#include <lights_physical_pars_fragment>\r\n#include <transmission_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <clearcoat_pars_fragment>\r\n#include <iridescence_pars_fragment>\r\n#include <roughnessmap_pars_fragment>\r\n#include <metalnessmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\n\r\n\r\n// CUSTOM START\r\n\r\nvarying vec4 initialPosition;\r\nvarying vec3 initialNormal;\r\n\r\nvarying vec3 frag_position;\r\nvarying vec3 frag_normal;\r\n\r\nuniform vec3 center;\r\nuniform float radius;\r\nuniform samplerCube sphericalNormalMap;\r\nuniform mat3 normalMatrix;\r\nuniform mat4 modelMatrix;\r\n\r\nuniform float impurityScale;\r\nuniform vec3 colorTransferBegin;\r\nuniform vec3 colorTransferEnd;\r\nuniform float refractionIndex;\r\nuniform float gamma;\r\nuniform float contrast;\r\nuniform float brightness;\r\nuniform float dispersion;\r\nuniform float tracingOpacity;\r\n\r\n\r\nvec3 getIBLRadianceVariation( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\r\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\r\n\t\tvec3 reflectVec = reflect( - viewDir, normal );\r\n\t\t// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\r\n\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\r\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\r\n\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\r\n\t\treturn min(envMapColor.rgb * envMapIntensity, vec3(1.0));\r\n\t#else\r\n\t\treturn vec3( 0.0 );\r\n\t#endif\r\n}\r\n\r\nvec3 calculateReflectedLight(vec3 position, vec3 normal, vec3 viewDir, PhysicalMaterial material, int depth) {\r\n\t\r\n\tGeometricContext currentGeometry;\r\n\tcurrentGeometry.position = (modelMatrix * vec4(position, 1.0)).xyz;\r\n\tmat3 inverseTransposeModelMatrix = mat3(transpose(inverse(modelMatrix)));\r\n\tcurrentGeometry.normal = normalize(inverseTransposeModelMatrix * normal);\r\n\tcurrentGeometry.viewDir = normalize(inverseTransposeModelMatrix * -viewDir);\r\n\r\n\r\n    #ifdef USE_CLEARCOAT\r\n        currentGeometry.clearcoatNormal = clearcoatNormal;\r\n    #endif\r\n\r\n\tReflectedLight rLight;\r\n\tIncidentLight dLight;\r\n\r\n\tfloat temp = material.roughness;\r\n\tmaterial.roughness = 0.5;\r\n\r\n\t#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n\t\tPointLight pointLight;\r\n        #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\r\n            PointLightShadow pointLightShadow;\r\n        #endif\r\n\r\n\t    #pragma unroll_loop_start\r\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\t\t\tpointLight = pointLights[ i ];\r\n            getPointLightInfo( pointLight, currentGeometry, dLight );\r\n            #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\r\n                pointLightShadow = pointLightShadows[ i ];\r\n                dLight.color *= all( bvec2( dLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\r\n            #endif\r\n\t\t    RE_Direct( dLight, currentGeometry, material, rLight );\r\n\t\t}\r\n        #pragma unroll_loop_end\r\n\t#endif\r\n\t#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\r\n        SpotLight spotLight;\r\n        #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\r\n            SpotLightShadow spotLightShadow;\r\n        #endif\r\n        #pragma unroll_loop_start\r\n        for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n            spotLight = spotLights[ i ];\r\n            getSpotLightInfo( spotLight, currentGeometry, dLight );\r\n            #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\r\n                spotLightShadow = spotLightShadows[ i ];\r\n                dLight.color *= all( bvec2( dLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\r\n            #endif\r\n            RE_Direct( dLight, currentGeometry, material, rLight );\r\n        }\r\n        #pragma unroll_loop_end\r\n\t#endif\r\n\r\n    #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\r\n        DirectionalLight directionalLight;\r\n        #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\r\n            DirectionalLightShadow directionalLightShadow;\r\n        #endif\r\n        #pragma unroll_loop_start\r\n        for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n            directionalLight = directionalLights[ i ];\r\n            getDirectionalLightInfo( directionalLight, currentGeometry, dLight );\r\n            #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\r\n                directionalLightShadow = directionalLightShadows[ i ];\r\n                dLight.color *= all( bvec2( dLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n            #endif\r\n            RE_Direct( dLight, currentGeometry, material, rLight );\r\n        }\r\n        #pragma unroll_loop_end\r\n    #endif\r\n\tmaterial.roughness = temp;\r\n\t\r\n    #if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\r\n        RectAreaLight rectAreaLight;\r\n        #pragma unroll_loop_start\r\n        for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\r\n            rectAreaLight = rectAreaLights[ i ];\r\n            RE_Direct_RectArea( rectAreaLight, currentGeometry, material, rLight );\r\n        }\r\n        #pragma unroll_loop_end\r\n    #endif\r\n    #if defined( RE_IndirectDiffuse )\r\n        vec3 iblIrradiance = vec3( 0.0 );\r\n        vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\r\n        irradiance += getLightProbeIrradiance( lightProbe, currentGeometry.normal );\r\n        #if ( NUM_HEMI_LIGHTS > 0 )\r\n            #pragma unroll_loop_start\r\n            for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\r\n                irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], currentGeometry.normal );\r\n            }\r\n            #pragma unroll_loop_end\r\n        #endif\r\n    #endif\r\n    #if defined( RE_IndirectSpecular )\r\n        vec3 radiance = vec3( 0.0 );\r\n        vec3 clearcoatRadiance = vec3( 0.0 );\r\n    #endif\r\n\r\n\r\n    #if defined( RE_IndirectDiffuse )\r\n        #ifdef USE_LIGHTMAP\r\n            vec4 lightMapTexel = texture2D( lightMap, vUv2 );\r\n            vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\r\n            irradiance += lightMapIrradiance;\r\n        #endif\r\n        #if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\r\n            iblIrradiance += getIBLIrradiance( currentGeometry.normal );\r\n        #endif\r\n    #endif\r\n    #if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\r\n        radiance += getIBLRadianceVariation( currentGeometry.viewDir, currentGeometry.normal, material.roughness );\r\n        #ifdef USE_CLEARCOAT\r\n            clearcoatRadiance += getIBLRadianceVariation( currentGeometry.viewDir, currentGeometry.clearcoatNormal, material.clearcoatRoughness );\r\n        #endif\r\n    #endif\r\n\r\n    #if defined( RE_IndirectDiffuse )\r\n        RE_IndirectDiffuse( irradiance, currentGeometry, material, rLight );\r\n    #endif\r\n    #if defined( RE_IndirectSpecular )\r\n        RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, currentGeometry, material, rLight );\r\n    #endif\r\n\r\n\tif(depth >= 0) {\r\n\t\tfloat frac = float(depth) / float(TRACING_DEPTH);\r\n\t\tvec3 colorTransfer = (1.0-frac) * colorTransferBegin + frac * colorTransferEnd;\r\n\t\trLight.indirectSpecular *= colorTransfer;\r\n\t\trLight.directSpecular *= colorTransfer;\r\n\t}\r\n\r\n\tvec3 color = rLight.indirectSpecular + rLight.directSpecular + rLight.indirectDiffuse + rLight.directDiffuse;\r\n\r\n\t// gamma\r\n\tcolor = pow(color, vec3(1.0/gamma)); \r\n\r\n\t// contrast\r\n\tcolor.rgb = ((color.rgb - 0.5) * max(contrast, 0.0)) + 0.5; \r\n\r\n\t// brightness\r\n\tcolor.r = min(max(color.r + brightness, 0.0), 1.0);\r\n\tcolor.g = min(max(color.g + brightness, 0.0), 1.0);\r\n\tcolor.b = min(max(color.b + brightness, 0.0), 1.0);\r\n\r\n\treturn color;\r\n}\r\n\r\nvec3 normalLookUp(vec3 dir) {\r\n\tvec4 s = textureCube(sphericalNormalMap, dir);\r\n\tif(s.a < 1.0/256.0) {\r\n\t\treturn normalize(vec3(-s.x, -s.y, -s.z));\r\n\t} else if(s.a < 3.0/256.0) {\r\n\t\treturn normalize(vec3(-s.x, -s.y, s.z));\r\n\t} else if(s.a < 5.0/256.0) {\r\n\t\treturn normalize(vec3(-s.x, s.y, -s.z));\r\n\t} else if(s.a < 7.0/256.0) {\r\n\t\treturn normalize(vec3(s.x, -s.y, -s.z));\r\n\t} else if(s.a < 9.0/256.0) {\r\n\t\treturn normalize(vec3(-s.x, s.y, s.z));\r\n\t} else if(s.a < 11.0/256.0) {\r\n\t\treturn normalize(vec3(s.x, -s.y, s.z));\r\n\t} else if(s.a < 13.0/256.0) {\r\n\t\treturn normalize(vec3(s.x, s.y, -s.z));\r\n\t} else {\r\n\t\treturn normalize(s.xyz);\r\n\t}\r\n}\r\n\r\n#ifdef USE_IMPURITYMAP\r\n\tfloat impurityLookUp(vec3 dir) {\r\n\t\tvec3 c = textureCube(impurityMap, dir.xy).rgb;\r\n\t\treturn (c.x + c.y + c.z) / 3.0;\r\n\t}\r\n#endif\r\n\r\nvec3 raySphereIntersection(vec3 o, vec3 d) {\r\n\r\n\tvec3 oc = o - center;\r\n    float a = dot(d, d);\r\n    float b = 2.0 * dot(oc, d);\r\n    float c = dot(oc,oc) - radius*radius;\r\n    float discriminant = b*b - 4.0*a*c;\r\n    if(discriminant < 0.0){\r\n        return vec3(0.0);\r\n    }\r\n    else{\r\n        return o +( (-b + sqrt(discriminant)) / (2.0*a)) * d;\r\n    }\r\n}\r\n\r\nvec3 hueToSaturatedColor(float hue) {\r\n    float r,g,b;\r\n    if (hue < 0.25){\r\n\t\tfloat t = 1.0 - (hue / 0.25);\r\n        r = 1.0;\r\n        g = 1.0;\r\n        b = t;    \r\n\t} else if (hue < 0.5){\r\n    \tfloat t = 1.0 - (hue - 0.25 / 0.25);\r\n\t\tr = 1.0;\r\n        g = t;\r\n        b = 0.0;\r\n\t} else if (hue < 0.75){\r\n    \tfloat t = 1.0 - (hue - 0.5 / 0.25);\r\n\t\tr = t;\r\n        g = 0.0;\r\n        b = 1.0 - t;\r\n    } else {\r\n    \tfloat t = hue - 0.75 / 0.25;\r\n        r = t;\r\n        g = t;\r\n        b = 1.0;\r\n    }\r\n    return vec3(r, g, b) / 0.5 + 0.5;\r\n}\r\n// CUSTOM END\r\n\r\nvoid main() {    \r\n    // CUSTOM START\r\n    vec3 frag_normal_normalized = frag_normal;\r\n    // CUSTOM END\r\n\t#include <clipping_planes_fragment>\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <roughnessmap_fragment>\r\n\t#include <metalnessmap_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\t#include <clearcoat_normal_fragment_begin>\r\n\t#include <clearcoat_normal_fragment_maps>\r\n\t#include <emissivemap_fragment>\r\n\t#include <lights_physical_fragment>\r\n\t#include <lights_fragment_begin>\r\n\t#include <lights_fragment_maps>\r\n\t#include <lights_fragment_end>\r\n\t#include <aomap_fragment>\r\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\r\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\r\n\t#include <transmission_fragment>\r\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\r\n\t#ifdef USE_SHEEN\r\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\r\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\r\n\t#endif\r\n\t#ifdef USE_CLEARCOAT\r\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\r\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\r\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\r\n\t#endif\r\n\t#include <output_fragment>\r\n\r\n    // CUSTOM START\r\n    \r\n\tmat4 inverseMM = inverse( modelMatrix );\r\n    \r\n\tvec3 initialDirection = normalize( frag_position - (inverseMM*vec4(cameraPosition,1.0)).xyz );\r\n\r\n\tvec4 outgoingLight2;\r\n\tfloat r_0 = (1.0-refractionIndex)/(1.0+refractionIndex);\r\n\tr_0 = r_0*r_0;\r\n\r\n\tfloat cos_theta_0 = -dot(initialDirection, frag_normal_normalized);\r\n\tfloat r_0_outside = (refractionIndex-1.0)/(refractionIndex+1.0);\r\n\tr_0_outside = r_0_outside*r_0_outside;\r\n\tfloat initialProbability = r_0_outside + (1.0 - r_0_outside)*pow(1.0 - cos_theta_0, 5.0);\r\n\r\n\toutgoingLight2 = vec4(calculateReflectedLight(frag_position, frag_normal_normalized, initialDirection, material, -1), 1.0);\r\n\t// gl_FragColor = outgoingLight2;\r\n\t// return;\r\n\tif(TRACING_DEPTH > 0) \r\n\t\toutgoingLight2 *= initialProbability;\r\n\t\t\r\n\tvec3 tempColor;\r\n\r\n\t#ifdef DISPERSION\r\n\t\tconst int loop = 3;\r\n\t\tvec3 dispersionColor;\r\n\t#else\r\n\t\tconst int loop = 1;\r\n\t#endif\r\n\t\t#pragma unroll_loop_start\r\n\t\tfor(int j = 0; j < loop; j++){\r\n\t\t\tvec3 refractedDirection = refract(initialDirection, frag_normal_normalized, 1.0/refractionIndex + float(j)*dispersion * 0.025);\r\n\t\t\tvec3 newPosition = raySphereIntersection(frag_position, refractedDirection);\r\n\t\t\tvec3 lookUpVector = normalize(newPosition - center);\r\n\t\t\tvec3 newNormal = normalLookUp(lookUpVector);\r\n\t\t\tvec3 newDirection = reflect(refractedDirection, newNormal);\r\n\r\n\t\t\tfloat currentProbability = 1.0;\r\n\r\n\t\t\t#ifdef USE_IMPURITYMAP\r\n\t\t\t\tfloat impurityProbability = impurityLookUp(lookUpVector);\r\n\t\t\t\tcurrentProbability -= impurityProbability * impurityScale;\r\n\t\t\t\t// gl_FragColor = vec4(vec3(impurityProbability), 1.0);\r\n\t\t\t\t// return;\r\n\t\t\t#endif\r\n\t\t\t\r\n\t\t\t// if(0 == TRACING_DEPTH) {\r\n\t\t\t// \tgl_FragColor = vec4(0.5 * newNormal + 0.5, 1.0);\r\n\t\t\t// \treturn;\r\n\t\t\t// }\r\n\r\n\t\t\ttempColor = vec3(0.0);\r\n\t\t\t#pragma unroll_loop_start\r\n\t\t\tfor(int i = 0; i < TRACING_DEPTH; i++) {\r\n\t\t\t\t// small position correction to avoid artefacts\r\n\t\t\t\tnewPosition = newPosition - lookUpVector * 1e-6;\r\n\t\t\t\tnewPosition = raySphereIntersection(newPosition, newDirection);\r\n\t\t\t\tlookUpVector = normalize(newPosition - center);\r\n\t\t\t\tnewNormal = normalLookUp(lookUpVector);\r\n\t\t\t\r\n\t\t\t\tfloat cos_theta = dot(newDirection, newNormal);\r\n\t\t\t\tfloat ratio;\r\n\t\t\t\tif(cos_theta > 0.0) {\r\n\t\t\t\t\tratio = refractionIndex;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcos_theta = -cos_theta;\r\n\t\t\t\t\tratio = 1.0 / refractionIndex;\r\n\t\t\t\t}\r\n\t\t\t\tfloat cos_theta_2 = 1.0 - ratio*ratio * (1.0 - cos_theta*cos_theta);\r\n\t\t\t\tfloat probability = r_0 + (1.0 - r_0)*pow(1.0 - cos_theta, 5.0);\r\n\t\t\t\tif(cos_theta_2 < 0.0) probability = 0.0;\r\n\r\n\t\t\t\tvec3 refracted = refract(newDirection, newNormal*-1.0, 1.0/refractionIndex);\r\n\t\t\t\ttempColor += probability * currentProbability * calculateReflectedLight(newPosition, newNormal*-1.0, reflect(refracted, newNormal), material, i);\r\n\t\t\t\tif(i+1 == TRACING_DEPTH)\r\n\t\t\t\t\ttempColor += (1.0 - probability) * currentProbability * calculateReflectedLight(newPosition, newNormal, newDirection, material, i);\r\n\r\n\t\t\t\tnewDirection = reflect(newDirection, newNormal);\r\n\r\n\t\t\t\t// if(i+1 == TRACING_DEPTH) {\r\n\t\t\t\t// \tgl_FragColor = vec4(0.5 * newNormal + 0.5, 1.0);\r\n\t\t\t\t// \treturn;\r\n\t\t\t\t// }\r\n\r\n\t\t\t\tcurrentProbability *= (1.0 - probability);\r\n\t\t\t}\r\n\t\t\t#pragma unroll_loop_end\r\n\r\n\t\t\t#ifdef DISPERSION\r\n\t\t\t\tif(j == 0) {\r\n\t\t\t\t\tdispersionColor.r = tempColor.r;\t\r\n\t\t\t\t} else if(j == 1) {\r\n\t\t\t\t\tdispersionColor.g = tempColor.g;\t\r\n\t\t\t\t} else if(j == 2) {\r\n\t\t\t\t\tdispersionColor.b = tempColor.b;\t\r\n\t\t\t\t}\r\n\t\t\t\ttempColor = dispersionColor;\r\n\t\t\t#endif\r\n\t\t}\t\r\n\t\t#pragma unroll_loop_end\r\n\r\n\tif(TRACING_DEPTH > 0)\r\n\t\toutgoingLight2.rgb += (1.0 - initialProbability) * tempColor;\r\n\r\n\tfloat alpha = (1.0 - initialProbability) + initialProbability*tracingOpacity;\r\n\tgl_FragColor = vec4(outgoingLight2.rgb, alpha*diffuseColor.a);\r\n\r\n    // CUSTOM END\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n}\r\n\r\n`"]}},"error":null,"hash":"de5daa3626da697c56dafe732d647e0f","cacheData":{"env":{}}}