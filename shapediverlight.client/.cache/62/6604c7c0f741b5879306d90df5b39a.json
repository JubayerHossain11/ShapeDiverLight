{"id":"M3KF","dependencies":[{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\dist\\shaders\\PCSS.js.map","includedInParent":true,"mtime":1706476152188},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\src\\shaders\\PCSS.ts","includedInParent":true,"mtime":1706476152891},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\package.json","includedInParent":true,"mtime":1706476652643},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\package.json","includedInParent":true,"mtime":1706476151754}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.entry=exports.main=void 0,exports.main=\"\\n\\nuniform float lightSizeUV;\\nuniform float blending;\\n\\n#ifdef SHADOWMAP_TYPE_PCF\\n\\n#define NEAR_PLANE 0.1\\n#define NUM_SAMPLES 20\\n#define NUM_RINGS 11\\n\\nvec2 poissonDisk[NUM_SAMPLES];\\n\\nvoid initPoissonSamples( const in vec2 randomSeed ) {\\n    float ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\\n    float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\\n\\n    // jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\\n    float angle = rand(randomSeed) * PI2;\\n    float radius = INV_NUM_SAMPLES;\\n    float radiusStep = radius;\\n\\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\\n        poissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\\n        radius += radiusStep;\\n        angle += ANGLE_STEP;\\n    }\\n}\\n\\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\\n    return (zReceiver - zBlocker) / zBlocker;\\n}\\n\\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\\n    // This uses similar triangles to compute what\\n    // area of the shadow map we should search\\n    float searchRadius = lightSizeUV * (zReceiver - NEAR_PLANE) / zReceiver;\\n    float blockerDepthSum = 0.0;\\n    int numBlockers = 0;\\n\\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\\n        float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\\n        if (shadowMapDepth < zReceiver) {\\n            blockerDepthSum += shadowMapDepth;\\n            numBlockers++;\\n        }\\n    }\\n\\n    if (numBlockers == 0) return -1.0;\\n\\n    return blockerDepthSum / float(numBlockers);\\n}\\n\\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\\n    float sum = 0.0;\\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\\n        float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * filterRadius));\\n        if (zReceiver <= depth) sum += 1.0;\\n    }\\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\\n        float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[i].yx * filterRadius));\\n        if (zReceiver <= depth) sum += 1.0;\\n    }\\n    return sum / (2.0 * float(NUM_SAMPLES));\\n}\\n\\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\\n    vec2 uv = coords.xy;\\n    float zReceiver = coords.z; // Assumed to be eye-space z in this code\\n\\n    initPoissonSamples(uv);\\n    // STEP 1: blocker search\\n    float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\\n\\n    //There are no occluders so early out (this saves filtering)\\n    if (avgBlockerDepth == -1.0) return 1.0;\\n\\n    // STEP 2: penumbra size\\n    float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\\n    float filterRadius = penumbraRatio * lightSizeUV * NEAR_PLANE / zReceiver;\\n\\n    // STEP 3: filtering\\n    //return avgBlockerDepth;\\n    return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\\n}\\n#endif\\n\",exports.entry=\"\\n// PCSS implementation\\nvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\nfloat dx = texelSize.x;\\nfloat dy = texelSize.y;\\nvec2 uv = shadowCoord.xy;\\nvec2 f = fract( uv * shadowMapSize + 0.5 );\\nuv -= f * texelSize;\\nfloat shadow1 = (\\n    texture2DCompare( shadowMap, uv, shadowCoord.z ) +\\n    texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\n    texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\n    texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\n    mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \\n         texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\n         f.x ) +\\n    mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \\n         texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\n         f.x ) +\\n    mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \\n         texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\n         f.y ) +\\n    mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \\n         texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n         f.y ) +\\n    mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \\n              texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\n              f.x ),\\n         mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \\n              texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\n              f.x ),\\n         f.y )\\n) * ( 1.0 / 9.0 );\\nfloat shadow2 = PCSS( shadowMap, shadowCoord );\\nshadow = shadow1 * (1.0 - blending) + blending * shadow2;\\n            \";"},"sourceMaps":{"js":{"mappings":[{"source":"../../src/shaders/PCSS.ts","name":null,"original":{"line":1,"column":13},"generated":{"line":1,"column":102}},{"source":"../../src/shaders/PCSS.ts","name":null,"original":{"line":1,"column":13},"generated":{"line":1,"column":110}},{"source":"../../src/shaders/PCSS.ts","name":null,"original":{"line":1,"column":20},"generated":{"line":1,"column":115}},{"source":"../../src/shaders/PCSS.ts","name":null,"original":{"line":89,"column":13},"generated":{"line":1,"column":3039}},{"source":"../../src/shaders/PCSS.ts","name":null,"original":{"line":89,"column":13},"generated":{"line":1,"column":3047}},{"source":"../../src/shaders/PCSS.ts","name":null,"original":{"line":89,"column":21},"generated":{"line":1,"column":3053}}],"sources":{"../../src/shaders/PCSS.ts":"export const main = `\r\n\r\nuniform float lightSizeUV;\r\nuniform float blending;\r\n\r\n#ifdef SHADOWMAP_TYPE_PCF\r\n\r\n#define NEAR_PLANE 0.1\r\n#define NUM_SAMPLES 20\r\n#define NUM_RINGS 11\r\n\r\nvec2 poissonDisk[NUM_SAMPLES];\r\n\r\nvoid initPoissonSamples( const in vec2 randomSeed ) {\r\n    float ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\r\n    float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\r\n\r\n    // jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\r\n    float angle = rand(randomSeed) * PI2;\r\n    float radius = INV_NUM_SAMPLES;\r\n    float radiusStep = radius;\r\n\r\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\r\n        poissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\r\n        radius += radiusStep;\r\n        angle += ANGLE_STEP;\r\n    }\r\n}\r\n\r\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\r\n    return (zReceiver - zBlocker) / zBlocker;\r\n}\r\n\r\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\r\n    // This uses similar triangles to compute what\r\n    // area of the shadow map we should search\r\n    float searchRadius = lightSizeUV * (zReceiver - NEAR_PLANE) / zReceiver;\r\n    float blockerDepthSum = 0.0;\r\n    int numBlockers = 0;\r\n\r\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\r\n        float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\r\n        if (shadowMapDepth < zReceiver) {\r\n            blockerDepthSum += shadowMapDepth;\r\n            numBlockers++;\r\n        }\r\n    }\r\n\r\n    if (numBlockers == 0) return -1.0;\r\n\r\n    return blockerDepthSum / float(numBlockers);\r\n}\r\n\r\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\r\n    float sum = 0.0;\r\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\r\n        float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * filterRadius));\r\n        if (zReceiver <= depth) sum += 1.0;\r\n    }\r\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\r\n        float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[i].yx * filterRadius));\r\n        if (zReceiver <= depth) sum += 1.0;\r\n    }\r\n    return sum / (2.0 * float(NUM_SAMPLES));\r\n}\r\n\r\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\r\n    vec2 uv = coords.xy;\r\n    float zReceiver = coords.z; // Assumed to be eye-space z in this code\r\n\r\n    initPoissonSamples(uv);\r\n    // STEP 1: blocker search\r\n    float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\r\n\r\n    //There are no occluders so early out (this saves filtering)\r\n    if (avgBlockerDepth == -1.0) return 1.0;\r\n\r\n    // STEP 2: penumbra size\r\n    float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\r\n    float filterRadius = penumbraRatio * lightSizeUV * NEAR_PLANE / zReceiver;\r\n\r\n    // STEP 3: filtering\r\n    //return avgBlockerDepth;\r\n    return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\r\n}\r\n#endif\r\n`;\r\n\r\nexport const entry = `\r\n// PCSS implementation\r\nvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\nfloat dx = texelSize.x;\r\nfloat dy = texelSize.y;\r\nvec2 uv = shadowCoord.xy;\r\nvec2 f = fract( uv * shadowMapSize + 0.5 );\r\nuv -= f * texelSize;\r\nfloat shadow1 = (\r\n    texture2DCompare( shadowMap, uv, shadowCoord.z ) +\r\n    texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\r\n    texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\r\n    texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\r\n    mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \r\n         texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\r\n         f.x ) +\r\n    mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \r\n         texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\r\n         f.x ) +\r\n    mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \r\n         texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\r\n         f.y ) +\r\n    mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \r\n         texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\r\n         f.y ) +\r\n    mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \r\n              texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\r\n              f.x ),\r\n         mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \r\n              texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\r\n              f.x ),\r\n         f.y )\r\n) * ( 1.0 / 9.0 );\r\nfloat shadow2 = PCSS( shadowMap, shadowCoord );\r\nshadow = shadow1 * (1.0 - blending) + blending * shadow2;\r\n            `"},"lineCount":null}},"error":null,"hash":"63d459bcf2fbc84b55f096bea14d1839","cacheData":{"env":{}}}