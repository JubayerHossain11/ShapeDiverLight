{"id":"node_modules/@shapediver/viewer.data-engine.geometry-engine/dist/gltfv2/loaders/GeometryLoader.js","dependencies":[{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv2\\loaders\\GeometryLoader.js.map","includedInParent":true,"mtime":1706542087154},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\src\\gltfv2\\loaders\\GeometryLoader.ts","includedInParent":true,"mtime":1706542087317},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\package.json","includedInParent":true,"mtime":1706542184022},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\package.json","includedInParent":true,"mtime":1706542086828},{"name":"@shapediver/viewer.shared.node-tree","loc":{"line":4,"column":42,"index":155},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv2\\loaders\\GeometryLoader.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.node-tree\\dist\\index.js"},{"name":"@shapediver/viewer.shared.types","loc":{"line":5,"column":38,"index":234},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv2\\loaders\\GeometryLoader.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.types\\dist\\index.js"},{"name":"../GLTFLoader","loc":{"line":6,"column":29,"index":300},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv2\\loaders\\GeometryLoader.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv2\\GLTFLoader.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GeometryLoader = void 0;\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst GLTFLoader_1 = require(\"../GLTFLoader\");\r\nclass GeometryLoader {\r\n    // #endregion Properties (1)\r\n    // #region Constructors (1)\r\n    constructor(_content, _accessorLoader, _bufferViewLoader, _materialLoader, _dracoModule) {\r\n        this._content = _content;\r\n        this._accessorLoader = _accessorLoader;\r\n        this._bufferViewLoader = _bufferViewLoader;\r\n        this._materialLoader = _materialLoader;\r\n        this._dracoModule = _dracoModule;\r\n        // #region Properties (1)\r\n        this._materialVariantsData = new viewer_shared_types_1.MaterialVariantsData();\r\n        this._loaded = {};\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Accessors (1)\r\n    get materialVariantsData() {\r\n        return this._materialVariantsData;\r\n    }\r\n    // #endregion Public Accessors (1)\r\n    // #region Public Methods (1)\r\n    loadMesh(meshId, weights) {\r\n        if (!this._content.meshes)\r\n            throw new Error('GeometryLoader.loadMesh: Meshes not available.');\r\n        if (!this._content.meshes[meshId])\r\n            throw new Error('GeometryLoader.loadMesh: Mesh not available.');\r\n        const mesh = this._content.meshes[meshId];\r\n        const meshNode = new viewer_shared_node_tree_1.TreeNode(mesh.name || 'mesh_' + meshId);\r\n        if (mesh.primitives)\r\n            for (let i = 0, len = mesh.primitives.length; i < len; i++)\r\n                meshNode.addChild(this.loadPrimitive(meshId, mesh.primitives, i, mesh.weights || weights));\r\n        return meshNode;\r\n    }\r\n    // #endregion Public Methods (1)\r\n    // #region Private Methods (1)\r\n    loadPrimitive(meshId, primitives, index, weights = []) {\r\n        const primitive = primitives[index];\r\n        const primitiveNode = new viewer_shared_node_tree_1.TreeNode('primitive_' + index);\r\n        if (this._loaded['mesh_' + meshId + '_primitive_' + index]) {\r\n            primitiveNode.data.push(this._loaded['mesh_' + meshId + '_primitive_' + index].clone());\r\n            return primitiveNode;\r\n        }\r\n        const attributes = {};\r\n        let indices = null;\r\n        const convertedNames = {};\r\n        if (primitive.extensions && primitive.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\r\n            const dracoDef = primitive.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\r\n            const arrayBuffer = this._bufferViewLoader.getBufferView(dracoDef.bufferView);\r\n            const decoder = new this._dracoModule.Decoder();\r\n            const array = new Int8Array(arrayBuffer);\r\n            const geometryType = decoder.GetEncodedGeometryType(array);\r\n            let dracoGeometry;\r\n            if (geometryType === this._dracoModule.TRIANGULAR_MESH) {\r\n                dracoGeometry = new this._dracoModule.Mesh();\r\n                decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);\r\n            }\r\n            else if (geometryType === this._dracoModule.POINT_CLOUD) {\r\n                dracoGeometry = new this._dracoModule.PointCloud();\r\n                decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);\r\n            }\r\n            if (dracoDef.attributes['POSITION'] === undefined) {\r\n                const errorMsg = \"No position attribute found in the mesh.\";\r\n                this._dracoModule.destroy(decoder);\r\n                this._dracoModule.destroy(dracoGeometry);\r\n                throw new Error(errorMsg);\r\n            }\r\n            for (let a in dracoDef.attributes) {\r\n                const attribute = decoder.GetAttributeByUniqueId(dracoGeometry, dracoDef.attributes[a]);\r\n                const attributeData = new this._dracoModule.DracoFloat32Array();\r\n                decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, attributeData);\r\n                const byteOffset = attribute.byte_offset();\r\n                const normalized = attribute.normalized();\r\n                const numComponents = attribute.num_components();\r\n                const numPoints = dracoGeometry.num_points();\r\n                const numValues = numPoints * numComponents;\r\n                const byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;\r\n                const ptr = this._dracoModule._malloc(byteLength);\r\n                decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, this._dracoModule.DT_FLOAT32, byteLength, ptr);\r\n                const array = new Float32Array(this._dracoModule.HEAPF32.buffer, ptr, numValues).slice();\r\n                this._dracoModule._free(ptr);\r\n                if (a.includes(\"COLOR\"))\r\n                    array.forEach((n, i) => array[i] = Math.max(0, Math.min(1, n)));\r\n                attributes[a] = new viewer_shared_types_1.AttributeData(array, numComponents, // itemSize\r\n                array.BYTES_PER_ELEMENT * numComponents, // itemBytes = elementBytes * itemSize\r\n                byteOffset, // byteOffset\r\n                array.BYTES_PER_ELEMENT, // elementBytes\r\n                normalized, // normalized\r\n                array.length / numComponents);\r\n            }\r\n            if (geometryType == this._dracoModule.TRIANGULAR_MESH) {\r\n                const numFaces = dracoGeometry.num_faces();\r\n                const numIndices = numFaces * 3;\r\n                const byteLength = numIndices * 4;\r\n                const ptr = this._dracoModule._malloc(byteLength);\r\n                decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\r\n                const indexArray = new Uint32Array(this._dracoModule.HEAPF32.buffer, ptr, numIndices).slice();\r\n                this._dracoModule._free(ptr);\r\n                indices = new viewer_shared_types_1.AttributeData(indexArray, 1, // itemSize\r\n                indexArray.BYTES_PER_ELEMENT * 1, // itemBytes = elementBytes * itemSize\r\n                0, // byteOffset\r\n                indexArray.BYTES_PER_ELEMENT, // elementBytes\r\n                false, // normalized\r\n                indexArray.length // count\r\n                );\r\n            }\r\n            this._dracoModule.destroy(decoder);\r\n            this._dracoModule.destroy(dracoGeometry);\r\n        }\r\n        for (let attribute in primitive.attributes) {\r\n            if (attributes[attribute]) {\r\n                convertedNames[attribute] = attribute;\r\n                continue;\r\n            }\r\n            let attributeName = attribute;\r\n            // attribute name conversion to be consistent with gltf\r\n            if (/\\d/.test(attributeName) && !attributeName.includes('_')) {\r\n                const index = attributeName.search(/\\d/);\r\n                attributeName = attributeName.substring(0, index) + '_' + attributeName.substring(index, attributeName.length);\r\n            }\r\n            else if (attributeName === 'TEXCOORD' || attributeName === 'COLOR' || attributeName === 'JOINTS' || attributeName === 'WEIGHTS') {\r\n                attributeName += '_0';\r\n            }\r\n            else if (attributeName === 'UV') {\r\n                attributeName = 'TEXCOORD_0';\r\n            }\r\n            convertedNames[attribute] = attributeName;\r\n            attributes[attributeName] = (this._accessorLoader.getAccessor(primitive.attributes[attribute]));\r\n        }\r\n        if ((primitive.indices || primitive.indices === 0) && !indices)\r\n            indices = this._accessorLoader.getAccessor(primitive.indices);\r\n        // reading and assigning morph targets\r\n        if (primitive.targets) {\r\n            for (let i = 0; i < primitive.targets.length; i++) {\r\n                for (let target in primitive.targets[i]) {\r\n                    if (!attributes[target])\r\n                        continue;\r\n                    attributes[convertedNames[target]].morphAttributeData.push((this._accessorLoader.getAccessor(primitive.targets[i][target])));\r\n                }\r\n            }\r\n        }\r\n        let material = null;\r\n        if (primitive.material || primitive.material === 0)\r\n            material = this._materialLoader.getMaterial(primitive.material);\r\n        const primitiveData = new viewer_shared_types_1.PrimitiveData(attributes, indices);\r\n        const geometryData = new viewer_shared_types_1.GeometryData(primitiveData, primitive.mode, material);\r\n        if (primitive.extensions && primitive.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_VARIANTS]) {\r\n            this._materialVariantsData.geometryData.push(geometryData);\r\n            const variantsExtension = primitive.extensions[GLTFLoader_1.GLTF_EXTENSIONS.KHR_MATERIALS_VARIANTS];\r\n            for (let i = 0; i < variantsExtension.mappings.length; i++) {\r\n                const mapping = variantsExtension.mappings[i];\r\n                const material = this._materialLoader.getMaterial(mapping.material);\r\n                for (let j = 0; j < mapping.variants.length; j++)\r\n                    geometryData.materialVariants.push({ variant: mapping.variants[j], material });\r\n            }\r\n        }\r\n        geometryData.morphWeights = weights;\r\n        this._loaded['mesh_' + meshId + '_primitive_' + index] = geometryData;\r\n        primitiveNode.data.push(geometryData);\r\n        return primitiveNode;\r\n    }\r\n}\r\nexports.GeometryLoader = GeometryLoader;\r\n"},"sourceMaps":{"js":{"version":3,"file":"GeometryLoader.js","sourceRoot":"","sources":["../../../src/gltfv2/loaders/GeometryLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import { IGLTF_v2, IGLTF_v2_Primitive } from '@shapediver/viewer.data-engine.shared-types'\r\nimport { ITreeNode, TreeNode } from '@shapediver/viewer.shared.node-tree'\r\nimport { AttributeData, GeometryData, MaterialVariantsData, PrimitiveData } from '@shapediver/viewer.shared.types'\r\n\r\nimport { GLTF_EXTENSIONS } from '../GLTFLoader'\r\nimport { AccessorLoader } from './AccessorLoader'\r\nimport { BufferViewLoader } from './BufferViewLoader'\r\nimport { MaterialLoader } from './MaterialLoader'\r\n\r\nexport class GeometryLoader {\r\n    // #region Properties (1)\r\n\r\n    private _materialVariantsData = new MaterialVariantsData();\r\n    private _loaded: {\r\n        [key: string]: GeometryData\r\n    } = {};\r\n\r\n    // #endregion Properties (1)\r\n\r\n    // #region Constructors (1)\r\n\r\n    constructor(\r\n        private readonly _content: IGLTF_v2,\r\n        private readonly _accessorLoader: AccessorLoader,\r\n        private readonly _bufferViewLoader: BufferViewLoader,\r\n        private readonly _materialLoader: MaterialLoader,\r\n        private readonly _dracoModule: any\r\n    ) { }\r\n\r\n    // #endregion Constructors (1)\r\n\r\n    // #region Public Accessors (1)\r\n\r\n    public get materialVariantsData(): MaterialVariantsData {\r\n        return this._materialVariantsData;\r\n    }\r\n\r\n    // #endregion Public Accessors (1)\r\n\r\n    // #region Public Methods (1)\r\n\r\n    public loadMesh(meshId: number, weights?: number[]): ITreeNode {\r\n        if (!this._content.meshes) throw new Error('GeometryLoader.loadMesh: Meshes not available.')\r\n        if (!this._content.meshes[meshId]) throw new Error('GeometryLoader.loadMesh: Mesh not available.')\r\n        \r\n        const mesh = this._content.meshes[meshId];\r\n        const meshNode = new TreeNode(mesh.name || 'mesh_' + meshId);\r\n\r\n        if (mesh.primitives)\r\n            for (let i = 0, len = mesh.primitives.length; i < len; i++)\r\n                meshNode.addChild(this.loadPrimitive(meshId, mesh.primitives, i, mesh.weights || weights));\r\n\r\n        return meshNode;\r\n    }\r\n\r\n    // #endregion Public Methods (1)\r\n\r\n    // #region Private Methods (1)\r\n\r\n    private loadPrimitive(meshId: number, primitives: IGLTF_v2_Primitive[], index: number, weights: number[] = []): ITreeNode {\r\n        const primitive = primitives[index];\r\n        const primitiveNode = new TreeNode('primitive_' + index);\r\n\r\n        if (this._loaded['mesh_' + meshId + '_primitive_' + index]) {\r\n            primitiveNode.data.push(this._loaded['mesh_' + meshId + '_primitive_' + index].clone());\r\n            return primitiveNode;\r\n        }\r\n\r\n        const attributes: {\r\n            [key: string]: AttributeData\r\n        } = {};\r\n\r\n        let indices = null;\r\n        const convertedNames: { [key: string]: string } = {}\r\n\r\n        if (primitive.extensions && primitive.extensions[GLTF_EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\r\n            const dracoDef = primitive.extensions[GLTF_EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\r\n            const arrayBuffer = this._bufferViewLoader.getBufferView(dracoDef.bufferView!);\r\n\r\n            const decoder = new this._dracoModule.Decoder();\r\n            const array = new Int8Array(arrayBuffer);\r\n            const geometryType = decoder.GetEncodedGeometryType(array);\r\n\r\n            let dracoGeometry;\r\n            if (geometryType === this._dracoModule.TRIANGULAR_MESH) {\r\n                dracoGeometry = new this._dracoModule.Mesh();\r\n                decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);\r\n            } else if (geometryType === this._dracoModule.POINT_CLOUD) {\r\n                dracoGeometry = new this._dracoModule.PointCloud();\r\n                decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);\r\n            }\r\n\r\n            if (dracoDef.attributes['POSITION'] === undefined) {\r\n                const errorMsg = \"No position attribute found in the mesh.\";\r\n                this._dracoModule.destroy(decoder);\r\n                this._dracoModule.destroy(dracoGeometry);\r\n                throw new Error(errorMsg);\r\n            }\r\n\r\n            for (let a in dracoDef.attributes) {\r\n                const attribute = decoder.GetAttributeByUniqueId(dracoGeometry, dracoDef.attributes[a])\r\n                const attributeData = new this._dracoModule.DracoFloat32Array();\r\n                decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, attributeData);\r\n\r\n                const byteOffset = attribute.byte_offset();\r\n                const normalized = attribute.normalized();\r\n                const numComponents = attribute.num_components();\r\n\r\n                const numPoints = dracoGeometry.num_points();\r\n                const numValues = numPoints * numComponents;\r\n                const byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;\r\n\r\n                const ptr = this._dracoModule._malloc(byteLength);\r\n                decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, this._dracoModule.DT_FLOAT32, byteLength, ptr);\r\n                const array = new Float32Array(this._dracoModule.HEAPF32.buffer, ptr, numValues).slice();\r\n                this._dracoModule._free(ptr);\r\n\r\n                if(a.includes(\"COLOR\")) array.forEach((n, i) => array[i] = Math.max(0, Math.min(1, n)));\r\n\r\n                attributes[a] = new AttributeData(\r\n                    array,\r\n                    numComponents, // itemSize\r\n                    array.BYTES_PER_ELEMENT * numComponents, // itemBytes = elementBytes * itemSize\r\n                    byteOffset, // byteOffset\r\n                    array.BYTES_PER_ELEMENT, // elementBytes\r\n                    normalized, // normalized\r\n                    array.length / numComponents\r\n                );\r\n            }\r\n\r\n            if (geometryType == this._dracoModule.TRIANGULAR_MESH) {\r\n\r\n                const numFaces = dracoGeometry.num_faces();\r\n                const numIndices = numFaces * 3;\r\n                const byteLength = numIndices * 4;\r\n\r\n                const ptr = this._dracoModule._malloc(byteLength);\r\n                decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\r\n                const indexArray = new Uint32Array(this._dracoModule.HEAPF32.buffer, ptr, numIndices).slice();\r\n                this._dracoModule._free(ptr);\r\n\r\n                indices = new AttributeData(\r\n                    indexArray,\r\n                    1, // itemSize\r\n                    indexArray.BYTES_PER_ELEMENT * 1, // itemBytes = elementBytes * itemSize\r\n                    0, // byteOffset\r\n                    indexArray.BYTES_PER_ELEMENT, // elementBytes\r\n                    false, // normalized\r\n                    indexArray.length // count\r\n                );\r\n            }\r\n\r\n            this._dracoModule.destroy(decoder);\r\n            this._dracoModule.destroy(dracoGeometry);\r\n        }\r\n\r\n        for (let attribute in primitive.attributes) {\r\n            if (attributes[attribute]) {\r\n                convertedNames[attribute] = attribute;\r\n                continue;\r\n            }\r\n\r\n\r\n            let attributeName = attribute;\r\n            // attribute name conversion to be consistent with gltf\r\n            if (/\\d/.test(attributeName) && !attributeName.includes('_')) {\r\n                const index = attributeName.search(/\\d/)\r\n                attributeName = attributeName.substring(0, index) + '_' + attributeName.substring(index, attributeName.length);\r\n            } else if (attributeName === 'TEXCOORD' || attributeName === 'COLOR' || attributeName === 'JOINTS' || attributeName === 'WEIGHTS') {\r\n                attributeName += '_0';\r\n            } else if (attributeName === 'UV') {\r\n                attributeName = 'TEXCOORD_0';\r\n            }\r\n\r\n            convertedNames[attribute] = attributeName;\r\n            attributes[attributeName] = (this._accessorLoader.getAccessor(primitive.attributes[attribute]))!;\r\n        }\r\n\r\n        if ((primitive.indices || primitive.indices === 0) && !indices) \r\n            indices = this._accessorLoader.getAccessor(primitive.indices);\r\n\r\n        // reading and assigning morph targets\r\n        if (primitive.targets) {\r\n            for (let i = 0; i < primitive.targets.length; i++) {\r\n                for (let target in primitive.targets[i]) {\r\n                    if (!attributes[target]) continue;\r\n                    attributes[convertedNames[target]].morphAttributeData.push((this._accessorLoader.getAccessor(primitive.targets[i][target]))!);\r\n                }\r\n            }\r\n        }\r\n\r\n        let material = null;\r\n        if (primitive.material || primitive.material === 0) \r\n            material = this._materialLoader.getMaterial(primitive.material);\r\n\r\n        const primitiveData = new PrimitiveData(attributes, indices);\r\n        const geometryData = new GeometryData(primitiveData, primitive.mode, material);\r\n\r\n        if (primitive.extensions && primitive.extensions[GLTF_EXTENSIONS.KHR_MATERIALS_VARIANTS]) {\r\n            this._materialVariantsData.geometryData.push(geometryData);\r\n            const variantsExtension = primitive.extensions[GLTF_EXTENSIONS.KHR_MATERIALS_VARIANTS];\r\n\r\n            for (let i = 0; i < variantsExtension.mappings.length; i++) {\r\n                const mapping = variantsExtension.mappings[i];\r\n                const material = this._materialLoader.getMaterial(mapping.material);\r\n                for (let j = 0; j < mapping.variants.length; j++)\r\n                    geometryData.materialVariants.push({ variant: mapping.variants[j], material });\r\n            }\r\n        }\r\n\r\n        geometryData.morphWeights = weights;\r\n        this._loaded['mesh_' + meshId + '_primitive_' + index] = geometryData;\r\n\r\n        primitiveNode.data.push(geometryData);\r\n        return primitiveNode;\r\n    }\r\n\r\n    // #endregion Private Methods (1)\r\n}"]}},"error":null,"hash":"930320370992ed649b08b938454f4e93","cacheData":{"env":{}}}