{"id":"node_modules/@shapediver/viewer.shared.services/dist/http-client/HttpClient.js","dependencies":[{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\dist\\http-client\\HttpClient.js.map","includedInParent":true,"mtime":1706542086193},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\src\\http-client\\HttpClient.ts","includedInParent":true,"mtime":1706542086793},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\package.json","includedInParent":true,"mtime":1706542184022},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\package.json","includedInParent":true,"mtime":1706542085933},{"name":"axios","loc":{"line":16,"column":40,"index":981},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\dist\\http-client\\HttpClient.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\axios\\index.js"},{"name":"@shapediver/sdk.geometry-api-sdk-v2","loc":{"line":17,"column":42,"index":1035},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\dist\\http-client\\HttpClient.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\sdk.geometry-api-sdk-v2\\dist\\index.js"},{"name":"../logger/ShapeDiverBackendErrors","loc":{"line":18,"column":42,"index":1118},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\dist\\http-client\\HttpClient.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\dist\\logger\\ShapeDiverBackendErrors.js"}],"generated":{"js":"\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HttpClient = void 0;\r\nconst axios_1 = __importDefault(require(\"axios\"));\r\nconst sdk_geometry_api_sdk_v2_1 = require(\"@shapediver/sdk.geometry-api-sdk-v2\");\r\nconst ShapeDiverBackendErrors_1 = require(\"../logger/ShapeDiverBackendErrors\");\r\nclass HttpClient {\r\n    // #endregion Properties (2)\r\n    // #region Constructors (1)\r\n    constructor() {\r\n        this._sessionLoading = {};\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Static Accessors (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Accessors (1)\r\n    // #region Public Methods (5)\r\n    addDataLoading(sessionId, callbacks) {\r\n        this._sessionLoading[sessionId] = callbacks;\r\n    }\r\n    /**\r\n     * Maps the geometry backend error to the corresponding viewer errors:\r\n     * - ShapeDiverResponseError is mapped to ShapeDiverGeometryBackendResponseError\r\n     * - ShapeDiverRequestError is mapped to ShapeDiverGeometryBackendRequestError\r\n     *\r\n     * Other error types are thrown as is.\r\n     *\r\n     * @param e\r\n     */\r\n    convertError(e) {\r\n        if (e instanceof sdk_geometry_api_sdk_v2_1.ShapeDiverResponseError) {\r\n            throw new ShapeDiverBackendErrors_1.ShapeDiverGeometryBackendResponseError(e.message, e.status, e.error, e.desc);\r\n        }\r\n        else if (e instanceof sdk_geometry_api_sdk_v2_1.ShapeDiverRequestError) {\r\n            throw new ShapeDiverBackendErrors_1.ShapeDiverGeometryBackendRequestError(e.message, e.desc);\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n    get(href, config = { responseType: 'arraybuffer' }, textureLoading = false) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // try to get sessionId from href\r\n            let sessionId = this.getSessionId(href);\r\n            // if href does not have sessionId, use the first session, if available\r\n            if (!sessionId && Object.keys(this._sessionLoading).length > 0)\r\n                sessionId = Object.keys(this._sessionLoading)[0];\r\n            // get the session loading functions, if available\r\n            let sessionLoading;\r\n            if (sessionId)\r\n                sessionLoading = this._sessionLoading[sessionId];\r\n            // separation texture vs everything else\r\n            if (textureLoading) {\r\n                // if we have a sessionId and the sessionLoading functions and the image is not a blob or data, we load it via the sdk\r\n                if (sessionLoading !== undefined && sessionId !== undefined && !href.startsWith('blob:') && !href.startsWith('data:')) {\r\n                    // take first session to load a texture that is not session related\r\n                    return new Promise((resolve, reject) => {\r\n                        sessionLoading.downloadTexture(sessionId, href).then((result) => {\r\n                            resolve({\r\n                                data: result[0],\r\n                                headers: {\r\n                                    'content-type': result[1]\r\n                                }\r\n                            });\r\n                        }).catch(e => reject(e));\r\n                    }).catch(e => { throw this.convertError(e); });\r\n                }\r\n                else {\r\n                    // we can load blobs and data urls directly\r\n                    // or load it directly if we don't have a session\r\n                    return (0, axios_1.default)(href, Object.assign({ method: 'get' }, config))\r\n                        .catch(e => { throw this.convertError(e); });\r\n                }\r\n            }\r\n            else {\r\n                if (!sessionLoading) {\r\n                    // if there is no session to load from, we use the fallback option\r\n                    return (0, axios_1.default)(href, Object.assign({ method: 'get' }, config))\r\n                        .catch(e => { throw this.convertError(e); });\r\n                }\r\n                else {\r\n                    // all data links where we could somehow find a session to load it with\r\n                    return new Promise((resolve, reject) => {\r\n                        sessionLoading.getAsset(href)\r\n                            .then((result) => {\r\n                            resolve({\r\n                                data: result[0],\r\n                                headers: {\r\n                                    'content-type': result[1]\r\n                                }\r\n                            });\r\n                        })\r\n                            .catch(() => {\r\n                            // if this fails, we just load it directly\r\n                            const axiosPromise = (0, axios_1.default)(href, Object.assign({ method: 'get' }, config));\r\n                            axiosPromise.catch(e => reject(e));\r\n                            resolve(axiosPromise);\r\n                        });\r\n                    }).catch(e => { throw this.convertError(e); });\r\n                }\r\n            }\r\n        });\r\n    }\r\n    loadTexture(href) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.get(href, undefined, true);\r\n        });\r\n    }\r\n    removeDataLoading(sessionId) {\r\n        delete this._sessionLoading[sessionId];\r\n    }\r\n    // #endregion Public Methods (5)\r\n    // #region Private Methods (1)\r\n    getSessionId(href) {\r\n        // searching for \"/session/SESSION_ID/{'output' | 'export' | 'texture'}/ASSET_DATA\"\r\n        const parts = href.split('/');\r\n        const sessionPartIndex = parts.indexOf('session');\r\n        // There have to be at exactly 4 parts, including the session\r\n        if (sessionPartIndex !== -1 && parts.length === sessionPartIndex + 4) {\r\n            const sessionId = parts[sessionPartIndex + 1];\r\n            // no such session has been registered, should never happen\r\n            if (!this._sessionLoading[sessionId])\r\n                return;\r\n            return sessionId;\r\n        }\r\n        return;\r\n    }\r\n}\r\nexports.HttpClient = HttpClient;\r\n"},"sourceMaps":{"js":{"version":3,"file":"HttpClient.js","sourceRoot":"","sources":["../../src/http-client/HttpClient.ts"],"names":[],"mappings":"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","sourcesContent":["import axios, { AxiosRequestConfig } from 'axios'\r\nimport { ShapeDiverError as ShapeDiverBackendError, ShapeDiverResponseError, ShapeDiverRequestError } from '@shapediver/sdk.geometry-api-sdk-v2'\r\nimport { ShapeDiverGeometryBackendRequestError, ShapeDiverGeometryBackendResponseError } from '../logger/ShapeDiverBackendErrors';\r\nimport { HttpResponse } from './HttpResponse';\r\n\r\nexport class HttpClient {\r\n    // #region Properties (2)\r\n\r\n    private static _instance: HttpClient;\r\n\r\n    private _sessionLoading: {\r\n        [key: string]: {\r\n            getAsset: (url: string) => Promise<[ArrayBuffer, string, string]>,\r\n            downloadTexture: (sessionId: string, url: string) => Promise<[ArrayBuffer, string]>,\r\n        }\r\n    } = {};\r\n\r\n    // #endregion Properties (2)\r\n\r\n    // #region Constructors (1)\r\n\r\n    private constructor() { }\r\n\r\n    // #endregion Constructors (1)\r\n\r\n    // #region Public Static Accessors (1)\r\n\r\n    public static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n\r\n    // #endregion Public Static Accessors (1)\r\n\r\n    // #region Public Methods (5)\r\n\r\n    public addDataLoading(sessionId: string, callbacks: {\r\n        getAsset: (url: string) => Promise<[ArrayBuffer, string, string]>,\r\n        downloadTexture: (sessionId: string, url: string) => Promise<[ArrayBuffer, string]>,\r\n    }) {\r\n        this._sessionLoading[sessionId] = callbacks;\r\n    }\r\n\r\n    /**\r\n     * Maps the geometry backend error to the corresponding viewer errors:\r\n     * - ShapeDiverResponseError is mapped to ShapeDiverGeometryBackendResponseError\r\n     * - ShapeDiverRequestError is mapped to ShapeDiverGeometryBackendRequestError\r\n     * \r\n     * Other error types are thrown as is.\r\n     * \r\n     * @param e \r\n     */\r\n    public convertError(e: ShapeDiverBackendError | Error | unknown) {\r\n        if (e instanceof ShapeDiverResponseError) {\r\n            throw new ShapeDiverGeometryBackendResponseError(e.message, e.status, e.error, e.desc);\r\n        } else if (e instanceof ShapeDiverRequestError) {\r\n            throw new ShapeDiverGeometryBackendRequestError(e.message, e.desc)\r\n        } else {\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    public async get(href: string, config: AxiosRequestConfig = { responseType: 'arraybuffer' }, textureLoading: boolean = false): Promise<HttpResponse<any>> {\r\n        // try to get sessionId from href\r\n        let sessionId = this.getSessionId(href);\r\n\r\n        // if href does not have sessionId, use the first session, if available\r\n        if (!sessionId && Object.keys(this._sessionLoading).length > 0)\r\n            sessionId = Object.keys(this._sessionLoading)[0];\r\n\r\n        // get the session loading functions, if available\r\n        let sessionLoading: {\r\n            getAsset: (url: string) => Promise<[ArrayBuffer, string, string]>,\r\n            downloadTexture: (sessionId: string, url: string) => Promise<[ArrayBuffer, string]>,\r\n        } | undefined;\r\n        if (sessionId)\r\n            sessionLoading = this._sessionLoading[sessionId];\r\n\r\n        // separation texture vs everything else\r\n        if (textureLoading) {\r\n            // if we have a sessionId and the sessionLoading functions and the image is not a blob or data, we load it via the sdk\r\n            if (sessionLoading !== undefined && sessionId !== undefined && !href.startsWith('blob:') && !href.startsWith('data:')) {\r\n                // take first session to load a texture that is not session related\r\n                return new Promise<HttpResponse<any>>((resolve, reject) => {\r\n                    sessionLoading!.downloadTexture(sessionId!, href).then((result) => {\r\n                        resolve({\r\n                            data: result[0],\r\n                            headers: {\r\n                                'content-type': result[1]\r\n                            }\r\n                        })\r\n                    }).catch(e => reject(e))\r\n                }).catch(e => { throw this.convertError(e) });\r\n            } else {\r\n                // we can load blobs and data urls directly\r\n                // or load it directly if we don't have a session\r\n                return axios(href, Object.assign({ method: 'get' }, config))\r\n                    .catch(e => { throw this.convertError(e) });\r\n            }\r\n        } else {\r\n            if (!sessionLoading) {\r\n                // if there is no session to load from, we use the fallback option\r\n                return axios(href, Object.assign({ method: 'get' }, config))\r\n                    .catch(e => { throw this.convertError(e) });\r\n            } else {\r\n                // all data links where we could somehow find a session to load it with\r\n                return new Promise<HttpResponse<ArrayBuffer>>((resolve, reject) => {\r\n                    sessionLoading!.getAsset(href)\r\n                        .then((result) => {\r\n                            resolve({\r\n                                data: result[0],\r\n                                headers: {\r\n                                    'content-type': result[1]\r\n                                }\r\n                            })\r\n                        })\r\n                        .catch(() => {\r\n                            // if this fails, we just load it directly\r\n                            const axiosPromise = axios(href, Object.assign({ method: 'get' }, config));\r\n                            axiosPromise.catch(e => reject(e))\r\n                            resolve(axiosPromise);\r\n                        });\r\n                }).catch(e => { throw this.convertError(e) });\r\n            }\r\n        }\r\n    }\r\n\r\n    public async loadTexture(href: string): Promise<HttpResponse<ArrayBuffer>> {\r\n        return this.get(href, undefined, true);\r\n    }\r\n\r\n    public removeDataLoading(sessionId: string) {\r\n        delete this._sessionLoading[sessionId];\r\n    }\r\n\r\n    // #endregion Public Methods (5)\r\n\r\n    // #region Private Methods (1)\r\n\r\n    private getSessionId(href: string): string | undefined {\r\n        // searching for \"/session/SESSION_ID/{'output' | 'export' | 'texture'}/ASSET_DATA\"\r\n        const parts = href.split('/');\r\n        const sessionPartIndex = parts.indexOf('session');\r\n\r\n        // There have to be at exactly 4 parts, including the session\r\n        if (sessionPartIndex !== -1 && parts.length === sessionPartIndex + 4) {\r\n            const sessionId = parts[sessionPartIndex + 1];\r\n            // no such session has been registered, should never happen\r\n            if (!this._sessionLoading[sessionId]) return;\r\n            return sessionId;\r\n        }\r\n        return;\r\n    }\r\n\r\n    // #endregion Private Methods (1)\r\n}"]}},"error":null,"hash":"9425871633e150a8bc56e0b5c82a14be","cacheData":{"env":{}}}