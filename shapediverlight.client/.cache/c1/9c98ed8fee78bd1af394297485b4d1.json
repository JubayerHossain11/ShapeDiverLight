{"id":"node_modules/@shapediver/viewer.shared.types/dist/implementation/data/AnimationData.js","dependencies":[{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.types\\dist\\implementation\\data\\AnimationData.js.map","includedInParent":true,"mtime":1706527151032},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.types\\src\\implementation\\data\\AnimationData.ts","includedInParent":true,"mtime":1706527152552},{"name":"D:\\projects\\myProjects\\shapeApp\\package.json","includedInParent":true,"mtime":1706533774939},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.types\\package.json","includedInParent":true,"mtime":1706527150980},{"name":"@shapediver/viewer.shared.node-tree","loc":{"line":16,"column":42,"index":1487},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.types\\dist\\implementation\\data\\AnimationData.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.node-tree\\dist\\index.js"},{"name":"gl-matrix","loc":{"line":17,"column":28,"index":1556},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.types\\dist\\implementation\\data\\AnimationData.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\gl-matrix\\esm\\index.js"},{"name":"./GeometryData","loc":{"line":18,"column":31,"index":1602},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.types\\dist\\implementation\\data\\AnimationData.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.types\\dist\\implementation\\data\\GeometryData.js"}],"generated":{"js":"\"use strict\";\r\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _AnimationData_animate, _AnimationData_animationTime, _AnimationData_duration, _AnimationData_name, _AnimationData_repeat, _AnimationData_start, _AnimationData_started, _AnimationData_tracks, _AnimationData_reset, _AnimationData_nodeIds;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AnimationData = void 0;\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nconst GeometryData_1 = require(\"./GeometryData\");\r\nclass AnimationData extends viewer_shared_node_tree_1.AbstractTreeNodeData {\r\n    // #endregion Properties (8)\r\n    // #region Constructors (1)\r\n    /**\r\n     * Creates a custom data node.\r\n     *\r\n     * @param _data the data as key- value pairs\r\n     * @param id the id\r\n     */\r\n    constructor(name, tracks, start, duration, id, version) {\r\n        super(id, version);\r\n        // #region Properties (8)\r\n        _AnimationData_animate.set(this, false);\r\n        _AnimationData_animationTime.set(this, 0);\r\n        _AnimationData_duration.set(this, void 0);\r\n        _AnimationData_name.set(this, void 0);\r\n        _AnimationData_repeat.set(this, false);\r\n        _AnimationData_start.set(this, void 0);\r\n        _AnimationData_started.set(this, false);\r\n        _AnimationData_tracks.set(this, void 0);\r\n        _AnimationData_reset.set(this, true);\r\n        _AnimationData_nodeIds.set(this, []);\r\n        __classPrivateFieldSet(this, _AnimationData_name, name, \"f\");\r\n        __classPrivateFieldSet(this, _AnimationData_tracks, tracks, \"f\");\r\n        __classPrivateFieldSet(this, _AnimationData_start, start, \"f\");\r\n        __classPrivateFieldSet(this, _AnimationData_duration, duration, \"f\");\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Accessors (9)\r\n    get animate() {\r\n        return __classPrivateFieldGet(this, _AnimationData_animate, \"f\");\r\n    }\r\n    get animationTime() {\r\n        return __classPrivateFieldGet(this, _AnimationData_animationTime, \"f\");\r\n    }\r\n    set animationTime(value) {\r\n        __classPrivateFieldSet(this, _AnimationData_animationTime, value, \"f\");\r\n    }\r\n    get duration() {\r\n        return __classPrivateFieldGet(this, _AnimationData_duration, \"f\");\r\n    }\r\n    get name() {\r\n        return __classPrivateFieldGet(this, _AnimationData_name, \"f\");\r\n    }\r\n    get repeat() {\r\n        return __classPrivateFieldGet(this, _AnimationData_repeat, \"f\");\r\n    }\r\n    set repeat(value) {\r\n        __classPrivateFieldSet(this, _AnimationData_repeat, value, \"f\");\r\n    }\r\n    get reset() {\r\n        return __classPrivateFieldGet(this, _AnimationData_reset, \"f\");\r\n    }\r\n    set reset(value) {\r\n        __classPrivateFieldSet(this, _AnimationData_reset, value, \"f\");\r\n    }\r\n    get start() {\r\n        return __classPrivateFieldGet(this, _AnimationData_start, \"f\");\r\n    }\r\n    get tracks() {\r\n        return __classPrivateFieldGet(this, _AnimationData_tracks, \"f\");\r\n    }\r\n    set tracks(value) {\r\n        __classPrivateFieldSet(this, _AnimationData_tracks, value, \"f\");\r\n    }\r\n    // #endregion Public Accessors (9)\r\n    // #region Public Methods (5)\r\n    /**\r\n     * Clones the scene graph data.\r\n     */\r\n    clone() {\r\n        return new AnimationData(this.name, __classPrivateFieldGet(this, _AnimationData_tracks, \"f\"), this.start, this.duration, this.id, this.version);\r\n    }\r\n    continueAnimation() {\r\n        if (__classPrivateFieldGet(this, _AnimationData_started, \"f\"))\r\n            __classPrivateFieldSet(this, _AnimationData_animate, true, \"f\");\r\n    }\r\n    pauseAnimation() {\r\n        if (__classPrivateFieldGet(this, _AnimationData_started, \"f\"))\r\n            __classPrivateFieldSet(this, _AnimationData_animate, false, \"f\");\r\n    }\r\n    startAnimation() {\r\n        __classPrivateFieldSet(this, _AnimationData_animationTime, 0, \"f\");\r\n        __classPrivateFieldSet(this, _AnimationData_animate, true, \"f\");\r\n        __classPrivateFieldSet(this, _AnimationData_started, true, \"f\");\r\n        __classPrivateFieldSet(this, _AnimationData_nodeIds, [], \"f\");\r\n        for (let i = 0; i < __classPrivateFieldGet(this, _AnimationData_tracks, \"f\").length; i++) {\r\n            const track = __classPrivateFieldGet(this, _AnimationData_tracks, \"f\")[i];\r\n            if (__classPrivateFieldGet(this, _AnimationData_nodeIds, \"f\").includes(track.node.id))\r\n                continue;\r\n            __classPrivateFieldGet(this, _AnimationData_nodeIds, \"f\").push(track.node.id);\r\n            const idleTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix');\r\n            if (idleTransformation) {\r\n                track.previousMatrix = {\r\n                    id: idleTransformation.id,\r\n                    matrix: gl_matrix_1.mat4.clone(idleTransformation.matrix)\r\n                };\r\n                idleTransformation.matrix = gl_matrix_1.mat4.create();\r\n                continue;\r\n            }\r\n            switch (track.path) {\r\n                case 'scale':\r\n                    const idleTransformationScale = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');\r\n                    if (idleTransformationScale) {\r\n                        track.previousMatrix = {\r\n                            id: idleTransformationScale.id,\r\n                            matrix: gl_matrix_1.mat4.clone(idleTransformationScale.matrix)\r\n                        };\r\n                        continue;\r\n                    }\r\n                    break;\r\n                case 'rotation':\r\n                    const idleTransformationRotation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');\r\n                    if (idleTransformationRotation) {\r\n                        track.previousMatrix = {\r\n                            id: idleTransformationRotation.id,\r\n                            matrix: gl_matrix_1.mat4.clone(idleTransformationRotation.matrix)\r\n                        };\r\n                        continue;\r\n                    }\r\n                    break;\r\n                case 'translation':\r\n                    const idleTransformationTranslation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');\r\n                    if (idleTransformationTranslation) {\r\n                        track.previousMatrix = {\r\n                            id: idleTransformationTranslation.id,\r\n                            matrix: gl_matrix_1.mat4.clone(idleTransformationTranslation.matrix)\r\n                        };\r\n                        continue;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    stopAnimation() {\r\n        if (this.reset) {\r\n            for (let i = 0; i < __classPrivateFieldGet(this, _AnimationData_tracks, \"f\").length; i++) {\r\n                const track = __classPrivateFieldGet(this, _AnimationData_tracks, \"f\")[i];\r\n                const id = this.id + '_' + i;\r\n                const prevAnimation = track.node.transformations.filter(t => t.id === id);\r\n                track.node.transformations = track.node.transformations.filter((el) => {\r\n                    return !prevAnimation.includes(el);\r\n                });\r\n                if (track.previousMatrix) {\r\n                    if (track.previousMatrix.id === 'gltf_matrix') {\r\n                        const transformation = track.node.transformations.find(t => t.id === 'gltf_matrix');\r\n                        transformation.matrix = track.previousMatrix.matrix;\r\n                        const translationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');\r\n                        translationTransformation.matrix = gl_matrix_1.mat4.create();\r\n                        const rotationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');\r\n                        rotationTransformation.matrix = gl_matrix_1.mat4.create();\r\n                        const scaleTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');\r\n                        scaleTransformation.matrix = gl_matrix_1.mat4.create();\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        switch (track.path) {\r\n                            case 'scale':\r\n                                const idleTransformationScale = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');\r\n                                idleTransformationScale.matrix = track.previousMatrix.matrix;\r\n                                continue;\r\n                            case 'rotation':\r\n                                const idleTransformationRotation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');\r\n                                idleTransformationRotation.matrix = track.previousMatrix.matrix;\r\n                                continue;\r\n                            case 'translation':\r\n                                const idleTransformationTranslation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');\r\n                                idleTransformationTranslation.matrix = track.previousMatrix.matrix;\r\n                                continue;\r\n                        }\r\n                    }\r\n                }\r\n                else if (!__classPrivateFieldGet(this, _AnimationData_nodeIds, \"f\").includes(track.node.id)) {\r\n                    const idleTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix');\r\n                    if (idleTransformation) {\r\n                        idleTransformation.matrix = gl_matrix_1.mat4.create();\r\n                    }\r\n                    else {\r\n                        const idleTransformationScale = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');\r\n                        if (idleTransformationScale)\r\n                            idleTransformationScale.matrix = gl_matrix_1.mat4.create();\r\n                        const idleTransformationRotation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');\r\n                        if (idleTransformationRotation)\r\n                            idleTransformationRotation.matrix = gl_matrix_1.mat4.create();\r\n                        const idleTransformationTranslation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');\r\n                        if (idleTransformationTranslation)\r\n                            idleTransformationTranslation.matrix = gl_matrix_1.mat4.create();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (let i = 0; i < __classPrivateFieldGet(this, _AnimationData_tracks, \"f\").length; i++) {\r\n                const track = __classPrivateFieldGet(this, _AnimationData_tracks, \"f\")[i];\r\n                const id = this.id + '_' + i;\r\n                const prevAnimation = track.node.transformations.filter(t => t.id === id);\r\n                track.node.transformations = track.node.transformations.filter((el) => {\r\n                    return !prevAnimation.includes(el);\r\n                });\r\n                const j = track.times.length - 1;\r\n                let translationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');\r\n                if (!translationTransformation) {\r\n                    translationTransformation = {\r\n                        id: 'gltf_matrix_translation',\r\n                        matrix: gl_matrix_1.mat4.create()\r\n                    };\r\n                    track.node.transformations.push(translationTransformation);\r\n                }\r\n                let rotationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');\r\n                if (!rotationTransformation) {\r\n                    rotationTransformation = {\r\n                        id: 'gltf_matrix_rotation',\r\n                        matrix: gl_matrix_1.mat4.create()\r\n                    };\r\n                    track.node.transformations.push(rotationTransformation);\r\n                }\r\n                let scaleTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');\r\n                if (!scaleTransformation) {\r\n                    scaleTransformation = {\r\n                        id: 'gltf_matrix_scale',\r\n                        matrix: gl_matrix_1.mat4.create()\r\n                    };\r\n                    track.node.transformations.push(scaleTransformation);\r\n                }\r\n                if (track.path === 'rotation') {\r\n                    let pivotMatrix, pivotMatrixInverse;\r\n                    if (track.pivot) {\r\n                        pivotMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(track.pivot[0], track.pivot[1], track.pivot[2]));\r\n                        pivotMatrixInverse = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(-track.pivot[0], -track.pivot[1], -track.pivot[2]));\r\n                    }\r\n                    let quaternion = gl_matrix_1.quat.fromValues(track.values[j * 4 + 0], track.values[j * 4 + 1], track.values[j * 4 + 2], track.values[j * 4 + 3]);\r\n                    const rotationMatrix = gl_matrix_1.mat4.fromQuat(gl_matrix_1.mat4.create(), quaternion);\r\n                    if (pivotMatrix && pivotMatrixInverse) {\r\n                        rotationTransformation.matrix = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), pivotMatrix, rotationMatrix), pivotMatrixInverse);\r\n                    }\r\n                    else {\r\n                        rotationTransformation.matrix = rotationMatrix;\r\n                    }\r\n                }\r\n                else if (track.path === 'translation') {\r\n                    let vector = gl_matrix_1.vec3.fromValues(track.values[j * 3 + 0], track.values[j * 3 + 1], track.values[j * 3 + 2]);\r\n                    translationTransformation.matrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), vector);\r\n                }\r\n                else if (track.path === 'scale') {\r\n                    let vector = gl_matrix_1.vec3.fromValues(track.values[j * 3 + 0], track.values[j * 3 + 1], track.values[j * 3 + 2]);\r\n                    scaleTransformation.matrix = gl_matrix_1.mat4.fromScaling(gl_matrix_1.mat4.create(), vector);\r\n                }\r\n                else if (track.path === 'weights') {\r\n                    let weights = [];\r\n                    const weightCount = track.values.length / track.times.length;\r\n                    for (let l = 0; l < weightCount; l++)\r\n                        weights.push(track.values[j * weightCount + l]);\r\n                    const applyWeights = (node) => {\r\n                        for (let l = 0; l < node.data.length; l++)\r\n                            if (node.data[l] instanceof GeometryData_1.GeometryData && node.data[l].morphWeights.length === weightCount)\r\n                                node.data[l].morphWeights = weights;\r\n                        for (let l = 0; l < node.children.length; l++)\r\n                            applyWeights(node.children[l]);\r\n                    };\r\n                    applyWeights(track.node);\r\n                }\r\n            }\r\n        }\r\n        __classPrivateFieldSet(this, _AnimationData_animationTime, -1, \"f\");\r\n        __classPrivateFieldSet(this, _AnimationData_started, false, \"f\");\r\n        __classPrivateFieldSet(this, _AnimationData_animate, false, \"f\");\r\n    }\r\n}\r\nexports.AnimationData = AnimationData;\r\n_AnimationData_animate = new WeakMap(), _AnimationData_animationTime = new WeakMap(), _AnimationData_duration = new WeakMap(), _AnimationData_name = new WeakMap(), _AnimationData_repeat = new WeakMap(), _AnimationData_start = new WeakMap(), _AnimationData_started = new WeakMap(), _AnimationData_tracks = new WeakMap(), _AnimationData_reset = new WeakMap(), _AnimationData_nodeIds = new WeakMap();\r\n"},"sourceMaps":{"js":{"version":3,"file":"AnimationData.js","sourceRoot":"","sources":["../../../src/implementation/data/AnimationData.ts"],"names":[],"mappings":"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","sourcesContent":["import { AbstractTreeNodeData, ITransformation, ITreeNode, ITreeNodeData } from '@shapediver/viewer.shared.node-tree'\r\nimport { mat4, quat, vec3, vec4 } from 'gl-matrix';\r\nimport { IAnimationData, IAnimationTrack } from '../../interfaces/data/IAnimationData';\r\nimport { GeometryData } from './GeometryData';\r\n\r\n\r\nexport class AnimationData extends AbstractTreeNodeData implements IAnimationData {\r\n    // #region Properties (8)\r\n\r\n    #animate: boolean = false;\r\n    #animationTime: number = 0;\r\n    #duration: number;\r\n    #name: string;\r\n    #repeat: boolean = false;\r\n    #start: number;\r\n    #started: boolean = false;\r\n    #tracks: IAnimationTrack[];\r\n    #reset: boolean = true;\r\n    #nodeIds: string[] = [];\r\n\r\n    // #endregion Properties (8)\r\n\r\n    // #region Constructors (1)\r\n\r\n    /**\r\n     * Creates a custom data node.\r\n     * \r\n     * @param _data the data as key- value pairs \r\n     * @param id the id\r\n     */\r\n    constructor(\r\n        name: string,\r\n        tracks: IAnimationTrack[],\r\n        start: number,\r\n        duration: number,\r\n        id?: string,\r\n        version?: string\r\n    ) {\r\n        super(id, version);\r\n        this.#name = name;\r\n        this.#tracks = tracks;\r\n        this.#start = start;\r\n        this.#duration = duration;\r\n    }\r\n\r\n    // #endregion Constructors (1)\r\n\r\n    // #region Public Accessors (9)\r\n\r\n    public get animate(): boolean {\r\n        return this.#animate;\r\n    }\r\n\r\n    public get animationTime(): number {\r\n        return this.#animationTime;\r\n    }\r\n\r\n    public set animationTime(value: number) {\r\n        this.#animationTime = value;\r\n    }\r\n\r\n    public get duration(): number {\r\n        return this.#duration;\r\n    }\r\n\r\n    public get name(): string {\r\n        return this.#name;\r\n    }\r\n\r\n    public get repeat(): boolean {\r\n        return this.#repeat;\r\n    }\r\n\r\n    public set repeat(value: boolean) {\r\n        this.#repeat = value;\r\n    }\r\n\r\n    public get reset(): boolean {\r\n        return this.#reset;\r\n    }\r\n\r\n    public set reset(value: boolean) {\r\n        this.#reset = value;\r\n    }\r\n\r\n    public get start(): number {\r\n        return this.#start;\r\n    }\r\n\r\n    public get tracks(): IAnimationTrack[] {\r\n        return this.#tracks;\r\n    }\r\n\r\n    public set tracks(value: IAnimationTrack[]) {\r\n        this.#tracks = value;\r\n    }\r\n\r\n    // #endregion Public Accessors (9)\r\n\r\n    // #region Public Methods (5)\r\n\r\n    /**\r\n     * Clones the scene graph data.\r\n     */\r\n    public clone(): IAnimationData {\r\n        return new AnimationData(this.name, this.#tracks, this.start, this.duration, this.id, this.version);\r\n    }\r\n\r\n    public continueAnimation() {\r\n        if (this.#started) this.#animate = true;\r\n    }\r\n\r\n    public pauseAnimation() {\r\n        if (this.#started) this.#animate = false;\r\n    }\r\n\r\n    public startAnimation() {\r\n        this.#animationTime = 0;\r\n        this.#animate = true;\r\n        this.#started = true;\r\n        this.#nodeIds = [];\r\n\r\n        for (let i = 0; i < this.#tracks.length; i++) {\r\n            const track = this.#tracks[i];\r\n            if(this.#nodeIds.includes(track.node.id)) continue;\r\n            this.#nodeIds.push(track.node.id)\r\n            const idleTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix');\r\n            if (idleTransformation) {\r\n                track.previousMatrix = {\r\n                    id: idleTransformation.id,\r\n                    matrix: mat4.clone(idleTransformation.matrix)\r\n                }\r\n                idleTransformation.matrix = mat4.create();\r\n                continue;\r\n            }\r\n\r\n            switch (track.path) {\r\n                case 'scale':\r\n                    const idleTransformationScale = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');\r\n                    if (idleTransformationScale) {\r\n                        track.previousMatrix = {\r\n                            id: idleTransformationScale.id,\r\n                            matrix: mat4.clone(idleTransformationScale.matrix)\r\n                        }\r\n                        continue;\r\n                    }\r\n\r\n                    break;\r\n\r\n                case 'rotation':\r\n                    const idleTransformationRotation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');\r\n                    if (idleTransformationRotation) {\r\n                        track.previousMatrix = {\r\n                            id: idleTransformationRotation.id,\r\n                            matrix: mat4.clone(idleTransformationRotation.matrix)\r\n                        }\r\n                        continue;\r\n                    }\r\n\r\n                    break;\r\n\r\n                case 'translation':\r\n                    const idleTransformationTranslation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');\r\n                    if (idleTransformationTranslation) {\r\n                        track.previousMatrix = {\r\n                            id: idleTransformationTranslation.id,\r\n                            matrix: mat4.clone(idleTransformationTranslation.matrix)\r\n                        }\r\n                        continue;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public stopAnimation() {\r\n        if (this.reset) {\r\n            for (let i = 0; i < this.#tracks.length; i++) {\r\n                const track = this.#tracks[i];\r\n                const id = this.id + '_' + i;\r\n                const prevAnimation = track.node.transformations.filter(t => t.id === id);\r\n                track.node.transformations = track.node.transformations.filter((el) => {\r\n                    return !prevAnimation.includes(el);\r\n                });\r\n\r\n                if (track.previousMatrix) {\r\n                    if (track.previousMatrix.id === 'gltf_matrix') {\r\n                        const transformation = track.node.transformations.find(t => t.id === 'gltf_matrix')!;\r\n                        transformation.matrix = track.previousMatrix.matrix;\r\n                        const translationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation')!;\r\n                        translationTransformation.matrix = mat4.create();\r\n                        const rotationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation')!;\r\n                        rotationTransformation.matrix = mat4.create();\r\n                        const scaleTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_scale')!;\r\n                        scaleTransformation.matrix = mat4.create();\r\n                        continue;\r\n                    } else {\r\n                        switch (track.path) {\r\n                            case 'scale':\r\n                                const idleTransformationScale = track.node.transformations.find(t => t.id === 'gltf_matrix_scale')!;\r\n                                idleTransformationScale.matrix = track.previousMatrix.matrix;\r\n                                continue;\r\n                            case 'rotation':\r\n                                const idleTransformationRotation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation')!;\r\n                                idleTransformationRotation.matrix = track.previousMatrix.matrix;\r\n                                continue;\r\n                            case 'translation':\r\n                                const idleTransformationTranslation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation')!;\r\n                                idleTransformationTranslation.matrix = track.previousMatrix.matrix;\r\n                                continue;\r\n                        }\r\n                    }\r\n                } else if(!this.#nodeIds.includes(track.node.id)) {\r\n                    const idleTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix');\r\n                    if (idleTransformation) {\r\n                        idleTransformation.matrix = mat4.create();\r\n                    } else {\r\n                        const idleTransformationScale = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');\r\n                        if (idleTransformationScale) idleTransformationScale.matrix = mat4.create();\r\n\r\n                        const idleTransformationRotation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');\r\n                        if (idleTransformationRotation) idleTransformationRotation.matrix = mat4.create();\r\n\r\n                        const idleTransformationTranslation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');\r\n                        if (idleTransformationTranslation) idleTransformationTranslation.matrix = mat4.create();\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = 0; i < this.#tracks.length; i++) {\r\n                const track = this.#tracks[i];\r\n                const id = this.id + '_' + i;\r\n\r\n                const prevAnimation = track.node.transformations.filter(t => t.id === id);\r\n                track.node.transformations = track.node.transformations.filter((el) => {\r\n                    return !prevAnimation.includes(el);\r\n                });\r\n\r\n                const j = track.times.length - 1;\r\n\r\n                let translationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');\r\n                if(!translationTransformation) {\r\n                    translationTransformation = {\r\n                        id: 'gltf_matrix_translation',\r\n                        matrix: mat4.create()\r\n                    }\r\n                    track.node.transformations.push(translationTransformation)\r\n                }\r\n                \r\n                let rotationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');\r\n                if(!rotationTransformation) {\r\n                    rotationTransformation = {\r\n                        id: 'gltf_matrix_rotation',\r\n                        matrix: mat4.create()\r\n                    }\r\n                    track.node.transformations.push(rotationTransformation)\r\n                }\r\n\r\n                let scaleTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');\r\n                if(!scaleTransformation) {\r\n                    scaleTransformation = {\r\n                        id: 'gltf_matrix_scale',\r\n                        matrix: mat4.create()\r\n                    }\r\n                    track.node.transformations.push(scaleTransformation)\r\n                }\r\n\r\n                if (track.path === 'rotation') {\r\n                    let pivotMatrix: mat4 | undefined, pivotMatrixInverse: mat4 | undefined;\r\n                    if(track.pivot) {\r\n                        pivotMatrix = mat4.fromTranslation(mat4.create(), vec3.fromValues(track.pivot[0], track.pivot[1], track.pivot[2]));\r\n                        pivotMatrixInverse = mat4.fromTranslation(mat4.create(), vec3.fromValues(-track.pivot[0], -track.pivot[1], -track.pivot[2]));\r\n                    }\r\n\r\n                    let quaternion: quat = quat.fromValues(track.values[j * 4 + 0], track.values[j * 4 + 1], track.values[j * 4 + 2], track.values[j * 4 + 3]);\r\n                    const rotationMatrix = mat4.fromQuat(mat4.create(), quaternion);\r\n                    if(pivotMatrix && pivotMatrixInverse) {\r\n                        rotationTransformation.matrix = mat4.multiply(mat4.create(), mat4.multiply(mat4.create(), pivotMatrix, rotationMatrix), pivotMatrixInverse);\r\n                    } else {\r\n                        rotationTransformation.matrix = rotationMatrix;\r\n                    }\r\n                } else if (track.path === 'translation') {\r\n                    let vector: vec3 = vec3.fromValues(track.values[j * 3 + 0], track.values[j * 3 + 1], track.values[j * 3 + 2]);\r\n                    translationTransformation.matrix = mat4.fromTranslation(mat4.create(), vector);\r\n                } else if (track.path === 'scale') {\r\n                    let vector: vec3 = vec3.fromValues(track.values[j * 3 + 0], track.values[j * 3 + 1], track.values[j * 3 + 2]);\r\n                    scaleTransformation.matrix = mat4.fromScaling(mat4.create(), vector);\r\n                } else if (track.path === 'weights') {\r\n                    let weights: number[] = [];\r\n                    const weightCount = track.values.length / track.times.length;\r\n\r\n                    for(let l = 0; l < weightCount; l++)\r\n                        weights.push(track.values[j * weightCount + l])\r\n                    \r\n                    const applyWeights = (node: ITreeNode) => {\r\n                        for(let l = 0; l < node.data.length; l++)\r\n                            if(node.data[l] instanceof GeometryData && (<GeometryData>node.data[l]).morphWeights.length === weightCount)\r\n                                (<GeometryData>node.data[l]).morphWeights = weights;\r\n\r\n                        for (let l = 0; l < node.children.length; l++)\r\n                            applyWeights(node.children[l])\r\n                    }\r\n                    applyWeights(track.node);\r\n                }\r\n            }\r\n        }\r\n        this.#animationTime = -1;\r\n        this.#started = false;\r\n        this.#animate = false;\r\n    }\r\n\r\n    // #endregion Public Methods (5)\r\n}\r\n"]}},"error":null,"hash":"27aece8c10c5d6fe6b9d3ba7d58a8f0c","cacheData":{"env":{}}}