{"id":"node_modules/@shapediver/viewer.shared.services/dist/converter/Converter.js","dependencies":[{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\dist\\converter\\Converter.js.map","includedInParent":true,"mtime":1706542086023},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\src\\converter\\Converter.ts","includedInParent":true,"mtime":1706542086697},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\package.json","includedInParent":true,"mtime":1706542184022},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\package.json","includedInParent":true,"mtime":1706542085933},{"name":"gl-matrix","loc":{"line":13,"column":28,"index":826},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\dist\\converter\\Converter.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\gl-matrix\\esm\\index.js"},{"name":"@ctrl/tinycolor","loc":{"line":14,"column":28,"index":869},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\dist\\converter\\Converter.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@ctrl\\tinycolor\\dist\\module\\public_api.js"},{"name":"../http-client/HttpClient","loc":{"line":15,"column":29,"index":919},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\dist\\converter\\Converter.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\dist\\http-client\\HttpClient.js"}],"generated":{"js":"\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Converter = void 0;\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nconst tinycolor_1 = require(\"@ctrl/tinycolor\");\r\nconst HttpClient_1 = require(\"../http-client/HttpClient\");\r\nclass Converter {\r\n    constructor() {\r\n        // #region Properties (2)\r\n        this._httpClient = HttpClient_1.HttpClient.instance;\r\n        // #endregion Private Methods (1)\r\n    }\r\n    // #endregion Properties (2)\r\n    // #region Public Static Accessors (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Accessors (1)\r\n    // #region Public Methods (8)\r\n    processSVG(blob) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let data = yield new Promise((resolve, reject) => {\r\n                const reader = new FileReader();\r\n                reader.onloadend = () => resolve(reader.result);\r\n                reader.onerror = reject;\r\n                reader.readAsDataURL(blob);\r\n            });\r\n            data = data.replace('data:image/svg+xml;base64,', '');\r\n            data = atob(data);\r\n            let svgC = document.createElement('DIV');\r\n            svgC.id = 'svgc';\r\n            svgC.innerHTML = data;\r\n            // now we can access the svg element as a DOM object\r\n            let svgE = svgC.getElementsByTagName('svg');\r\n            let childImageURIs = [];\r\n            let styleURIs = [];\r\n            // collect image urls\r\n            for (let i = 0; i < svgE.length; ++i) {\r\n                for (let j = 0; j < 2; ++j) {\r\n                    let childImages = svgE[i].getElementsByTagName(['image', 'img'][j]);\r\n                    for (let k = 0; k < childImages.length; ++k) {\r\n                        if (childImages[k].href.baseVal.substring(0, 5) != 'data:') {\r\n                            childImageURIs.push(childImages[k].href.baseVal);\r\n                        }\r\n                    }\r\n                }\r\n                // collect potential font definitions\r\n                // we assume styles are imported using the following syntax:\r\n                // @import url(CSS_URL);\r\n                let styleElements = svgE[i].getElementsByTagName('style');\r\n                for (let j = 0; j < styleElements.length; ++j) {\r\n                    let regex = /@import\\x20url\\(\\s*(.*?)\\s*\\);/g;\r\n                    let m;\r\n                    while ((m = regex.exec(styleElements[j].innerHTML)) !== null) {\r\n                        styleURIs.push(m[1]);\r\n                    }\r\n                    // make unique\r\n                    styleURIs = styleURIs.filter(function (value, index, self) {\r\n                        return self.indexOf(value) === index;\r\n                    });\r\n                }\r\n            }\r\n            // creating a promise for each image which needs to be converted to a data URI\r\n            let replacementPromises = [];\r\n            let createImagePromise = (uri) => __awaiter(this, void 0, void 0, function* () {\r\n                if (uri.length > 0) {\r\n                    const response = yield this._httpClient.loadTexture(uri);\r\n                    let uInt8Array = new Uint8Array(response.data), i = uInt8Array.length;\r\n                    let biStr = []; //new Array(i);\r\n                    while (i--)\r\n                        biStr[i] = String.fromCharCode(uInt8Array[i]);\r\n                    let base64Data = window.btoa(biStr.join(''));\r\n                    let imgDataUrl = 'data:' + response.headers['content-type'] + ';base64,' + base64Data;\r\n                    // replace url in SVG string\r\n                    // CAUTION theoretically this could cause unwanted replacements\r\n                    data = data.replace(uri, imgDataUrl);\r\n                }\r\n            });\r\n            for (let i = 0; i < childImageURIs.length; ++i)\r\n                replacementPromises.push(createImagePromise(childImageURIs[i]));\r\n            // now we create promises for the google fonts to be imported\r\n            let createStylePromise = (styleUrl) => __awaiter(this, void 0, void 0, function* () {\r\n                const response = yield this._httpClient.get(styleUrl, { responseType: 'text' });\r\n                let cssString = response.data;\r\n                // we assume that fonts are imported using the following syntax:\r\n                // url(FONT_URI);\r\n                let fontURLs = [];\r\n                let regex = /url\\(\\s*(.*?)\\s*\\)/g;\r\n                let m;\r\n                while ((m = regex.exec(cssString)) !== null) {\r\n                    fontURLs.push(m[1]);\r\n                }\r\n                let fontPromises = [];\r\n                let createFontPromise = (fUrl) => __awaiter(this, void 0, void 0, function* () {\r\n                    const response = yield this._httpClient.get(fUrl, { responseType: 'arraybuffer' });\r\n                    let uInt8Array = new Uint8Array(response.data), i = uInt8Array.length;\r\n                    let biStr = []; //new Array(i);\r\n                    while (i--)\r\n                        biStr[i] = String.fromCharCode(uInt8Array[i]);\r\n                    let base64Data = window.btoa(biStr.join(''));\r\n                    let fontDataUrl = 'data:' + response.headers['content-type'] + ';base64,' + base64Data;\r\n                    if (fUrl.length > 0)\r\n                        cssString = cssString.replace(fUrl, fontDataUrl);\r\n                });\r\n                for (let j = 0; j < fontURLs.length; ++j)\r\n                    fontPromises.push(createFontPromise(fontURLs[j]));\r\n                yield Promise.all(fontPromises);\r\n                data = data.replace('@import url(' + styleUrl + ');', cssString);\r\n            });\r\n            for (let i = 0; i < styleURIs.length; ++i)\r\n                replacementPromises.push(createStylePromise(styleURIs[i]));\r\n            yield Promise.all(replacementPromises);\r\n            let du = 'data:image/svg+xml,' + encodeURIComponent(data);\r\n            let img = new Image(); // same as document.createElement('img')\r\n            img.crossOrigin = 'Anonymous';\r\n            const promise = new Promise((resolve, reject) => {\r\n                img.onload = () => resolve();\r\n                img.onerror = reject;\r\n            });\r\n            img.src = du;\r\n            yield promise;\r\n            return img;\r\n        });\r\n    }\r\n    responseToImage(response) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const arrayBufferView = new Uint8Array(response.data);\r\n            const blob = new Blob([arrayBufferView], { type: response.headers['content-type'] });\r\n            if (response.headers['content-type'] === 'image/svg+xml') {\r\n                const img = yield this.processSVG(blob);\r\n                return img;\r\n            }\r\n            else {\r\n                const img = new Image();\r\n                const promise = new Promise((resolve, reject) => {\r\n                    img.onload = () => resolve();\r\n                    img.onerror = reject;\r\n                });\r\n                img.crossOrigin = \"anonymous\";\r\n                img.src = URL.createObjectURL(blob);\r\n                yield promise;\r\n                URL.revokeObjectURL(img.src);\r\n                return img;\r\n            }\r\n        });\r\n    }\r\n    toAlpha(color) {\r\n        const c = this.toHexColor(color);\r\n        if (c.length <= 8)\r\n            return 1;\r\n        return parseInt(c.slice(c.length - 2, c.length), 16) / 255;\r\n    }\r\n    toColorArray(color) {\r\n        if (typeof color !== 'string' || !color.startsWith(\"#\"))\r\n            color = this.toHexColor(color);\r\n        const tColor = new tinycolor_1.TinyColor(color);\r\n        const rgb = tColor.toRgb();\r\n        return [rgb.r / 255.0, rgb.g / 255.0, rgb.b / 255.0];\r\n    }\r\n    /**\r\n     * @param color\r\n     * @param defColor\r\n     */\r\n    toHex8Color(color, defColorString = '#000') {\r\n        const c = this.toHexColor(color, defColorString);\r\n        const tColor = new tinycolor_1.TinyColor(c);\r\n        const cH8 = tColor.toHex8String();\r\n        return cH8.replace('#', '0x');\r\n    }\r\n    /**\r\n     * This color converter is mostly left 'as-is' from viewer v2.\r\n     * I didn't want to break something that works.\r\n     *\r\n     * @param color\r\n     * @param defColor\r\n     */\r\n    toHexColor(color, defColorString = '#000') {\r\n        if (!color || color === 'default')\r\n            return defColorString;\r\n        if (color.constructor === Float32Array)\r\n            color = Array.from(color);\r\n        const tColor = new tinycolor_1.TinyColor(color);\r\n        if (color instanceof tinycolor_1.TinyColor)\r\n            return this.tinyColorToString(tColor);\r\n        // check if we got a number\r\n        if (typeof color === 'number') {\r\n            let cs = color.toString(16);\r\n            let cl = cs.length;\r\n            if (cl < 3)\r\n                cs = cs.padStart(3, '0');\r\n            else if (cl < 6)\r\n                cs = cs.padStart(6, '0');\r\n            else if (cl < 8)\r\n                cs = cs.padEnd(8, '0');\r\n            let tc = new tinycolor_1.TinyColor(cs);\r\n            return tc.isValid ? this.tinyColorToString(tc) : defColorString;\r\n        }\r\n        // check if the input is a THREE.Color\r\n        if (color.isColor && typeof color.getHexString == 'function') {\r\n            let tc = new tinycolor_1.TinyColor(color.getHexString());\r\n            return tc.isValid ? this.tinyColorToString(tc) : defColorString;\r\n        }\r\n        // check for array of numbers\r\n        if (Array.isArray(color) && (color.length == 3 || color.length == 4)) {\r\n            let isRGBArray = true;\r\n            for (let i = 0; i < 3; ++i) {\r\n                color[i] = parseFloat(color[i]);\r\n                if (isNaN(color[i])) {\r\n                    isRGBArray = false;\r\n                }\r\n            }\r\n            if (!isRGBArray)\r\n                return defColorString;\r\n            let tc = new tinycolor_1.TinyColor({\r\n                r: Math.max(0, Math.min(color[0], 255)),\r\n                g: Math.max(0, Math.min(color[1], 255)),\r\n                b: Math.max(0, Math.min(color[2], 255))\r\n            });\r\n            if (color.length == 4) {\r\n                let a = parseFloat(color[3]);\r\n                if (!isNaN(a)) {\r\n                    tc.setAlpha(Math.max(0, Math.min(a, 255)) / 255);\r\n                }\r\n            }\r\n            return tc.isValid ? this.tinyColorToString(tc) : defColorString;\r\n        }\r\n        // if we got something other than a string, check if\r\n        // tinycolor can work with it\r\n        if (typeof color !== 'string') {\r\n            let tc = new tinycolor_1.TinyColor(color);\r\n            return tc.isValid ? this.tinyColorToString(tc) : defColorString;\r\n        }\r\n        // tinycolor doesn't like 0x\r\n        let tmpColor = color.replace('0x', '#');\r\n        // if we got no alpha value, add full opacity\r\n        if (tmpColor.match(/^#[a-f0-9]{6}$/i) !== null) {\r\n            let tc = new tinycolor_1.TinyColor(tmpColor + 'ff');\r\n            return tc.isValid ? this.tinyColorToString(tc) : defColorString;\r\n        }\r\n        // standard case\r\n        if (tmpColor.match(/^#[a-f0-9]{8}$/i) !== null) {\r\n            let tc = new tinycolor_1.TinyColor(tmpColor);\r\n            return tc.isValid ? this.tinyColorToString(tc) : defColorString;\r\n        }\r\n        // correct number which have the alpha value defined as a single hex digit\r\n        if (tmpColor.match(/^#[a-f0-9]{7}$/i) !== null) {\r\n            let tc = new tinycolor_1.TinyColor(tmpColor.slice(0, 7) + '0' + tmpColor.slice(-1));\r\n            return tc.isValid ? this.tinyColorToString(tc) : defColorString;\r\n        }\r\n        // check if tinycolor understands the string\r\n        let tc = new tinycolor_1.TinyColor(tmpColor);\r\n        return tc.isValid ? this.tinyColorToString(tc) : defColorString;\r\n    }\r\n    toThreeJsColorInput(color) {\r\n        const c = this.toHexColor(color);\r\n        return c.slice(0, c.length - 2);\r\n    }\r\n    toVec3(point) {\r\n        if (Array.isArray(point) && point.length >= 3 && typeof point[0] === 'number' && typeof point[1] === 'number' && typeof point[2] === 'number')\r\n            return gl_matrix_1.vec3.fromValues(point[0], point[1], point[2]);\r\n        if (((point.x || point.x === 0) && typeof point.x === 'number') && ((point.y || point.y === 0) && typeof point.y === 'number') && ((point.z || point.z === 0) && typeof point.z === 'number'))\r\n            return gl_matrix_1.vec3.fromValues(point.x, point.y, point.z);\r\n        if (((point.X || point.X === 0) && typeof point.X === 'number') && ((point.Y || point.Y === 0) && typeof point.Y === 'number') && ((point.Z || point.Z === 0) && typeof point.Z === 'number'))\r\n            return gl_matrix_1.vec3.fromValues(point.X, point.Y, point.Z);\r\n        return gl_matrix_1.vec3.create();\r\n    }\r\n    // #endregion Public Methods (8)\r\n    // #region Private Methods (1)\r\n    tinyColorToString(color) {\r\n        return color.toHex8String();\r\n    }\r\n}\r\nexports.Converter = Converter;\r\n"},"sourceMaps":{"js":{"version":3,"file":"Converter.js","sourceRoot":"","sources":["../../src/converter/Converter.ts"],"names":[],"mappings":"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","sourcesContent":["import { vec3, vec4 } from 'gl-matrix'\r\nimport { TinyColor } from '@ctrl/tinycolor'\r\nimport { HttpClient } from '../http-client/HttpClient';\r\nimport { HttpResponse } from '../http-client/HttpResponse';\r\n\r\nexport class Converter {\r\n    // #region Properties (2)\r\n\r\n    private readonly _httpClient: HttpClient = HttpClient.instance;\r\n\r\n    private static _instance: Converter;\r\n\r\n    // #endregion Properties (2)\r\n\r\n    // #region Public Static Accessors (1)\r\n\r\n    public static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n\r\n    // #endregion Public Static Accessors (1)\r\n\r\n    // #region Public Methods (8)\r\n\r\n    public async processSVG(blob: Blob): Promise<HTMLImageElement> {\r\n        let data = <string>await new Promise((resolve, reject) => {\r\n            const reader = new FileReader();\r\n            reader.onloadend = () => resolve(<string>reader.result);\r\n            reader.onerror = reject;\r\n            reader.readAsDataURL(blob);\r\n        });\r\n        data = data.replace('data:image/svg+xml;base64,', '')\r\n        data = atob(data);\r\n\r\n        let svgC = document.createElement('DIV');\r\n        svgC.id = 'svgc';\r\n        svgC.innerHTML = <string>data;\r\n\r\n        // now we can access the svg element as a DOM object\r\n        let svgE = svgC.getElementsByTagName('svg');\r\n        let childImageURIs: string[] = [];\r\n        let styleURIs: string[] = [];\r\n\r\n        // collect image urls\r\n        for (let i = 0; i < svgE.length; ++i) {\r\n            for (let j = 0; j < 2; ++j) {\r\n                let childImages = <HTMLCollectionOf<SVGImageElement>>svgE[i].getElementsByTagName(['image', 'img'][j]);\r\n                for (let k = 0; k < childImages.length; ++k) {\r\n                    if (childImages[k].href.baseVal.substring(0, 5) != 'data:') {\r\n                        childImageURIs.push(childImages[k].href.baseVal);\r\n                    }\r\n                }\r\n            }\r\n            // collect potential font definitions\r\n            // we assume styles are imported using the following syntax:\r\n            // @import url(CSS_URL);\r\n            let styleElements = <HTMLCollectionOf<HTMLStyleElement>>svgE[i].getElementsByTagName('style');\r\n            for (let j = 0; j < styleElements.length; ++j) {\r\n                let regex = /@import\\x20url\\(\\s*(.*?)\\s*\\);/g;\r\n                let m;\r\n                while ((m = regex.exec(styleElements[j].innerHTML)) !== null) {\r\n                    styleURIs.push(m[1]);\r\n                }\r\n                // make unique\r\n                styleURIs = styleURIs.filter(\r\n                    function (value, index, self) {\r\n                        return self.indexOf(value) === index;\r\n                    }\r\n                );\r\n            }\r\n        }\r\n\r\n        // creating a promise for each image which needs to be converted to a data URI\r\n        let replacementPromises = [];\r\n        let createImagePromise = async (uri: string) => {\r\n            if (uri.length > 0) {\r\n                const response = await this._httpClient.loadTexture(uri);\r\n                let uInt8Array = new Uint8Array(response.data), i = uInt8Array.length;\r\n                let biStr = []; //new Array(i);\r\n                while (i--)\r\n                    biStr[i] = String.fromCharCode(uInt8Array[i]);\r\n\r\n                let base64Data = window.btoa(biStr.join(''));\r\n                let imgDataUrl = 'data:' + response.headers['content-type'] + ';base64,' + base64Data;\r\n\r\n                // replace url in SVG string\r\n                // CAUTION theoretically this could cause unwanted replacements\r\n                data = data.replace(uri, imgDataUrl);\r\n            }\r\n        };\r\n\r\n        for (let i = 0; i < childImageURIs.length; ++i)\r\n            replacementPromises.push(createImagePromise(childImageURIs[i]));\r\n\r\n        // now we create promises for the google fonts to be imported\r\n        let createStylePromise = async (styleUrl: string) => {\r\n            const response = await this._httpClient.get(\r\n                styleUrl,\r\n                { responseType: 'text' }\r\n            );\r\n            let cssString = response.data;\r\n            // we assume that fonts are imported using the following syntax:\r\n            // url(FONT_URI);\r\n            let fontURLs = [];\r\n            let regex = /url\\(\\s*(.*?)\\s*\\)/g;\r\n            let m;\r\n            while ((m = regex.exec(cssString)) !== null) {\r\n                fontURLs.push(m[1]);\r\n            }\r\n\r\n            let fontPromises = [];\r\n            let createFontPromise = async (fUrl: string) => {\r\n                const response = await this._httpClient.get(\r\n                    fUrl,\r\n                    { responseType: 'arraybuffer' }\r\n                );\r\n                let uInt8Array = new Uint8Array(response.data), i = uInt8Array.length;\r\n                let biStr = []; //new Array(i);\r\n                while (i--)\r\n                    biStr[i] = String.fromCharCode(uInt8Array[i]);\r\n\r\n                let base64Data = window.btoa(biStr.join(''));\r\n                let fontDataUrl = 'data:' + response.headers['content-type'] + ';base64,' + base64Data;\r\n                if (fUrl.length > 0)\r\n                    cssString = cssString.replace(fUrl, fontDataUrl);\r\n            };\r\n\r\n            for (let j = 0; j < fontURLs.length; ++j)\r\n                fontPromises.push(createFontPromise(fontURLs[j]));\r\n\r\n            await Promise.all(fontPromises);\r\n            data = data.replace('@import url(' + styleUrl + ');', cssString);\r\n        };\r\n\r\n        for (let i = 0; i < styleURIs.length; ++i)\r\n            replacementPromises.push(createStylePromise(styleURIs[i]));\r\n\r\n        await Promise.all(replacementPromises);\r\n\r\n        let du = 'data:image/svg+xml,' + encodeURIComponent(data);\r\n        let img = new Image(); // same as document.createElement('img')\r\n        img.crossOrigin = 'Anonymous';\r\n        const promise = new Promise<void>((resolve, reject) => {\r\n            img.onload = () => resolve();\r\n            img.onerror = reject;\r\n        })\r\n        img.src = du;\r\n        await promise;\r\n        return img;\r\n    }\r\n\r\n    public async responseToImage(response: HttpResponse<ArrayBuffer>): Promise<HTMLImageElement> {\r\n        const arrayBufferView = new Uint8Array( response.data );\r\n        const blob = new Blob([ arrayBufferView ], { type: response.headers['content-type'] } );\r\n        if (response.headers['content-type'] === 'image/svg+xml') {\r\n            const img = await this.processSVG(blob);\r\n            return img;\r\n        } else {\r\n            const img = new Image();\r\n            const promise = new Promise<void>((resolve, reject) => {\r\n                img.onload = () => resolve();\r\n                img.onerror = reject;\r\n            })\r\n            img.crossOrigin = \"anonymous\";\r\n            img.src = URL.createObjectURL(blob);\r\n            await promise;\r\n            URL.revokeObjectURL(img.src);\r\n            return img;\r\n        }\r\n    }\r\n\r\n    public toAlpha(color: any): number {\r\n        const c = this.toHexColor(color);\r\n        if (c.length <= 8) return 1;\r\n        return parseInt(c.slice(c.length - 2, c.length), 16) / 255;\r\n    }\r\n\r\n    public toColorArray(color: any): number[] {\r\n        if(typeof color !== 'string' || !color.startsWith(\"#\"))\r\n            color = this.toHexColor(color);\r\n        const tColor = new TinyColor(color);\r\n        const rgb = tColor.toRgb()\r\n        return [rgb.r / 255.0, rgb.g / 255.0, rgb.b / 255.0];\r\n    }\r\n\r\n    /**\r\n     * @param color \r\n     * @param defColor \r\n     */\r\n    public toHex8Color(color: any, defColorString: string = '#000'): string {\r\n        const c = this.toHexColor(color, defColorString);\r\n        const tColor = new TinyColor(c);\r\n        const cH8 = tColor.toHex8String();\r\n        return cH8.replace('#', '0x');\r\n    }\r\n\r\n    /**\r\n     * This color converter is mostly left 'as-is' from viewer v2.\r\n     * I didn't want to break something that works.\r\n     * \r\n     * @param color \r\n     * @param defColor \r\n     */\r\n    public toHexColor(color: any, defColorString: string = '#000'): string {\r\n        if (!color || color === 'default') return defColorString;\r\n\r\n        if (color.constructor === Float32Array)\r\n            color = Array.from(color);\r\n\r\n        const tColor = new TinyColor(color);\r\n\r\n        if (color instanceof TinyColor)\r\n            return this.tinyColorToString(tColor);\r\n\r\n        // check if we got a number\r\n        if (typeof color === 'number') {\r\n            let cs = color.toString(16);\r\n            let cl = cs.length;\r\n            if (cl < 3) cs = cs.padStart(3, '0');\r\n            else if (cl < 6) cs = cs.padStart(6, '0');\r\n            else if (cl < 8) cs = cs.padEnd(8, '0');\r\n            let tc = new TinyColor(cs);\r\n            return tc.isValid ? this.tinyColorToString(tc) : defColorString;\r\n        }\r\n\r\n        // check if the input is a THREE.Color\r\n        if (color.isColor && typeof color.getHexString == 'function') {\r\n            let tc = new TinyColor(color.getHexString());\r\n            return tc.isValid ? this.tinyColorToString(tc) : defColorString;\r\n        }\r\n\r\n        // check for array of numbers\r\n        if (Array.isArray(color) && (color.length == 3 || color.length == 4)) {\r\n            let isRGBArray = true;\r\n            for (let i = 0; i < 3; ++i) {\r\n                color[i] = parseFloat(color[i]);\r\n                if (isNaN(color[i])) {\r\n                    isRGBArray = false;\r\n                }\r\n            }\r\n            if (!isRGBArray)\r\n                return defColorString;\r\n\r\n            let tc = new TinyColor({\r\n                r: Math.max(0, Math.min(color[0], 255)),\r\n                g: Math.max(0, Math.min(color[1], 255)),\r\n                b: Math.max(0, Math.min(color[2], 255))\r\n            });\r\n            if (color.length == 4) {\r\n                let a = parseFloat(color[3]);\r\n                if (!isNaN(a)) {\r\n                    tc.setAlpha(Math.max(0, Math.min(a, 255)) / 255);\r\n                }\r\n            }\r\n            return tc.isValid ? this.tinyColorToString(tc) : defColorString;\r\n        }\r\n\r\n        // if we got something other than a string, check if\r\n        // tinycolor can work with it\r\n        if (typeof color !== 'string') {\r\n            let tc = new TinyColor(color);\r\n            return tc.isValid ? this.tinyColorToString(tc) : defColorString;\r\n        }\r\n\r\n        // tinycolor doesn't like 0x\r\n        let tmpColor = color.replace('0x', '#');\r\n\r\n        // if we got no alpha value, add full opacity\r\n        if (tmpColor.match(/^#[a-f0-9]{6}$/i) !== null) {\r\n            let tc = new TinyColor(tmpColor + 'ff');\r\n            return tc.isValid ? this.tinyColorToString(tc) : defColorString;\r\n        }\r\n\r\n        // standard case\r\n        if (tmpColor.match(/^#[a-f0-9]{8}$/i) !== null) {\r\n            let tc = new TinyColor(tmpColor);\r\n            return tc.isValid ? this.tinyColorToString(tc) : defColorString;\r\n        }\r\n\r\n        // correct number which have the alpha value defined as a single hex digit\r\n        if (tmpColor.match(/^#[a-f0-9]{7}$/i) !== null) {\r\n            let tc = new TinyColor(tmpColor.slice(0, 7) + '0' + tmpColor.slice(-1));\r\n            return tc.isValid ? this.tinyColorToString(tc) : defColorString;\r\n        }\r\n\r\n        // check if tinycolor understands the string\r\n        let tc = new TinyColor(tmpColor);\r\n        return tc.isValid ? this.tinyColorToString(tc) : defColorString;\r\n    }\r\n\r\n    public toThreeJsColorInput(color: any): string {\r\n        const c = this.toHexColor(color);\r\n        return c.slice(0, c.length - 2);\r\n    }\r\n\r\n    public toVec3(point: any): vec3 {\r\n        if (Array.isArray(point) && point.length >= 3 && typeof point[0] === 'number' && typeof point[1] === 'number' && typeof point[2] === 'number')\r\n            return vec3.fromValues(point[0], point[1], point[2]);\r\n\r\n        if (((point.x || point.x === 0) && typeof point.x === 'number') && ((point.y || point.y === 0) && typeof point.y === 'number') && ((point.z || point.z === 0) && typeof point.z === 'number'))\r\n            return vec3.fromValues(point.x, point.y, point.z);\r\n\r\n        if (((point.X || point.X === 0) && typeof point.X === 'number') && ((point.Y || point.Y === 0) && typeof point.Y === 'number') && ((point.Z || point.Z === 0) && typeof point.Z === 'number'))\r\n            return vec3.fromValues(point.X, point.Y, point.Z);\r\n\r\n        return vec3.create();\r\n    }\r\n\r\n    // #endregion Public Methods (8)\r\n\r\n    // #region Private Methods (1)\r\n\r\n    private tinyColorToString(color: TinyColor): string {\r\n        return color.toHex8String();\r\n    }\r\n\r\n    // #endregion Private Methods (1)\r\n}"]}},"error":null,"hash":"b57915e643343d31a9d89be030d2d46c","cacheData":{"env":{}}}