{"id":"node_modules/@shapediver/viewer.shared.math/dist/implementation/Triangle.js","dependencies":[{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.math\\dist\\implementation\\Triangle.js.map","includedInParent":true,"mtime":1706527150299},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.math\\src\\implementation\\Triangle.ts","includedInParent":true,"mtime":1706527150490},{"name":"D:\\projects\\myProjects\\shapeApp\\package.json","includedInParent":true,"mtime":1706533774939},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.math\\package.json","includedInParent":true,"mtime":1706527150101},{"name":"gl-matrix","loc":{"line":4,"column":28,"index":135},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.math\\dist\\implementation\\Triangle.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\gl-matrix\\esm\\index.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Triangle = void 0;\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nclass Triangle {\r\n    constructor(_v0 = gl_matrix_1.vec3.create(), _v1 = gl_matrix_1.vec3.create(), _v2 = gl_matrix_1.vec3.create()) {\r\n        this._v0 = _v0;\r\n        this._v1 = _v1;\r\n        this._v2 = _v2;\r\n    }\r\n    applyMatrix(matrix) {\r\n        gl_matrix_1.vec3.transformMat4(this._v0, this._v0, matrix);\r\n        gl_matrix_1.vec3.transformMat4(this._v1, this._v1, matrix);\r\n        gl_matrix_1.vec3.transformMat4(this._v2, this._v2, matrix);\r\n        return this;\r\n    }\r\n    clone() {\r\n        return new Triangle(gl_matrix_1.vec3.clone(this._v0), gl_matrix_1.vec3.clone(this._v1), gl_matrix_1.vec3.clone(this._v2));\r\n    }\r\n    // Möller–Trumbore intersection algorithm\r\n    intersect(origin, direction) {\r\n        const EPSILON = 0.0000001;\r\n        const edge1 = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), this._v1, this._v0);\r\n        const edge2 = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), this._v2, this._v0);\r\n        const h = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), direction, edge2);\r\n        const a = gl_matrix_1.vec3.dot(edge1, h);\r\n        if (a > -EPSILON && a < EPSILON)\r\n            return null; // This ray is parallel to this triangle.\r\n        const f = 1.0 / a;\r\n        const s = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), origin, this._v0);\r\n        const u = f * gl_matrix_1.vec3.dot(s, h);\r\n        if (u < 0.0 || u > 1.0)\r\n            return null;\r\n        const q = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), s, edge1);\r\n        const v = f * gl_matrix_1.vec3.dot(direction, q);\r\n        if (v < 0.0 || u + v > 1.0)\r\n            return null;\r\n        // At this stage we can compute t to find out where the intersection point is on the line.\r\n        const t = f * gl_matrix_1.vec3.dot(edge2, q);\r\n        return t > EPSILON ? gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), direction, gl_matrix_1.vec3.fromValues(t, t, t)), origin) : null;\r\n    }\r\n    reset() {\r\n        this._v0 = gl_matrix_1.vec3.create();\r\n        this._v1 = gl_matrix_1.vec3.create();\r\n        this._v2 = gl_matrix_1.vec3.create();\r\n    }\r\n}\r\nexports.Triangle = Triangle;\r\n"},"sourceMaps":{"js":{"version":3,"file":"Triangle.js","sourceRoot":"","sources":["../../src/implementation/Triangle.ts"],"names":[],"mappings":";;;AAAA,yCAAsC;AAItC,MAAa,QAAQ;IACjB,YACY,MAAY,gBAAI,CAAC,MAAM,EAAE,EACzB,MAAY,gBAAI,CAAC,MAAM,EAAE,EACzB,MAAY,gBAAI,CAAC,MAAM,EAAE;QAFzB,QAAG,GAAH,GAAG,CAAsB;QACzB,QAAG,GAAH,GAAG,CAAsB;QACzB,QAAG,GAAH,GAAG,CAAsB;IACjC,CAAC;IAEL,WAAW,CAAC,MAAY;QACpB,gBAAI,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;QAC/C,gBAAI,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;QAC/C,gBAAI,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;QAC/C,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,KAAK;QACD,OAAO,IAAI,QAAQ,CAAC,gBAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,gBAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,gBAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;IAC1F,CAAC;IAED,yCAAyC;IACzC,SAAS,CAAC,MAAY,EAAE,SAAe;QACnC,MAAM,OAAO,GAAG,SAAS,CAAC;QAC1B,MAAM,KAAK,GAAG,gBAAI,CAAC,GAAG,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;QAC1D,MAAM,KAAK,GAAG,gBAAI,CAAC,GAAG,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;QAC1D,MAAM,CAAC,GAAG,gBAAI,CAAC,KAAK,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,SAAS,EAAE,KAAK,CAAC,CAAA;QACrD,MAAM,CAAC,GAAG,gBAAI,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QAC7B,IAAI,CAAC,GAAG,CAAC,OAAO,IAAI,CAAC,GAAG,OAAO;YAC3B,OAAO,IAAI,CAAC,CAAI,yCAAyC;QAC7D,MAAM,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC;QAClB,MAAM,CAAC,GAAG,gBAAI,CAAC,GAAG,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;QACpD,MAAM,CAAC,GAAG,CAAC,GAAG,gBAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC7B,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,GAAG;YAClB,OAAO,IAAI,CAAC;QAChB,MAAM,CAAC,GAAG,gBAAI,CAAC,KAAK,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;QAC9C,MAAM,CAAC,GAAG,CAAC,GAAG,gBAAI,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;QACrC,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG;YACtB,OAAO,IAAI,CAAC;QAChB,0FAA0F;QAC1F,MAAM,CAAC,GAAG,CAAC,GAAG,gBAAI,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;QACjC,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,gBAAI,CAAC,GAAG,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,gBAAI,CAAC,QAAQ,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,SAAS,EAAE,gBAAI,CAAC,UAAU,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAA,CAAC,CAAA,IAAI,CAAC;IACjI,CAAC;IAED,KAAK;QACD,IAAI,CAAC,GAAG,GAAG,gBAAI,CAAC,MAAM,EAAE,CAAC;QACzB,IAAI,CAAC,GAAG,GAAG,gBAAI,CAAC,MAAM,EAAE,CAAC;QACzB,IAAI,CAAC,GAAG,GAAG,gBAAI,CAAC,MAAM,EAAE,CAAC;IAC7B,CAAC;CACJ;AA9CD,4BA8CC","sourcesContent":["import { mat4, vec3 } from 'gl-matrix'\r\nimport { ITriangle } from '../interfaces/ITriangle';\r\n\r\n\r\nexport class Triangle implements ITriangle {\r\n    constructor(\r\n        private _v0: vec3 = vec3.create(),\r\n        private _v1: vec3 = vec3.create(),\r\n        private _v2: vec3 = vec3.create(),\r\n    ) { }\r\n\r\n    applyMatrix(matrix: mat4): ITriangle {\r\n        vec3.transformMat4(this._v0, this._v0, matrix);\r\n        vec3.transformMat4(this._v1, this._v1, matrix);\r\n        vec3.transformMat4(this._v2, this._v2, matrix);\r\n        return this;\r\n    }\r\n\r\n    clone(): ITriangle {\r\n        return new Triangle(vec3.clone(this._v0), vec3.clone(this._v1), vec3.clone(this._v2));\r\n    }\r\n\r\n    // Möller–Trumbore intersection algorithm\r\n    intersect(origin: vec3, direction: vec3): vec3 | null {\r\n        const EPSILON = 0.0000001;\r\n        const edge1 = vec3.sub(vec3.create(), this._v1, this._v0);\r\n        const edge2 = vec3.sub(vec3.create(), this._v2, this._v0);\r\n        const h = vec3.cross(vec3.create(), direction, edge2)\r\n        const a = vec3.dot(edge1, h);\r\n        if (a > -EPSILON && a < EPSILON)\r\n            return null;    // This ray is parallel to this triangle.\r\n        const f = 1.0 / a;\r\n        const s = vec3.sub(vec3.create(), origin, this._v0);\r\n        const u = f * vec3.dot(s, h);\r\n        if (u < 0.0 || u > 1.0)\r\n            return null;\r\n        const q = vec3.cross(vec3.create(), s, edge1);\r\n        const v = f * vec3.dot(direction, q);\r\n        if (v < 0.0 || u + v > 1.0)\r\n            return null;\r\n        // At this stage we can compute t to find out where the intersection point is on the line.\r\n        const t = f * vec3.dot(edge2, q);\r\n        return t > EPSILON ? vec3.add(vec3.create(), vec3.multiply(vec3.create(), direction, vec3.fromValues(t, t, t)), origin):null;\r\n    }\r\n\r\n    reset() {\r\n        this._v0 = vec3.create();\r\n        this._v1 = vec3.create();\r\n        this._v2 = vec3.create();    \r\n    }\r\n}"]}},"error":null,"hash":"26e5bd697c8d3c9525dd56686a97baf8","cacheData":{"env":{}}}