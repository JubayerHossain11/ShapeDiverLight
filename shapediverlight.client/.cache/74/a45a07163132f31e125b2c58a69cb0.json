{"id":"node_modules/@shapediver/viewer.shared.math/dist/implementation/Sphere.js","dependencies":[{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.math\\dist\\implementation\\Sphere.js.map","includedInParent":true,"mtime":1706527150267},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.math\\src\\implementation\\Sphere.ts","includedInParent":true,"mtime":1706527150469},{"name":"D:\\projects\\myProjects\\shapeApp\\package.json","includedInParent":true,"mtime":1706533774939},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.math\\package.json","includedInParent":true,"mtime":1706527150101},{"name":"gl-matrix","loc":{"line":4,"column":28,"index":133},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.math\\dist\\implementation\\Sphere.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\gl-matrix\\esm\\index.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Sphere = void 0;\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nclass Sphere {\r\n    // #region Constructors (1)\r\n    constructor(_center = gl_matrix_1.vec3.create(), _radius = 0) {\r\n        this._center = _center;\r\n        this._radius = _radius;\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Accessors (4)\r\n    get center() {\r\n        return this._center;\r\n    }\r\n    set center(value) {\r\n        this._center = value;\r\n    }\r\n    get radius() {\r\n        return this._radius;\r\n    }\r\n    set radius(value) {\r\n        this._radius = value;\r\n    }\r\n    // #endregion Public Accessors (4)\r\n    // #region Public Methods (4)\r\n    applyMatrix(matrix) {\r\n        this._center = gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), this._center, matrix);\r\n        const scaleXSq = matrix[0] * matrix[0] + matrix[1] * matrix[1] + matrix[2] * matrix[2];\r\n        const scaleYSq = matrix[4] * matrix[4] + matrix[5] * matrix[5] + matrix[6] * matrix[6];\r\n        const scaleZSq = matrix[8] * matrix[8] + matrix[9] * matrix[9] + matrix[10] * matrix[10];\r\n        const maxScaleOnAxis = Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\r\n        this.radius = this.radius * maxScaleOnAxis;\r\n        return this;\r\n    }\r\n    clone() {\r\n        return new Sphere(gl_matrix_1.vec3.clone(this._center), this._radius);\r\n    }\r\n    containsPoint(point) {\r\n        return (gl_matrix_1.vec3.squaredDistance(point, this.center) <= (this.radius * this.radius));\r\n    }\r\n    clampPoint(point) {\r\n        return point;\r\n    }\r\n    intersect(origin, direction) {\r\n        // vector from ray origin to sphere center\r\n        const rayToSphere = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), this.center, origin);\r\n        // project rayToSphere onto direction\r\n        const projection = gl_matrix_1.vec3.dot(rayToSphere, direction);\r\n        // distance from sphere center to projection\r\n        const distanceToProjection = gl_matrix_1.vec3.squaredDistance(rayToSphere, gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), direction, gl_matrix_1.vec3.fromValues(projection, projection, projection)));\r\n        // check if the distance to projection is less than the radius\r\n        if (distanceToProjection <= this.radius * this.radius) {\r\n            // calculate the distance from the origin to the intersection point\r\n            const distanceToIntersection = Math.sqrt(this.radius * this.radius - distanceToProjection);\r\n            return projection - distanceToIntersection;\r\n        }\r\n        // if there is no intersection, return null\r\n        return null;\r\n    }\r\n    intersects(origin, direction) {\r\n        // vector from ray origin to sphere center\r\n        const rayToSphere = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), this.center, origin);\r\n        // project rayToSphere onto direction\r\n        const projection = gl_matrix_1.vec3.dot(rayToSphere, direction);\r\n        // distance from sphere center to projection\r\n        const distanceToProjection = gl_matrix_1.vec3.squaredDistance(rayToSphere, gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), direction, gl_matrix_1.vec3.fromValues(projection, projection, projection)));\r\n        return distanceToProjection <= this.radius * this.radius;\r\n    }\r\n    setFromBox(box) {\r\n        gl_matrix_1.vec3.add(this.center, box.min, box.max);\r\n        gl_matrix_1.vec3.scale(this.center, this.center, 0.5);\r\n        this.radius = gl_matrix_1.vec3.dist(box.min, box.max) * 0.5;\r\n        return this;\r\n    }\r\n    reset() {\r\n        this._center = gl_matrix_1.vec3.create();\r\n        this._radius = 0;\r\n    }\r\n}\r\nexports.Sphere = Sphere;\r\n"},"sourceMaps":{"js":{"version":3,"file":"Sphere.js","sourceRoot":"","sources":["../../src/implementation/Sphere.ts"],"names":[],"mappings":"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","sourcesContent":["import { mat4, vec3 } from 'gl-matrix'\r\nimport { IBox } from '../interfaces/IBox';\r\nimport { ISphere } from '../interfaces/ISphere';\r\n\r\nexport class Sphere implements ISphere {\r\n    // #region Constructors (1)\r\n\r\n    constructor(\r\n        private _center: vec3 = vec3.create(),\r\n        private _radius: number = 0\r\n    ) { }\r\n\r\n    // #endregion Constructors (1)\r\n\r\n    // #region Public Accessors (4)\r\n\r\n    public get center(): vec3 {\r\n        return this._center;\r\n    }\r\n\r\n    public set center(value: vec3) {\r\n        this._center = value;\r\n    }\r\n\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n    }\r\n    \r\n    // #endregion Public Accessors (4)\r\n\r\n    // #region Public Methods (4)\r\n\r\n    public applyMatrix(matrix: mat4): Sphere {\r\n        this._center = vec3.transformMat4(vec3.create(), this._center, matrix);\r\n        const scaleXSq = matrix[0] * matrix[0] + matrix[1] * matrix[1] + matrix[2] * matrix[2];\r\n        const scaleYSq = matrix[4] * matrix[4] + matrix[5] * matrix[5] + matrix[6] * matrix[6];\r\n        const scaleZSq = matrix[8] * matrix[8] + matrix[9] * matrix[9] + matrix[10] * matrix[10];\r\n        const maxScaleOnAxis = Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\r\n        this.radius = this.radius * maxScaleOnAxis;\r\n        return this;\r\n    }\r\n\r\n    public clone(): ISphere {\r\n        return new Sphere(vec3.clone(this._center), this._radius);\r\n    }\r\n\r\n    public containsPoint(point: vec3): boolean {\r\n        return (vec3.squaredDistance(point, this.center) <= (this.radius * this.radius));\r\n    }\r\n\r\n    public clampPoint(point: vec3): vec3 {\r\n        return point;\r\n    }\r\n\r\n    public intersect(origin: vec3, direction: vec3): number | null {\r\n        // vector from ray origin to sphere center\r\n        const rayToSphere = vec3.sub(vec3.create(), this.center, origin);\r\n\r\n        // project rayToSphere onto direction\r\n        const projection = vec3.dot(rayToSphere, direction);\r\n\r\n        // distance from sphere center to projection\r\n        const distanceToProjection = vec3.squaredDistance(rayToSphere, vec3.multiply(vec3.create(), direction, vec3.fromValues(projection, projection, projection)));\r\n\r\n        // check if the distance to projection is less than the radius\r\n        if (distanceToProjection <= this.radius * this.radius) {\r\n            // calculate the distance from the origin to the intersection point\r\n            const distanceToIntersection = Math.sqrt(this.radius * this.radius - distanceToProjection);\r\n            return projection - distanceToIntersection;\r\n        }\r\n\r\n        // if there is no intersection, return null\r\n        return null;\r\n    }\r\n\r\n    public intersects(origin: vec3, direction: vec3): boolean {\r\n        // vector from ray origin to sphere center\r\n        const rayToSphere = vec3.sub(vec3.create(), this.center, origin);\r\n\r\n        // project rayToSphere onto direction\r\n        const projection = vec3.dot(rayToSphere, direction);\r\n\r\n        // distance from sphere center to projection\r\n        const distanceToProjection = vec3.squaredDistance(rayToSphere, vec3.multiply(vec3.create(), direction, vec3.fromValues(projection, projection, projection)));\r\n        return distanceToProjection <= this.radius * this.radius;\r\n    }\r\n\r\n    public setFromBox(box: IBox): ISphere {\r\n        vec3.add(this.center, box.min, box.max);\r\n        vec3.scale(this.center, this.center, 0.5);\r\n        this.radius = vec3.dist(box.min, box.max) * 0.5;\r\n        return this;\r\n    }\r\n\r\n    public reset() {\r\n        this._center = vec3.create();\r\n        this._radius = 0;\r\n    }\r\n\r\n    // #endregion Public Methods (4)\r\n}"]}},"error":null,"hash":"c45cfc1d598dd593dcfe55d604b7e290","cacheData":{"env":{}}}