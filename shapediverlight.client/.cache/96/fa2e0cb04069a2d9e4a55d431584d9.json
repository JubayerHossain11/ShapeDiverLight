{"id":"node_modules/@shapediver/viewer.rendering-engine-threejs.standard/dist/three/shaders/SAOShader.js","dependencies":[{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\dist\\three\\shaders\\SAOShader.js.map","includedInParent":true,"mtime":1706527153681},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\src\\three\\shaders\\SAOShader.js","includedInParent":true,"mtime":1706527152707},{"name":"D:\\projects\\myProjects\\shapeApp\\package.json","includedInParent":true,"mtime":1706533774939},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\package.json","includedInParent":true,"mtime":1706527152875},{"name":"three","loc":{"line":4,"column":24,"index":132},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\dist\\three\\shaders\\SAOShader.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\three\\build\\three.module.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SAOShader = void 0;\r\nconst three_1 = require(\"three\");\r\n/**\r\n * TODO\r\n */\r\nconst SAOShader = {\r\n    defines: {\r\n        'NUM_SAMPLES': 8,\r\n        'NORMAL_TEXTURE': 0,\r\n        'DIFFUSE_TEXTURE': 0,\r\n        'PERSPECTIVE_CAMERA': 1\r\n    },\r\n    uniforms: {\r\n        'tDepth': { value: null },\r\n        'tDiffuse': { value: null },\r\n        'tNormal': { value: null },\r\n        'size': { value: new three_1.Vector2(512, 512) },\r\n        'cameraNear': { value: 1 },\r\n        'cameraFar': { value: 100 },\r\n        'cameraProjectionMatrix': { value: new three_1.Matrix4() },\r\n        'cameraInverseProjectionMatrix': { value: new three_1.Matrix4() },\r\n        'scale': { value: 1.0 },\r\n        'intensity': { value: 0.1 },\r\n        'bias': { value: 0.5 },\r\n        'minResolution': { value: 0.0 },\r\n        'kernelRadius': { value: 100.0 },\r\n        'randomSeed': { value: 0.0 }\r\n    },\r\n    vertexShader: /* glsl */ `\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t}`,\r\n    fragmentShader: /* glsl */ `\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\t#if DIFFUSE_TEXTURE == 1\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\t#endif\r\n\r\n\t\tuniform sampler2D tDepth;\r\n\r\n\t\t#if NORMAL_TEXTURE == 1\r\n\t\tuniform sampler2D tNormal;\r\n\t\t#endif\r\n\r\n\t\tuniform float cameraNear;\r\n\t\tuniform float cameraFar;\r\n\t\tuniform mat4 cameraProjectionMatrix;\r\n\t\tuniform mat4 cameraInverseProjectionMatrix;\r\n\r\n\t\tuniform float scale;\r\n\t\tuniform float intensity;\r\n\t\tuniform float kernelRadius;\r\n\t\tuniform vec2 size;\r\n\r\n\t\t// RGBA depth\r\n\r\n\t\t#include <common>\r\n\t\t#include <packing>\r\n\r\n\t\tvec4 getDefaultColor( const in vec2 screenPosition ) {\r\n\t\t\t#if DIFFUSE_TEXTURE == 1\r\n\t\t\treturn texture2D( tDiffuse, vUv );\r\n\t\t\t#else\r\n\t\t\treturn vec4( 1.0 );\r\n\t\t\t#endif\r\n\t\t}\r\n\r\n\t\tvec3 getViewPosition(const in vec2 screenPosition, const in float depth, const in float viewZ) {\r\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\r\n\t\t\tvec4 clipPosition = vec4((vec3(screenPosition, depth) - 0.5) * 2.0, 1.0);\r\n\t\t\tclipPosition *= clipW; // unprojection\r\n\t\t\r\n\t\t\treturn (cameraInverseProjectionMatrix * clipPosition).xyz;\r\n\t\t}\r\n\r\n\t\tfloat getViewZ( const in float depth ) {\r\n\t\t\t#if PERSPECTIVE_CAMERA == 1\r\n\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\r\n\t\t\t#else\r\n\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\r\n\t\t\t#endif\r\n\t\t}\r\n\t\t\r\n\t\tfloat getOcclusion(const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition) {\r\n\t\t\tvec3 viewDelta = sampleViewPosition - centerViewPosition;\r\n\t\t\tfloat viewDistance = length(viewDelta);\r\n\t\t\tfloat scaledScreenDistance = scale * viewDistance;\r\n\t\t\treturn max(0.0, (dot(centerViewNormal, viewDelta))/scaledScreenDistance)/(1.0 + pow2(scaledScreenDistance));\r\n\t\t}\r\n\t\t\r\n\t\tfloat getAmbientOcclusion(const in vec3 centerViewPosition) {\r\n\t\t\tvec3 centerViewNormal = unpackRGBToNormal(texture2D(tNormal, vUv).xyz);\r\n\t\t\r\n\t\t\tfloat angle = rand(vUv) * PI2;\r\n\t\t\tvec2 radius = vec2(kernelRadius * (1.0/float(NUM_SAMPLES)))/size;\r\n\t\t\tvec2 radiusStep = radius;\r\n\t\t\tfloat occlusionSum = 0.0;\r\n\t\t\tfloat weightSum = 0.0;\r\n\t\t\tfloat angleStep = PI2 * 3.0/float(NUM_SAMPLES);\r\n\t\t\r\n\t\t\tfor(int i = 0; i < NUM_SAMPLES; i ++) {\r\n\t\t\t\tvec2 sampleUv = vUv + vec2(cos(angle), sin(angle)) * radius;\r\n\t\t\t\tradius += radiusStep;\r\n\t\t\t\tangle += PI2 * 3.0/float(NUM_SAMPLES);\r\n\t\t\r\n\t\t\t\tfloat sampleDepth = unpackRGBAToDepth(texture2D(tDepth, sampleUv));\r\n\t\t\t\tif(sampleDepth >= (1.0 - EPSILON)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\r\n\t\t\t\tfloat sampleViewZ = getViewZ(sampleDepth);\r\n\t\t\t\tvec3 sampleViewPosition = getViewPosition(sampleUv, sampleDepth, sampleViewZ);\r\n\t\t\t\tocclusionSum += getOcclusion(centerViewPosition, centerViewNormal, sampleViewPosition);\r\n\t\t\t\tweightSum += 1.0;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tif(weightSum == 0.0) discard;\r\n\t\t\r\n\t\t\treturn occlusionSum * (intensity/weightSum);\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\t\t\tfloat centerDepth = unpackRGBAToDepth(texture2D(tDepth, vUv));\r\n\t\t\tif( centerDepth >= ( 1.0 - EPSILON ) ) {\r\n\t\t\t\tdiscard;\r\n\t\t\t}\r\n\r\n\t\t\tfloat centerViewZ = getViewZ( centerDepth );\r\n\t\t\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );\r\n\t\t\tgl_FragColor = vec4(viewPosition, 1);\r\n\r\n\t\t\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\r\n\r\n\t\t\tgl_FragColor = getDefaultColor( vUv );\r\n\t\t\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;\r\n\t\t}`\r\n};\r\nexports.SAOShader = SAOShader;\r\n"},"sourceMaps":{"js":{"version":3,"file":"SAOShader.js","sourceRoot":"","sources":["../../../src/three/shaders/SAOShader.js"],"names":[],"mappings":";;;AAAA,iCAGe;AAEf;;GAEG;AAEH,MAAM,SAAS,GAAG;IACjB,OAAO,EAAE;QACR,aAAa,EAAE,CAAC;QAChB,gBAAgB,EAAE,CAAC;QACnB,iBAAiB,EAAE,CAAC;QACpB,oBAAoB,EAAE,CAAC;KACvB;IACD,QAAQ,EAAE;QAET,QAAQ,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE;QACzB,UAAU,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE;QAC3B,SAAS,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE;QAC1B,MAAM,EAAE,EAAE,KAAK,EAAE,IAAI,eAAO,CAAE,GAAG,EAAE,GAAG,CAAE,EAAE;QAE1C,YAAY,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE;QAC1B,WAAW,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE;QAC3B,wBAAwB,EAAE,EAAE,KAAK,EAAE,IAAI,eAAO,EAAE,EAAE;QAClD,+BAA+B,EAAE,EAAE,KAAK,EAAE,IAAI,eAAO,EAAE,EAAE;QAEzD,OAAO,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE;QACvB,WAAW,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE;QAC3B,MAAM,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE;QAEtB,eAAe,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE;QAC/B,cAAc,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE;QAChC,YAAY,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE;KAC5B;IACD,YAAY,EAAE,UAAU,CAAA;;;;;;;IAOrB;IAEH,cAAc,EAAE,UAAU,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAyGvB;CAEH,CAAC;AAEO,8BAAS","sourcesContent":["import {\r\n\tMatrix4,\r\n\tVector2\r\n} from 'three';\r\n\r\n/**\r\n * TODO\r\n */\r\n\r\nconst SAOShader = {\r\n\tdefines: {\r\n\t\t'NUM_SAMPLES': 8,\r\n\t\t'NORMAL_TEXTURE': 0,\r\n\t\t'DIFFUSE_TEXTURE': 0,\r\n\t\t'PERSPECTIVE_CAMERA': 1\r\n\t},\r\n\tuniforms: {\r\n\r\n\t\t'tDepth': { value: null },\r\n\t\t'tDiffuse': { value: null },\r\n\t\t'tNormal': { value: null },\r\n\t\t'size': { value: new Vector2( 512, 512 ) },\r\n\r\n\t\t'cameraNear': { value: 1 },\r\n\t\t'cameraFar': { value: 100 },\r\n\t\t'cameraProjectionMatrix': { value: new Matrix4() },\r\n\t\t'cameraInverseProjectionMatrix': { value: new Matrix4() },\r\n\r\n\t\t'scale': { value: 1.0 },\r\n\t\t'intensity': { value: 0.1 },\r\n\t\t'bias': { value: 0.5 },\r\n\r\n\t\t'minResolution': { value: 0.0 },\r\n\t\t'kernelRadius': { value: 100.0 },\r\n\t\t'randomSeed': { value: 0.0 }\r\n\t},\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\t#if DIFFUSE_TEXTURE == 1\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\t#endif\r\n\r\n\t\tuniform sampler2D tDepth;\r\n\r\n\t\t#if NORMAL_TEXTURE == 1\r\n\t\tuniform sampler2D tNormal;\r\n\t\t#endif\r\n\r\n\t\tuniform float cameraNear;\r\n\t\tuniform float cameraFar;\r\n\t\tuniform mat4 cameraProjectionMatrix;\r\n\t\tuniform mat4 cameraInverseProjectionMatrix;\r\n\r\n\t\tuniform float scale;\r\n\t\tuniform float intensity;\r\n\t\tuniform float kernelRadius;\r\n\t\tuniform vec2 size;\r\n\r\n\t\t// RGBA depth\r\n\r\n\t\t#include <common>\r\n\t\t#include <packing>\r\n\r\n\t\tvec4 getDefaultColor( const in vec2 screenPosition ) {\r\n\t\t\t#if DIFFUSE_TEXTURE == 1\r\n\t\t\treturn texture2D( tDiffuse, vUv );\r\n\t\t\t#else\r\n\t\t\treturn vec4( 1.0 );\r\n\t\t\t#endif\r\n\t\t}\r\n\r\n\t\tvec3 getViewPosition(const in vec2 screenPosition, const in float depth, const in float viewZ) {\r\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\r\n\t\t\tvec4 clipPosition = vec4((vec3(screenPosition, depth) - 0.5) * 2.0, 1.0);\r\n\t\t\tclipPosition *= clipW; // unprojection\r\n\t\t\r\n\t\t\treturn (cameraInverseProjectionMatrix * clipPosition).xyz;\r\n\t\t}\r\n\r\n\t\tfloat getViewZ( const in float depth ) {\r\n\t\t\t#if PERSPECTIVE_CAMERA == 1\r\n\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\r\n\t\t\t#else\r\n\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\r\n\t\t\t#endif\r\n\t\t}\r\n\t\t\r\n\t\tfloat getOcclusion(const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition) {\r\n\t\t\tvec3 viewDelta = sampleViewPosition - centerViewPosition;\r\n\t\t\tfloat viewDistance = length(viewDelta);\r\n\t\t\tfloat scaledScreenDistance = scale * viewDistance;\r\n\t\t\treturn max(0.0, (dot(centerViewNormal, viewDelta))/scaledScreenDistance)/(1.0 + pow2(scaledScreenDistance));\r\n\t\t}\r\n\t\t\r\n\t\tfloat getAmbientOcclusion(const in vec3 centerViewPosition) {\r\n\t\t\tvec3 centerViewNormal = unpackRGBToNormal(texture2D(tNormal, vUv).xyz);\r\n\t\t\r\n\t\t\tfloat angle = rand(vUv) * PI2;\r\n\t\t\tvec2 radius = vec2(kernelRadius * (1.0/float(NUM_SAMPLES)))/size;\r\n\t\t\tvec2 radiusStep = radius;\r\n\t\t\tfloat occlusionSum = 0.0;\r\n\t\t\tfloat weightSum = 0.0;\r\n\t\t\tfloat angleStep = PI2 * 3.0/float(NUM_SAMPLES);\r\n\t\t\r\n\t\t\tfor(int i = 0; i < NUM_SAMPLES; i ++) {\r\n\t\t\t\tvec2 sampleUv = vUv + vec2(cos(angle), sin(angle)) * radius;\r\n\t\t\t\tradius += radiusStep;\r\n\t\t\t\tangle += PI2 * 3.0/float(NUM_SAMPLES);\r\n\t\t\r\n\t\t\t\tfloat sampleDepth = unpackRGBAToDepth(texture2D(tDepth, sampleUv));\r\n\t\t\t\tif(sampleDepth >= (1.0 - EPSILON)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\r\n\t\t\t\tfloat sampleViewZ = getViewZ(sampleDepth);\r\n\t\t\t\tvec3 sampleViewPosition = getViewPosition(sampleUv, sampleDepth, sampleViewZ);\r\n\t\t\t\tocclusionSum += getOcclusion(centerViewPosition, centerViewNormal, sampleViewPosition);\r\n\t\t\t\tweightSum += 1.0;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tif(weightSum == 0.0) discard;\r\n\t\t\r\n\t\t\treturn occlusionSum * (intensity/weightSum);\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\t\t\tfloat centerDepth = unpackRGBAToDepth(texture2D(tDepth, vUv));\r\n\t\t\tif( centerDepth >= ( 1.0 - EPSILON ) ) {\r\n\t\t\t\tdiscard;\r\n\t\t\t}\r\n\r\n\t\t\tfloat centerViewZ = getViewZ( centerDepth );\r\n\t\t\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );\r\n\t\t\tgl_FragColor = vec4(viewPosition, 1);\r\n\r\n\t\t\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\r\n\r\n\t\t\tgl_FragColor = getDefaultColor( vUv );\r\n\t\t\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;\r\n\t\t}`\r\n\r\n};\r\n\r\nexport { SAOShader };\r\n"]}},"error":null,"hash":"96225d5cf3f6c23c044590dc9488bb2d","cacheData":{"env":{}}}