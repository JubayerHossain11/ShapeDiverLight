{"id":"node_modules/@shapediver/viewer.rendering-engine-threejs.standard/dist/managers/SceneTracingManager.js","dependencies":[{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\dist\\managers\\SceneTracingManager.js.map","includedInParent":true,"mtime":1706542087070},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\src\\managers\\SceneTracingManager.ts","includedInParent":true,"mtime":1706542087520},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\package.json","includedInParent":true,"mtime":1706542184022},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\package.json","includedInParent":true,"mtime":1706542086641},{"name":"gl-matrix","loc":{"line":4,"column":28,"index":146},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\dist\\managers\\SceneTracingManager.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\gl-matrix\\esm\\index.js"},{"name":"@shapediver/viewer.rendering-engine.camera-engine","loc":{"line":5,"column":56,"index":217},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\dist\\managers\\SceneTracingManager.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.camera-engine\\dist\\index.js"},{"name":"@shapediver/viewer.shared.services","loc":{"line":6,"column":41,"index":313},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\dist\\managers\\SceneTracingManager.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\dist\\index.js"},{"name":"@shapediver/viewer.rendering-engine.intersection-engine","loc":{"line":7,"column":62,"index":415},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\dist\\managers\\SceneTracingManager.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.intersection-engine\\dist\\index.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SceneTracingManager = void 0;\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nconst viewer_rendering_engine_camera_engine_1 = require(\"@shapediver/viewer.rendering-engine.camera-engine\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst viewer_rendering_engine_intersection_engine_1 = require(\"@shapediver/viewer.rendering-engine.intersection-engine\");\r\nclass SceneTracingManager {\r\n    // #endregion Properties (2)\r\n    // #region Constructors (1)\r\n    constructor(_renderingEngine) {\r\n        this._renderingEngine = _renderingEngine;\r\n        // #region Properties (2)\r\n        this._intersectionManager = viewer_rendering_engine_intersection_engine_1.IntersectionEngine.instance;\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Methods (3)\r\n    convert3Dto2D(p) {\r\n        const canvasPageCoordinates = this._renderingEngine.canvas.getBoundingClientRect(), width = this._renderingEngine.canvas.width, height = this._renderingEngine.canvas.height;\r\n        const camera = this._renderingEngine.cameraEngine.camera;\r\n        if (!camera)\r\n            throw new viewer_shared_services_1.ShapeDiverViewerGeneralError('SceneTracingManager.convert3Dto2D: No camera is defined for this viewer.');\r\n        const direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), p, camera.position));\r\n        const tracing = this._intersectionManager.intersect({ origin: camera.position, direction });\r\n        const pos = camera.project(gl_matrix_1.vec3.clone(p));\r\n        pos[0] = (pos[0] * (width / 2)) + (width / 2);\r\n        pos[1] = -(pos[1] * (height / 2)) + (height / 2);\r\n        // take care of correction by device pixel ratio\r\n        pos[0] = pos[0] / devicePixelRatio;\r\n        pos[1] = pos[1] / devicePixelRatio;\r\n        // epsilon is added as a distance spacer as users tend to put the anchors of html elements directly at the vertices\r\n        // with this we prevent flickering\r\n        const eps = 0.0001;\r\n        return {\r\n            hidden: tracing.length > 0 && tracing[0].distance + eps < gl_matrix_1.vec3.distance(camera.position, p),\r\n            container: gl_matrix_1.vec2.clone(pos),\r\n            client: gl_matrix_1.vec2.fromValues(pos[0] + canvasPageCoordinates.left, pos[1] + canvasPageCoordinates.top),\r\n            page: gl_matrix_1.vec2.fromValues(pos[0] + canvasPageCoordinates.left + window.pageXOffset, pos[1] + canvasPageCoordinates.top + window.pageYOffset)\r\n        };\r\n    }\r\n    init() { }\r\n    /**\r\n     * Calculate the ray that is created by the mouse event and the camera.\r\n     *\r\n     * @param event\r\n     * @returns\r\n     */\r\n    mouseEventToRay(event) {\r\n        const rect = this._renderingEngine.canvas.getBoundingClientRect();\r\n        const camera = this._renderingEngine.cameraEngine.camera;\r\n        if (!camera)\r\n            throw new viewer_shared_services_1.ShapeDiverViewerGeneralError('SceneTracingManager.mouseEventToRay: No camera is defined for this viewer.');\r\n        let _mouse_x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n        let _mouse_y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n        let origin = gl_matrix_1.vec3.clone(camera.position);\r\n        if (camera instanceof viewer_rendering_engine_camera_engine_1.OrthographicCamera) {\r\n            if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.right, _mouse_y * camera.top, 0));\r\n            }\r\n            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.left, _mouse_y * camera.top, 0));\r\n            }\r\n            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.left, _mouse_y * camera.top));\r\n            }\r\n            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.right, _mouse_y * camera.top));\r\n            }\r\n            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.right, 0, _mouse_y * camera.top));\r\n            }\r\n            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.left, 0, _mouse_y * camera.top));\r\n            }\r\n        }\r\n        let direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), camera.unproject(gl_matrix_1.vec3.fromValues(_mouse_x, _mouse_y, 0.5)), origin));\r\n        return { origin, direction };\r\n    }\r\n    /**\r\n     * Create the ray that is created by the touch event and the camera.\r\n     *\r\n     * @param event\r\n     * @returns\r\n     */\r\n    touchEventToRay(event) {\r\n        if (event.touches.length > 1)\r\n            throw new viewer_shared_services_1.ShapeDiverViewerGeneralError('SceneTracingManager.touchEventToRay: No touches in this event.');\r\n        const touch = event.changedTouches[0];\r\n        const rect = this._renderingEngine.canvas.getBoundingClientRect();\r\n        const camera = this._renderingEngine.cameraEngine.camera;\r\n        if (!camera)\r\n            throw new viewer_shared_services_1.ShapeDiverViewerGeneralError('SceneTracingManager.touchEventToRay: No camera is defined for this viewer.');\r\n        let _mouse_x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;\r\n        let _mouse_y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;\r\n        let origin = gl_matrix_1.vec3.clone(camera.position);\r\n        if (camera instanceof viewer_rendering_engine_camera_engine_1.OrthographicCamera) {\r\n            if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.right, _mouse_y * camera.top, 0));\r\n            }\r\n            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.left, _mouse_y * camera.top, 0));\r\n            }\r\n            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.left, _mouse_y * camera.top));\r\n            }\r\n            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.right, _mouse_y * camera.top));\r\n            }\r\n            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.right, 0, _mouse_y * camera.top));\r\n            }\r\n            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.left, 0, _mouse_y * camera.top));\r\n            }\r\n        }\r\n        let direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), camera.unproject(gl_matrix_1.vec3.fromValues(_mouse_x, _mouse_y, 0.5)), origin));\r\n        return { origin, direction };\r\n    }\r\n    /**\r\n     * Create the ray that is created by the touch event and the camera.\r\n     *\r\n     * @param event\r\n     * @returns\r\n     */\r\n    touchToRay(event) {\r\n        const rect = this._renderingEngine.canvas.getBoundingClientRect();\r\n        const camera = this._renderingEngine.cameraEngine.camera;\r\n        if (!camera)\r\n            throw new viewer_shared_services_1.ShapeDiverViewerGeneralError('SceneTracingManager.touchToRay: No camera is defined for this viewer.');\r\n        let _mouse_x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n        let _mouse_y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n        let origin = gl_matrix_1.vec3.clone(camera.position);\r\n        if (camera instanceof viewer_rendering_engine_camera_engine_1.OrthographicCamera) {\r\n            if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.TOP) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.right, _mouse_y * camera.top, 0));\r\n            }\r\n            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.left, _mouse_y * camera.top, 0));\r\n            }\r\n            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.left, _mouse_y * camera.top));\r\n            }\r\n            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(0, _mouse_x * camera.right, _mouse_y * camera.top));\r\n            }\r\n            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.right, 0, _mouse_y * camera.top));\r\n            }\r\n            else if (camera.direction == viewer_rendering_engine_camera_engine_1.ORTHOGRAPHIC_CAMERA_DIRECTION.BACK) {\r\n                origin = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), camera.position, gl_matrix_1.vec3.fromValues(_mouse_x * camera.left, 0, _mouse_y * camera.top));\r\n            }\r\n        }\r\n        let direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), camera.unproject(gl_matrix_1.vec3.fromValues(_mouse_x, _mouse_y, 0.5)), origin));\r\n        return { origin, direction };\r\n    }\r\n}\r\nexports.SceneTracingManager = SceneTracingManager;\r\n"},"sourceMaps":{"js":{"version":3,"file":"SceneTracingManager.js","sourceRoot":"","sources":["../../src/managers/SceneTracingManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { vec2, vec3 } from 'gl-matrix'\r\nimport { AbstractCamera, OrthographicCamera, ORTHOGRAPHIC_CAMERA_DIRECTION } from '@shapediver/viewer.rendering-engine.camera-engine'\r\nimport { ShapeDiverViewerGeneralError } from '@shapediver/viewer.shared.services'\r\nimport { IManager } from '@shapediver/viewer.rendering-engine.rendering-engine'\r\nimport { IntersectionEngine } from '@shapediver/viewer.rendering-engine.intersection-engine'\r\n\r\nimport { RenderingEngine } from '../RenderingEngine'\r\n\r\nexport class SceneTracingManager implements IManager {\r\n    // #region Properties (2)\r\n\r\n    private readonly _intersectionManager: IntersectionEngine = IntersectionEngine.instance;\r\n\r\n    // #endregion Properties (2)\r\n\r\n    // #region Constructors (1)\r\n\r\n    constructor(private readonly _renderingEngine: RenderingEngine) { }\r\n\r\n    // #endregion Constructors (1)\r\n\r\n    // #region Public Methods (3)\r\n\r\n    public convert3Dto2D(p: vec3): {\r\n        container: vec2, client: vec2, page: vec2, hidden: boolean\r\n    } {\r\n        const canvasPageCoordinates = this._renderingEngine.canvas.getBoundingClientRect(),\r\n            width = this._renderingEngine.canvas.width,\r\n            height = this._renderingEngine.canvas.height;\r\n\r\n        const camera = this._renderingEngine.cameraEngine.camera;\r\n        if (!camera) \r\n            throw new ShapeDiverViewerGeneralError('SceneTracingManager.convert3Dto2D: No camera is defined for this viewer.');\r\n\r\n        const direction = vec3.normalize(vec3.create(), vec3.subtract(vec3.create(), p, camera.position));\r\n        const tracing = this._intersectionManager.intersect({ origin: camera.position, direction });\r\n\r\n        const pos: vec2 = (<AbstractCamera>camera).project(vec3.clone(p));\r\n\r\n        pos[0] = (pos[0] * (width / 2)) + (width / 2);\r\n        pos[1] = - (pos[1] * (height / 2)) + (height / 2);\r\n\r\n        // take care of correction by device pixel ratio\r\n        pos[0] = pos[0] / devicePixelRatio;\r\n        pos[1] = pos[1] / devicePixelRatio;\r\n\r\n        // epsilon is added as a distance spacer as users tend to put the anchors of html elements directly at the vertices\r\n        // with this we prevent flickering\r\n        const eps = 0.0001;\r\n\r\n        return {\r\n            hidden: tracing.length > 0 && tracing[0].distance + eps < vec3.distance(camera.position, p),\r\n            container: vec2.clone(pos),\r\n            client: vec2.fromValues(pos[0] + canvasPageCoordinates.left, pos[1] + canvasPageCoordinates.top),\r\n            page: vec2.fromValues(pos[0] + canvasPageCoordinates.left + window.pageXOffset, pos[1] + canvasPageCoordinates.top + window.pageYOffset)\r\n        };\r\n    }\r\n\r\n    public init(): void { }\r\n\r\n    /**\r\n     * Calculate the ray that is created by the mouse event and the camera.\r\n     * \r\n     * @param event \r\n     * @returns \r\n     */\r\n    public mouseEventToRay(event: MouseEvent): {\r\n        origin: vec3,\r\n        direction: vec3\r\n    } {\r\n        const rect = this._renderingEngine.canvas.getBoundingClientRect();\r\n        const camera = this._renderingEngine.cameraEngine.camera;\r\n        if (!camera) \r\n            throw new ShapeDiverViewerGeneralError('SceneTracingManager.mouseEventToRay: No camera is defined for this viewer.');\r\n\r\n        let _mouse_x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n        let _mouse_y = - ((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n\r\n        let origin = vec3.clone(camera.position);\r\n        if(camera instanceof OrthographicCamera) {\r\n            if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.TOP) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(_mouse_x*camera.right, _mouse_y*camera.top, 0))\r\n            } else if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(_mouse_x*camera.left, _mouse_y*camera.top, 0))\r\n            } else if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(0, _mouse_x*camera.left, _mouse_y*camera.top))\r\n            } else if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(0, _mouse_x*camera.right, _mouse_y*camera.top))\r\n            } else if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(_mouse_x*camera.right, 0, _mouse_y*camera.top))\r\n            } else if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.BACK) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(_mouse_x*camera.left, 0, _mouse_y*camera.top))\r\n            }\r\n        }\r\n\r\n        let direction = vec3.normalize(vec3.create(), vec3.sub(vec3.create(), camera.unproject(vec3.fromValues(_mouse_x, _mouse_y, 0.5)), origin));\r\n\r\n        return { origin, direction };\r\n    }\r\n\r\n    /**\r\n     * Create the ray that is created by the touch event and the camera.\r\n     * \r\n     * @param event \r\n     * @returns \r\n     */\r\n    public touchEventToRay(event: TouchEvent): {\r\n        origin: vec3,\r\n        direction: vec3\r\n    } {\r\n        if (event.touches.length > 1) \r\n            throw new ShapeDiverViewerGeneralError('SceneTracingManager.touchEventToRay: No touches in this event.');\r\n\r\n        const touch = event.changedTouches[0];\r\n\r\n        const rect = this._renderingEngine.canvas.getBoundingClientRect();\r\n        const camera = this._renderingEngine.cameraEngine.camera;\r\n        if (!camera) \r\n            throw new ShapeDiverViewerGeneralError('SceneTracingManager.touchEventToRay: No camera is defined for this viewer.');\r\n\r\n        let _mouse_x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;\r\n        let _mouse_y = - ((touch.clientY - rect.top) / rect.height) * 2 + 1;\r\n\r\n        let origin = vec3.clone(camera.position);\r\n        if(camera instanceof OrthographicCamera) {\r\n            if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.TOP) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(_mouse_x*camera.right, _mouse_y*camera.top, 0))\r\n            } else if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(_mouse_x*camera.left, _mouse_y*camera.top, 0))\r\n            } else if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(0, _mouse_x*camera.left, _mouse_y*camera.top))\r\n            } else if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(0, _mouse_x*camera.right, _mouse_y*camera.top))\r\n            } else if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(_mouse_x*camera.right, 0, _mouse_y*camera.top))\r\n            } else if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.BACK) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(_mouse_x*camera.left, 0, _mouse_y*camera.top))\r\n            }\r\n        }\r\n        let direction = vec3.normalize(vec3.create(), vec3.sub(vec3.create(), camera.unproject(vec3.fromValues(_mouse_x, _mouse_y, 0.5)), origin));\r\n\r\n        return { origin, direction };\r\n    }\r\n\r\n    /**\r\n     * Create the ray that is created by the touch event and the camera.\r\n     * \r\n     * @param event \r\n     * @returns \r\n     */\r\n    public touchToRay(event: Touch): {\r\n        origin: vec3,\r\n        direction: vec3\r\n    } {\r\n        const rect = this._renderingEngine.canvas.getBoundingClientRect();\r\n        const camera = this._renderingEngine.cameraEngine.camera;\r\n        if (!camera) \r\n            throw new ShapeDiverViewerGeneralError('SceneTracingManager.touchToRay: No camera is defined for this viewer.');\r\n\r\n        let _mouse_x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n        let _mouse_y = - ((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n\r\n        let origin = vec3.clone(camera.position);\r\n        if(camera instanceof OrthographicCamera) {\r\n            if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.TOP) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(_mouse_x*camera.right, _mouse_y*camera.top, 0))\r\n            } else if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.BOTTOM) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(_mouse_x*camera.left, _mouse_y*camera.top, 0))\r\n            } else if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.LEFT) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(0, _mouse_x*camera.left, _mouse_y*camera.top))\r\n            } else if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.RIGHT) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(0, _mouse_x*camera.right, _mouse_y*camera.top))\r\n            } else if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.FRONT) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(_mouse_x*camera.right, 0, _mouse_y*camera.top))\r\n            } else if(camera.direction == ORTHOGRAPHIC_CAMERA_DIRECTION.BACK) {\r\n                origin = vec3.add(vec3.create(), camera.position, vec3.fromValues(_mouse_x*camera.left, 0, _mouse_y*camera.top))\r\n            }\r\n        }\r\n        let direction = vec3.normalize(vec3.create(), vec3.sub(vec3.create(), camera.unproject(vec3.fromValues(_mouse_x, _mouse_y, 0.5)), origin));\r\n\r\n        return { origin, direction };\r\n    }\r\n\r\n    // #endregion Public Methods (3)\r\n}"]}},"error":null,"hash":"0cf89f49e8390b9370a22993ba3bbc9a","cacheData":{"env":{}}}