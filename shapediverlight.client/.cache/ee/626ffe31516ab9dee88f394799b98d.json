{"id":"node_modules/@shapediver/viewer.rendering-engine.intersection-engine/dist/implementation/IntersectionEngine.js","dependencies":[{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.intersection-engine\\dist\\implementation\\IntersectionEngine.js.map","includedInParent":true,"mtime":1706542085569},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.intersection-engine\\src\\implementation\\IntersectionEngine.ts","includedInParent":true,"mtime":1706542086061},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\package.json","includedInParent":true,"mtime":1706542184022},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.intersection-engine\\package.json","includedInParent":true,"mtime":1706542084963},{"name":"@shapediver/viewer.shared.types","loc":{"line":4,"column":38,"index":155},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.intersection-engine\\dist\\implementation\\IntersectionEngine.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.types\\dist\\index.js"},{"name":"gl-matrix","loc":{"line":5,"column":28,"index":220},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.intersection-engine\\dist\\implementation\\IntersectionEngine.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\gl-matrix\\esm\\index.js"},{"name":"@shapediver/viewer.shared.math","loc":{"line":6,"column":37,"index":272},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.intersection-engine\\dist\\implementation\\IntersectionEngine.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.math\\dist\\index.js"},{"name":"@shapediver/viewer.shared.node-tree","loc":{"line":7,"column":42,"index":350},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.intersection-engine\\dist\\implementation\\IntersectionEngine.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.node-tree\\dist\\index.js"},{"name":"@shapediver/viewer.rendering-engine.rendering-engine","loc":{"line":8,"column":59,"index":450},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.intersection-engine\\dist\\implementation\\IntersectionEngine.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.rendering-engine\\dist\\index.js"},{"name":"@shapediver/viewer.shared.services","loc":{"line":9,"column":41,"index":549},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.intersection-engine\\dist\\implementation\\IntersectionEngine.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\dist\\index.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IntersectionEngine = void 0;\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nconst viewer_shared_math_1 = require(\"@shapediver/viewer.shared.math\");\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst viewer_rendering_engine_rendering_engine_1 = require(\"@shapediver/viewer.rendering-engine.rendering-engine\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nclass IntersectionEngine {\r\n    // #endregion Properties (4)\r\n    // #region Constructors (1)\r\n    constructor() {\r\n        // #region Properties (4)\r\n        this._eventEngine = viewer_shared_services_1.EventEngine.instance;\r\n        this._tree = viewer_shared_node_tree_1.Tree.instance;\r\n        this._intersectNodes = [];\r\n        this.gatherNodes();\r\n        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.VIEWPORT.VIEWPORT_UPDATED, () => {\r\n            this.gatherNodes();\r\n        });\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Static Accessors (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Accessors (1)\r\n    // #region Public Methods (2)\r\n    intersect(ray, filterCriteria, intersectionOptions, root = this._tree.root, viewerID) {\r\n        let intersections = [];\r\n        const intersectNode = (node, visible, excludeViewports, restrictViewports) => {\r\n            if (visible === false)\r\n                return;\r\n            if (viewerID !== undefined) {\r\n                if (excludeViewports.includes(viewerID))\r\n                    return;\r\n                if (restrictViewports.length > 0 && !restrictViewports.includes(viewerID))\r\n                    return;\r\n            }\r\n            if (filterCriteria) {\r\n                for (let i = 0; i < filterCriteria.length; i++) {\r\n                    if (filterCriteria[i](node)) {\r\n                        const intersection = this.intersectNode(node, ray, intersectionOptions);\r\n                        if (intersection) {\r\n                            intersection.forEach(i => i.node = node);\r\n                            intersections = intersections.concat(intersection);\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                const intersection = this.intersectNode(node, ray);\r\n                if (intersection) {\r\n                    intersection.forEach(i => i.node = node);\r\n                    intersections = intersections.concat(intersection);\r\n                }\r\n            }\r\n            for (let i = 0; i < node.children.length; i++)\r\n                intersectNode(node.children[i], visible && node.children[i].visible, excludeViewports.concat(node.children[i].excludeViewports), restrictViewports.concat(node.children[i].restrictViewports));\r\n        };\r\n        for (let i = 0; i < this._intersectNodes.length; i++)\r\n            intersectNode(this._intersectNodes[i].node, this._intersectNodes[i].visible, this._intersectNodes[i].excludeViewports, this._intersectNodes[i].restrictViewports);\r\n        intersections.sort((a, b) => a.distance - b.distance);\r\n        return intersections;\r\n    }\r\n    intersectNode(node, rayIn, intersectionOptions) {\r\n        if (node.visible === false)\r\n            return;\r\n        const inverseMatrix = gl_matrix_1.mat4.invert(gl_matrix_1.mat4.create(), node.worldMatrix);\r\n        const ray = {\r\n            origin: gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), rayIn.origin, inverseMatrix),\r\n            direction: gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(inverseMatrix[0] * rayIn.direction[0] + inverseMatrix[4] * rayIn.direction[1] + inverseMatrix[8] * rayIn.direction[2], inverseMatrix[1] * rayIn.direction[0] + inverseMatrix[5] * rayIn.direction[1] + inverseMatrix[9] * rayIn.direction[2], inverseMatrix[2] * rayIn.direction[0] + inverseMatrix[6] * rayIn.direction[1] + inverseMatrix[10] * rayIn.direction[2]))\r\n        };\r\n        let geometryData;\r\n        for (let i = 0; i < node.data.length; i++) {\r\n            if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {\r\n                geometryData = node.data[i];\r\n                break;\r\n            }\r\n        }\r\n        // quick out if the material does not fit the intersection options\r\n        if (geometryData && intersectionOptions) {\r\n            let materialData = null;\r\n            if (geometryData.effectMaterials.length > 0) {\r\n                materialData = geometryData.effectMaterials[geometryData.effectMaterials.length - 1].material;\r\n            }\r\n            else if (intersectionOptions.rendererType === viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE.ATTRIBUTES) {\r\n                materialData = geometryData.attributeMaterial;\r\n            }\r\n            else {\r\n                materialData = geometryData.material;\r\n            }\r\n            // if opacity <= intersectionOptions.opacity\r\n            if (materialData && materialData.opacity <= intersectionOptions.opacity)\r\n                return;\r\n        }\r\n        if (!geometryData) {\r\n            let intersections = [];\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                let intersection = this.intersectNode(node.children[i], rayIn, intersectionOptions);\r\n                if (intersection)\r\n                    intersections = intersections.concat(intersection);\r\n            }\r\n            if (intersections.length > 0) {\r\n                intersections.sort((a, b) => a.distance - b.distance);\r\n                return intersections;\r\n            }\r\n            return;\r\n        }\r\n        else if (geometryData.mode === viewer_shared_types_1.PRIMITIVE_MODE.LINES) {\r\n            // if (node.boundingBox.boundingSphere.intersects(ray.origin, ray.direction) === false) return;\r\n            if (node.boundingBox.intersects(rayIn.origin, rayIn.direction) === false)\r\n                return;\r\n            const index = geometryData.primitive.indices;\r\n            const position = geometryData.primitive.attributes['POSITION'];\r\n            const radius = 0.1;\r\n            let intersections = [];\r\n            if (index !== null) {\r\n                // indexed buffer geometry\r\n                for (let i = 0, il = +index.count; i < il; i += 2) {\r\n                    const a = index.array[(i) * index.itemSize];\r\n                    const b = index.array[(i + 1) * index.itemSize];\r\n                    let intersection = this.checkLineIntersection(node, ray, radius, gl_matrix_1.vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]), gl_matrix_1.vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]));\r\n                    if (intersection)\r\n                        intersections.push(Object.assign(intersection, { geometryData }));\r\n                }\r\n            }\r\n            else if (position !== undefined) {\r\n                // non-indexed buffer geometry\r\n                for (let i = 0, il = +position.count; i < il; i += 2) {\r\n                    const a = i;\r\n                    const b = i + 1;\r\n                    let intersection = this.checkLineIntersection(node, ray, radius, gl_matrix_1.vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]), gl_matrix_1.vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]));\r\n                    if (intersection)\r\n                        intersections.push(Object.assign(intersection, { geometryData }));\r\n                }\r\n            }\r\n            intersections.sort((a, b) => a.distance - b.distance);\r\n            intersections.forEach(i => i.point = gl_matrix_1.vec3.transformMat4(i.point, i.point, node.worldMatrix));\r\n            return intersections;\r\n        }\r\n        else if (geometryData.mode === viewer_shared_types_1.PRIMITIVE_MODE.LINE_LOOP || geometryData.mode === viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP) {\r\n            // if (node.boundingBox.boundingSphere.intersects(ray.origin, ray.direction) === false) return;\r\n            if (node.boundingBox.intersects(rayIn.origin, rayIn.direction) === false)\r\n                return;\r\n            const index = geometryData.primitive.indices;\r\n            const position = geometryData.primitive.attributes['POSITION'];\r\n            const radius = 0.1;\r\n            let intersections = [];\r\n            if (index !== null) {\r\n                // indexed buffer geometry\r\n                for (let i = 0, il = +index.count - 1; i < il; i++) {\r\n                    const a = index.array[(i) * index.itemSize];\r\n                    const b = index.array[(i + 1) * index.itemSize];\r\n                    let intersection = this.checkLineIntersection(node, ray, radius, gl_matrix_1.vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]), gl_matrix_1.vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]));\r\n                    if (intersection)\r\n                        intersections.push(Object.assign(intersection, { geometryData }));\r\n                }\r\n            }\r\n            else if (position !== undefined) {\r\n                // non-indexed buffer geometry\r\n                for (let i = 0, il = +position.count; i < il; i += 2) {\r\n                    const a = i;\r\n                    const b = i + 1;\r\n                    let intersection = this.checkLineIntersection(node, ray, radius, gl_matrix_1.vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]), gl_matrix_1.vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]));\r\n                    if (intersection)\r\n                        intersections.push(Object.assign(intersection, { geometryData }));\r\n                }\r\n            }\r\n            intersections.sort((a, b) => a.distance - b.distance);\r\n            intersections.forEach(i => i.point = gl_matrix_1.vec3.transformMat4(i.point, i.point, node.worldMatrix));\r\n            return intersections;\r\n        }\r\n        else if (geometryData.mode === viewer_shared_types_1.PRIMITIVE_MODE.POINTS) {\r\n            const position = geometryData.primitive.attributes['POSITION'];\r\n            const radius = 0.1;\r\n            let intersections = [];\r\n            if (position !== undefined) {\r\n                // non-indexed buffer geometry\r\n                for (let i = 0, il = +position.count; i < il; i++) {\r\n                    let intersection = this.checkPointIntersection(node, ray, radius, gl_matrix_1.vec3.fromValues(position.array[i * position.itemSize], position.array[i * position.itemSize + 1], position.array[i * position.itemSize + 2]));\r\n                    if (intersection)\r\n                        intersections.push(Object.assign(intersection, { geometryData }));\r\n                }\r\n            }\r\n            intersections.sort((a, b) => a.distance - b.distance);\r\n            intersections.forEach(i => i.point = gl_matrix_1.vec3.transformMat4(i.point, i.point, node.worldMatrix));\r\n            return intersections;\r\n        }\r\n        else {\r\n            // Here, Vector is a vector in Rn, not a dynamic array.\r\n            let v = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), node.boundingBox.boundingSphere.center, rayIn.origin);\r\n            let dotProd = gl_matrix_1.vec3.dot(v, rayIn.direction);\r\n            dotProd = Math.max(dotProd, 0.0); // if dotProd is negative, the closest point is in the opposite direction to d.\r\n            let e = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), rayIn.origin, gl_matrix_1.vec3.scale(gl_matrix_1.vec3.create(), rayIn.direction, dotProd));\r\n            let squaredDistance = gl_matrix_1.vec3.squaredDistance(e, node.boundingBox.boundingSphere.center);\r\n            if (squaredDistance > node.boundingBox.boundingSphere.radius * node.boundingBox.boundingSphere.radius)\r\n                return;\r\n            // if (node.boundingBox.boundingSphere.intersects(ray.origin, ray.direction) === false) return;\r\n            if (node.boundingBox.intersects(rayIn.origin, rayIn.direction) === false)\r\n                return;\r\n            const material = geometryData.material;\r\n            const index = geometryData.primitive.indices;\r\n            const position = geometryData.primitive.attributes['POSITION'];\r\n            let intersections = [];\r\n            if (index !== null) {\r\n                // indexed buffer geometry\r\n                for (let i = 0, il = +index.count; i < il; i += 3) {\r\n                    const a = index.array[(i) * index.itemSize];\r\n                    const b = index.array[(i + 1) * index.itemSize];\r\n                    const c = index.array[(i + 2) * index.itemSize];\r\n                    let intersection = this.checkIntersection(node, material, ray, gl_matrix_1.vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]), gl_matrix_1.vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]), gl_matrix_1.vec3.fromValues(position.array[c * position.itemSize], position.array[c * position.itemSize + 1], position.array[c * position.itemSize + 2]));\r\n                    if (intersection)\r\n                        intersections.push(Object.assign(intersection, { geometryData }));\r\n                }\r\n            }\r\n            else if (position !== undefined) {\r\n                // non-indexed buffer geometry\r\n                for (let i = 0, il = +position.count; i < il; i += 3) {\r\n                    const a = i;\r\n                    const b = i + 1;\r\n                    const c = i + 2;\r\n                    let intersection = this.checkIntersection(node, material, ray, gl_matrix_1.vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]), gl_matrix_1.vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]), gl_matrix_1.vec3.fromValues(position.array[c * position.itemSize], position.array[c * position.itemSize + 1], position.array[c * position.itemSize + 2]));\r\n                    if (intersection)\r\n                        intersections.push(Object.assign(intersection, { geometryData }));\r\n                }\r\n            }\r\n            intersections.sort((a, b) => a.distance - b.distance);\r\n            intersections.forEach(i => i.point = gl_matrix_1.vec3.transformMat4(i.point, i.point, node.worldMatrix));\r\n            return intersections;\r\n        }\r\n    }\r\n    // #endregion Public Methods (2)\r\n    // #region Private Methods (4)\r\n    checkIntersection(node, material, ray, pA, pB, pC) {\r\n        let point;\r\n        if (material && material.side === viewer_shared_types_1.MATERIAL_SIDE.BACK) {\r\n            const triangle = new viewer_shared_math_1.Triangle(pC, pB, pA);\r\n            point = triangle.intersect(ray.origin, ray.direction);\r\n        }\r\n        else {\r\n            const triangle = new viewer_shared_math_1.Triangle(pA, pB, pC);\r\n            point = triangle.intersect(ray.origin, ray.direction);\r\n        }\r\n        if (point === null)\r\n            return;\r\n        const distance = gl_matrix_1.vec3.distance(ray.origin, point);\r\n        return {\r\n            distance: distance,\r\n            point: gl_matrix_1.vec3.clone(point),\r\n            node\r\n        };\r\n    }\r\n    checkLineIntersection(node, ray, radius, pA, pB) {\r\n        const direction = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), pB, pA);\r\n        const lineLength = gl_matrix_1.vec3.length(direction);\r\n        const lineRay = {\r\n            origin: pA,\r\n            direction: gl_matrix_1.vec3.divide(gl_matrix_1.vec3.create(), direction, gl_matrix_1.vec3.fromValues(lineLength, lineLength, lineLength))\r\n        };\r\n        const planeNormal = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), ray.direction, lineRay.direction);\r\n        const Na = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), ray.direction, planeNormal));\r\n        const Nb = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), lineRay.direction, planeNormal));\r\n        const da = gl_matrix_1.vec3.dot(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), pA, ray.origin), Nb) / gl_matrix_1.vec3.dot(ray.direction, Nb);\r\n        const db = gl_matrix_1.vec3.dot(gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), ray.origin, pA), Na) / gl_matrix_1.vec3.dot(lineRay.direction, Na);\r\n        let pointA = gl_matrix_1.vec3.create();\r\n        if (da < 0) {\r\n            gl_matrix_1.vec3.copy(pointA, ray.origin);\r\n        }\r\n        else {\r\n            pointA = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), ray.origin, gl_matrix_1.vec3.mul(gl_matrix_1.vec3.create(), ray.direction, gl_matrix_1.vec3.fromValues(da, da, da)));\r\n        }\r\n        let pointB = gl_matrix_1.vec3.create();\r\n        if (db < 0) {\r\n            gl_matrix_1.vec3.copy(pointB, pA);\r\n        }\r\n        else if (db < lineLength) {\r\n            pointB = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), pA, gl_matrix_1.vec3.mul(gl_matrix_1.vec3.create(), lineRay.direction, gl_matrix_1.vec3.fromValues(db, db, db)));\r\n        }\r\n        else {\r\n            gl_matrix_1.vec3.copy(pointB, pB);\r\n        }\r\n        const distance = gl_matrix_1.vec3.distance(pointA, pointB);\r\n        if (distance < radius) {\r\n            return {\r\n                distance: distance,\r\n                point: gl_matrix_1.vec3.clone(pointB),\r\n                node\r\n            };\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    checkPointIntersection(node, ray, radius, p) {\r\n        const closestPoint = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), p, ray.origin);\r\n        const directionDistance = gl_matrix_1.vec3.dot(closestPoint, ray.direction);\r\n        if (directionDistance < 0) {\r\n            gl_matrix_1.vec3.copy(closestPoint, ray.origin);\r\n        }\r\n        else {\r\n            gl_matrix_1.vec3.multiply(closestPoint, gl_matrix_1.vec3.copy(closestPoint, ray.direction), gl_matrix_1.vec3.fromValues(directionDistance, directionDistance, directionDistance));\r\n            gl_matrix_1.vec3.add(closestPoint, closestPoint, ray.origin);\r\n        }\r\n        const distance = gl_matrix_1.vec3.distance(closestPoint, p);\r\n        if (distance < radius) {\r\n            return {\r\n                distance: distance,\r\n                point: gl_matrix_1.vec3.clone(closestPoint),\r\n                node\r\n            };\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    gatherNodes() {\r\n        this._intersectNodes = [];\r\n        this._tree.root.traverse(node => {\r\n            if (node.visible === false)\r\n                return;\r\n            for (let i = 0; i < node.data.length; i++) {\r\n                if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {\r\n                    let tempNode = node;\r\n                    let visible = true, restrictViewports = [], excludeViewports = [];\r\n                    while (tempNode.parent) {\r\n                        visible = tempNode.visible && visible;\r\n                        restrictViewports = restrictViewports.concat(tempNode.restrictViewports);\r\n                        excludeViewports = excludeViewports.concat(tempNode.excludeViewports);\r\n                        tempNode = tempNode.parent;\r\n                    }\r\n                    this._intersectNodes.push({\r\n                        node,\r\n                        visible,\r\n                        restrictViewports: [...new Set(restrictViewports)],\r\n                        excludeViewports: [...new Set(excludeViewports)]\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.IntersectionEngine = IntersectionEngine;\r\n"},"sourceMaps":{"js":{"version":3,"file":"IntersectionEngine.js","sourceRoot":"","sources":["../../src/implementation/IntersectionEngine.ts"],"names":[],"mappings":";;;AAAA,yEAAqH;AACrH,yCAAuC;AACvC,uEAA0D;AAC1D,iFAAuF;AACvF,mHAAqF;AAKrF,+EAA4E;AAE5E,MAAa,kBAAkB;IAe3B,4BAA4B;IAE5B,2BAA2B;IAE3B;QAlBA,yBAAyB;QAER,iBAAY,GAAgB,oCAAW,CAAC,QAAQ,CAAC;QACjD,UAAK,GAAU,8BAAI,CAAC,QAAQ,CAAC;QAItC,oBAAe,GAKjB,EAAE,CAAC;QAOL,IAAI,CAAC,WAAW,EAAE,CAAC;QACnB,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,kCAAS,CAAC,QAAQ,CAAC,gBAAgB,EAAE,GAAG,EAAE;YACpE,IAAI,CAAC,WAAW,EAAE,CAAC;QACvB,CAAC,CAAC,CAAA;IACN,CAAC;IAED,8BAA8B;IAE9B,sCAAsC;IAE/B,MAAM,KAAK,QAAQ;QACtB,OAAO,IAAI,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,SAAS,GAAG,IAAI,IAAI,EAAE,CAAC,CAAC;IAC3D,CAAC;IAED,yCAAyC;IAEzC,6BAA6B;IAGtB,SAAS,CACZ,GAAS,EACT,cAAsC,EACtC,mBAAsE,EACtE,OAAkB,IAAI,CAAC,KAAK,CAAC,IAAI,EACjC,QAAiB;QAEjB,IAAI,aAAa,GAAoB,EAAE,CAAC;QACxC,MAAM,aAAa,GAAG,CAAC,IAAe,EAAE,OAAgB,EAAE,gBAA0B,EAAE,iBAA2B,EAAE,EAAE;YACjH,IAAG,OAAO,KAAK,KAAK;gBAAE,OAAO;YAE7B,IAAG,QAAQ,KAAK,SAAS,EAAE;gBACvB,IAAG,gBAAgB,CAAC,QAAQ,CAAC,QAAQ,CAAC;oBAAE,OAAO;gBAC/C,IAAG,iBAAiB,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,QAAQ,CAAC;oBAAE,OAAO;aACpF;YAED,IAAG,cAAc,EAAE;gBACf,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBAC5C,IAAI,cAAc,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;wBACzB,MAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,GAAG,EAAE,mBAAmB,CAAC,CAAA;wBACvE,IAAI,YAAY,EAAE;4BACd,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC;4BACzC,aAAa,GAAG,aAAa,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;yBACtD;wBACD,MAAM;qBACT;iBACJ;aACJ;iBAAM;gBACH,MAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,GAAG,CAAC,CAAA;gBAClD,IAAI,YAAY,EAAE;oBACd,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC;oBACzC,aAAa,GAAG,aAAa,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;iBACtD;aACJ;YAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE;gBACzC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,EAAE,iBAAiB,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,iBAAiB,CAAC,CAAC,CAAA;QACtM,CAAC,CAAA;QACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC,EAAE;YAC/C,aAAa,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,gBAAgB,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,iBAAiB,CAAC,CAAA;QAEtK,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC;QACtD,OAAO,aAAa,CAAC;IACzB,CAAC;IAEM,aAAa,CAAC,IAAe,EAAE,KAAW,EAAE,mBAAsE;QACrH,IAAI,IAAI,CAAC,OAAO,KAAK,KAAK;YAAE,OAAO;QAEnC,MAAM,aAAa,GAAG,gBAAI,CAAC,MAAM,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;QACnE,MAAM,GAAG,GAAG;YACR,MAAM,EAAE,gBAAI,CAAC,aAAa,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,KAAK,CAAC,MAAM,EAAE,aAAa,CAAC;YACtE,SAAS,EAAE,gBAAI,CAAC,SAAS,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,gBAAI,CAAC,UAAU,CACpD,aAAa,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,EACrH,aAAa,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,EACrH,aAAa,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CACzH,CAAC;SACL,CAAC;QAEF,IAAI,YAAsC,CAAC;QAC3C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACvC,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,YAAY,kCAAY,EAAE;gBACtC,YAAY,GAAiB,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC1C,MAAM;aACT;SACJ;QAED,kEAAkE;QAClE,IAAI,YAAY,IAAI,mBAAmB,EAAE;YACrC,IAAI,YAAY,GAAiC,IAAI,CAAC;YACtD,IAAI,YAAY,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE;gBACzC,YAAY,GAAG,YAAY,CAAC,eAAe,CAAC,YAAY,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAA;aAChG;iBAAM,IAAI,mBAAmB,CAAC,YAAY,KAAK,wDAAa,CAAC,UAAU,EAAE;gBACtE,YAAY,GAAG,YAAY,CAAC,iBAAiB,CAAC;aACjD;iBAAM;gBACH,YAAY,GAAG,YAAY,CAAC,QAAQ,CAAC;aACxC;YAED,4CAA4C;YAC5C,IAAI,YAAY,IAAI,YAAY,CAAC,OAAO,IAAI,mBAAmB,CAAC,OAAO;gBACnE,OAAO;SACd;QAED,IAAI,CAAC,YAAY,EAAE;YACf,IAAI,aAAa,GAAoB,EAAE,CAAC;YACxC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC3C,IAAI,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,mBAAmB,CAAC,CAAC;gBACpF,IAAI,YAAY;oBACZ,aAAa,GAAG,aAAa,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;aAC1D;YACD,IAAI,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC1B,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC;gBACtD,OAAO,aAAa,CAAC;aACxB;YACD,OAAO;SACV;aAAM,IAAI,YAAY,CAAC,IAAI,KAAK,oCAAc,CAAC,KAAK,EAAE;YACnD,+FAA+F;YAC/F,IAAI,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,SAAS,CAAC,KAAK,KAAK;gBAAE,OAAO;YAEjF,MAAM,KAAK,GAAG,YAAY,CAAC,SAAS,CAAC,OAAO,CAAC;YAC7C,MAAM,QAAQ,GAAG,YAAY,CAAC,SAAS,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;YAC/D,MAAM,MAAM,GAAG,GAAG,CAAC;YACnB,IAAI,aAAa,GAAoB,EAAE,CAAC;YACxC,IAAI,KAAK,KAAK,IAAI,EAAE;gBAChB,0BAA0B;gBAC1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,EAAE;oBAC/C,MAAM,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;oBAC5C,MAAM,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;oBAEhD,IAAI,YAAY,GAAG,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,GAAG,EAAE,MAAM,EAC3D,gBAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,EAC5I,gBAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;oBAClJ,IAAI,YAAY;wBAAE,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,YAAY,EAAE,EAAE,YAAY,EAAE,CAAC,CAAC,CAAA;iBACtF;aACJ;iBAAM,IAAI,QAAQ,KAAK,SAAS,EAAE;gBAC/B,8BAA8B;gBAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,EAAE;oBAClD,MAAM,CAAC,GAAG,CAAC,CAAC;oBACZ,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBAChB,IAAI,YAAY,GAAG,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,GAAG,EAAE,MAAM,EAC3D,gBAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,EAC5I,gBAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC9I,IAAI,YAAY;wBAAE,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,YAAY,EAAE,EAAE,YAAY,EAAE,CAAC,CAAC,CAAA;iBAC1F;aACJ;YAED,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC;YACtD,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,GAAG,gBAAI,CAAC,aAAa,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;YAC7F,OAAO,aAAa,CAAC;SACxB;aAAM,IAAI,YAAY,CAAC,IAAI,KAAK,oCAAc,CAAC,SAAS,IAAI,YAAY,CAAC,IAAI,KAAK,oCAAc,CAAC,UAAU,EAAE;YAC1G,+FAA+F;YAC/F,IAAI,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,SAAS,CAAC,KAAK,KAAK;gBAAE,OAAO;YAEjF,MAAM,KAAK,GAAG,YAAY,CAAC,SAAS,CAAC,OAAO,CAAC;YAC7C,MAAM,QAAQ,GAAG,YAAY,CAAC,SAAS,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;YAC/D,MAAM,MAAM,GAAG,GAAG,CAAC;YACnB,IAAI,aAAa,GAAoB,EAAE,CAAC;YACxC,IAAI,KAAK,KAAK,IAAI,EAAE;gBAChB,0BAA0B;gBAC1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;oBAChD,MAAM,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;oBAC5C,MAAM,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;oBAEhD,IAAI,YAAY,GAAG,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,GAAG,EAAE,MAAM,EAC3D,gBAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,EAC5I,gBAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;oBAClJ,IAAI,YAAY;wBAAE,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,YAAY,EAAE,EAAE,YAAY,EAAE,CAAC,CAAC,CAAA;iBACtF;aACJ;iBAAM,IAAI,QAAQ,KAAK,SAAS,EAAE;gBAC/B,8BAA8B;gBAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,EAAE;oBAClD,MAAM,CAAC,GAAG,CAAC,CAAC;oBACZ,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBAChB,IAAI,YAAY,GAAG,IAAI,CAAC,qBAAqB,CAAC,IAAI,EAAE,GAAG,EAAE,MAAM,EAC3D,gBAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,EAC5I,gBAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC9I,IAAI,YAAY;wBAAE,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,YAAY,EAAE,EAAE,YAAY,EAAE,CAAC,CAAC,CAAA;iBAC1F;aACJ;YAED,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC;YACtD,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,GAAG,gBAAI,CAAC,aAAa,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;YAC7F,OAAO,aAAa,CAAC;SACxB;aAAM,IAAI,YAAY,CAAC,IAAI,KAAK,oCAAc,CAAC,MAAM,EAAE;YACpD,MAAM,QAAQ,GAAG,YAAY,CAAC,SAAS,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;YAC/D,MAAM,MAAM,GAAG,GAAG,CAAC;YACnB,IAAI,aAAa,GAAoB,EAAE,CAAC;YACxC,IAAI,QAAQ,KAAK,SAAS,EAAE;gBACxB,8BAA8B;gBAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;oBAC/C,IAAI,YAAY,GAAG,IAAI,CAAC,sBAAsB,CAAC,IAAI,EAAE,GAAG,EAAE,MAAM,EAC5D,gBAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;oBAClJ,IAAI,YAAY;wBAAE,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,YAAY,EAAE,EAAE,YAAY,EAAE,CAAC,CAAC,CAAA;iBACtF;aACJ;YAED,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC;YACtD,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,GAAG,gBAAI,CAAC,aAAa,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;YAC7F,OAAO,aAAa,CAAC;SACxB;aAAM;YACH,uDAAuD;YACvD,IAAK,CAAC,GAAG,gBAAI,CAAC,GAAG,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,MAAM,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;YACvF,IAAI,OAAO,GAAG,gBAAI,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC;YAC3C,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,CAAC,+EAA+E;YACjH,IAAI,CAAC,GAAG,gBAAI,CAAC,GAAG,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,KAAK,CAAC,MAAM,EAAE,gBAAI,CAAC,KAAK,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,KAAK,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC;YAEnG,IAAI,eAAe,GAAG,gBAAI,CAAC,eAAe,CAAC,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;YACtF,IAAI,eAAe,GAAG,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,MAAM;gBAAE,OAAO;YAE9G,+FAA+F;YAC/F,IAAI,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,SAAS,CAAC,KAAK,KAAK;gBAAE,OAAO;YAEjF,MAAM,QAAQ,GAAG,YAAY,CAAC,QAAQ,CAAC;YACvC,MAAM,KAAK,GAAG,YAAY,CAAC,SAAS,CAAC,OAAO,CAAC;YAC7C,MAAM,QAAQ,GAAG,YAAY,CAAC,SAAS,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;YAE/D,IAAI,aAAa,GAAoB,EAAE,CAAC;YAExC,IAAI,KAAK,KAAK,IAAI,EAAE;gBAChB,0BAA0B;gBAC1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,EAAE;oBAC/C,MAAM,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;oBAC5C,MAAM,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;oBAChD,MAAM,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;oBAEhD,IAAI,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,QAAQ,EAAE,GAAG,EACzD,gBAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,EAC5I,gBAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,EAC5I,gBAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;oBAClJ,IAAI,YAAY;wBAAE,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,YAAY,EAAE,EAAE,YAAY,EAAE,CAAC,CAAC,CAAA;iBACtF;aACJ;iBAAM,IAAI,QAAQ,KAAK,SAAS,EAAE;gBAC/B,8BAA8B;gBAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,EAAE;oBAClD,MAAM,CAAC,GAAG,CAAC,CAAC;oBACZ,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBAChB,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBAChB,IAAI,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,QAAQ,EAAE,GAAG,EACzD,gBAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,EAC5I,gBAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,EAC5I,gBAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,GAAG,QAAQ,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;oBAClJ,IAAI,YAAY;wBAAE,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,YAAY,EAAE,EAAE,YAAY,EAAE,CAAC,CAAC,CAAA;iBACtF;aACJ;YAED,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC;YACtD,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,GAAG,gBAAI,CAAC,aAAa,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;YAC7F,OAAO,aAAa,CAAC;SACxB;IACL,CAAC;IAED,gCAAgC;IAEhC,8BAA8B;IAEtB,iBAAiB,CAAC,IAAe,EAAE,QAAsC,EAAE,GAAS,EAAE,EAAQ,EAAE,EAAQ,EAAE,EAAQ;QACtH,IAAI,KAAkB,CAAC;QAEvB,IAAI,QAAQ,IAAI,QAAQ,CAAC,IAAI,KAAK,mCAAa,CAAC,IAAI,EAAE;YAClD,MAAM,QAAQ,GAAG,IAAI,6BAAQ,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;YAC1C,KAAK,GAAG,QAAQ,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,SAAS,CAAC,CAAC;SACzD;aAAM;YACH,MAAM,QAAQ,GAAG,IAAI,6BAAQ,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;YAC1C,KAAK,GAAG,QAAQ,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,SAAS,CAAC,CAAC;SACzD;QAED,IAAI,KAAK,KAAK,IAAI;YAAE,OAAO;QAE3B,MAAM,QAAQ,GAAG,gBAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QAClD,OAAO;YACH,QAAQ,EAAE,QAAQ;YAClB,KAAK,EAAE,gBAAI,CAAC,KAAK,CAAC,KAAK,CAAC;YACxB,IAAI;SACP,CAAC;IACN,CAAC;IAEO,qBAAqB,CAAC,IAAe,EAAE,GAAS,EAAE,MAAc,EAAE,EAAQ,EAAE,EAAQ;QACxF,MAAM,SAAS,GAAG,gBAAI,CAAC,GAAG,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;QAClD,MAAM,UAAU,GAAG,gBAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QAC1C,MAAM,OAAO,GAAG;YACZ,MAAM,EAAE,EAAE;YACV,SAAS,EAAE,gBAAI,CAAC,MAAM,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,SAAS,EAAE,gBAAI,CAAC,UAAU,CAAC,UAAU,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;SACxG,CAAC;QACF,MAAM,WAAW,GAAG,gBAAI,CAAC,KAAK,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC;QAEhF,MAAM,EAAE,GAAG,gBAAI,CAAC,SAAS,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,gBAAI,CAAC,KAAK,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,GAAG,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC,CAAC;QAChG,MAAM,EAAE,GAAG,gBAAI,CAAC,SAAS,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,gBAAI,CAAC,KAAK,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,OAAO,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC,CAAC;QAEpG,MAAM,EAAE,GAAG,gBAAI,CAAC,GAAG,CAAC,gBAAI,CAAC,GAAG,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC,GAAG,gBAAI,CAAC,GAAG,CAAC,GAAG,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;QAC/F,MAAM,EAAE,GAAG,gBAAI,CAAC,GAAG,CAAC,gBAAI,CAAC,GAAG,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,GAAG,gBAAI,CAAC,GAAG,CAAC,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;QAEnG,IAAI,MAAM,GAAS,gBAAI,CAAC,MAAM,EAAE,CAAC;QACjC,IAAI,EAAE,GAAG,CAAC,EAAE;YACR,gBAAI,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;SACjC;aAAM;YACH,MAAM,GAAG,gBAAI,CAAC,GAAG,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,GAAG,CAAC,MAAM,EAAE,gBAAI,CAAC,GAAG,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,GAAG,CAAC,SAAS,EAAE,gBAAI,CAAC,UAAU,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;SACrH;QAED,IAAI,MAAM,GAAS,gBAAI,CAAC,MAAM,EAAE,CAAC;QACjC,IAAI,EAAE,GAAG,CAAC,EAAE;YACR,gBAAI,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;SACzB;aAAM,IAAI,EAAE,GAAG,UAAU,EAAE;YACxB,MAAM,GAAG,gBAAI,CAAC,GAAG,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE,gBAAI,CAAC,GAAG,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,OAAO,CAAC,SAAS,EAAE,gBAAI,CAAC,UAAU,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;SACjH;aAAM;YACH,gBAAI,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;SACzB;QAED,MAAM,QAAQ,GAAG,gBAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;QAC/C,IAAI,QAAQ,GAAG,MAAM,EAAE;YACnB,OAAO;gBACH,QAAQ,EAAE,QAAQ;gBAClB,KAAK,EAAE,gBAAI,CAAC,KAAK,CAAC,MAAM,CAAC;gBACzB,IAAI;aACP,CAAA;SACJ;aAAM;YACH,OAAO;SACV;IACL,CAAC;IAEO,sBAAsB,CAAC,IAAe,EAAE,GAAS,EAAE,MAAc,EAAE,CAAO;QAC9E,MAAM,YAAY,GAAG,gBAAI,CAAC,GAAG,CAAC,gBAAI,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;QAC5D,MAAM,iBAAiB,GAAG,gBAAI,CAAC,GAAG,CAAC,YAAY,EAAE,GAAG,CAAC,SAAS,CAAC,CAAC;QAEhE,IAAI,iBAAiB,GAAG,CAAC,EAAE;YACvB,gBAAI,CAAC,IAAI,CAAC,YAAY,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;SACvC;aAAM;YACH,gBAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,gBAAI,CAAC,IAAI,CAAC,YAAY,EAAE,GAAG,CAAC,SAAS,CAAC,EAAE,gBAAI,CAAC,UAAU,CAAC,iBAAiB,EAAE,iBAAiB,EAAE,iBAAiB,CAAC,CAAC,CAAC;YAC9I,gBAAI,CAAC,GAAG,CAAC,YAAY,EAAE,YAAY,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;SACpD;QAED,MAAM,QAAQ,GAAG,gBAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC;QAChD,IAAI,QAAQ,GAAG,MAAM,EAAE;YACnB,OAAO;gBACH,QAAQ,EAAE,QAAQ;gBAClB,KAAK,EAAE,gBAAI,CAAC,KAAK,CAAC,YAAY,CAAC;gBAC/B,IAAI;aACP,CAAA;SACJ;aAAM;YACH,OAAO;SACV;IACL,CAAC;IAEO,WAAW;QACf,IAAI,CAAC,eAAe,GAAG,EAAE,CAAC;QAC1B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;YAC5B,IAAI,IAAI,CAAC,OAAO,KAAK,KAAK;gBAAE,OAAO;YAEnC,KAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACtC,IAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,YAAY,kCAAY,EAAE;oBAErC,IAAI,QAAQ,GAAG,IAAI,CAAC;oBACpB,IAAI,OAAO,GAAG,IAAI,EAAE,iBAAiB,GAAa,EAAE,EAAE,gBAAgB,GAAa,EAAE,CAAC;oBACtF,OAAM,QAAQ,CAAC,MAAM,EAAE;wBACnB,OAAO,GAAG,QAAQ,CAAC,OAAO,IAAI,OAAO,CAAC;wBACtC,iBAAiB,GAAG,iBAAiB,CAAC,MAAM,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAA;wBACxE,gBAAgB,GAAG,gBAAgB,CAAC,MAAM,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAA;wBACrE,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC;qBAC9B;oBAED,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC;wBACtB,IAAI;wBACJ,OAAO;wBACP,iBAAiB,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,iBAAiB,CAAC,CAAC;wBAClD,gBAAgB,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,gBAAgB,CAAC,CAAC;qBACnD,CAAC,CAAA;iBAEL;aACJ;QACL,CAAC,CAAC,CAAA;IACN,CAAC;CAGJ;AAtYD,gDAsYC","sourcesContent":["import { GeometryData, IMaterialAbstractData, MATERIAL_SIDE, PRIMITIVE_MODE } from \"@shapediver/viewer.shared.types\";\r\nimport { mat4, vec3 } from \"gl-matrix\";\r\nimport { Triangle } from \"@shapediver/viewer.shared.math\";\r\nimport { ITree, ITreeNode, Tree, TreeNode } from \"@shapediver/viewer.shared.node-tree\";\r\nimport { RENDERER_TYPE } from \"@shapediver/viewer.rendering-engine.rendering-engine\";\r\nimport { IIntersectionFilter } from \"../interfaces/IIntersectionFilter\";\r\nimport { IRay } from \"../interfaces/IRay\";\r\nimport { IIntersection } from \"../interfaces/IIntersection\";\r\nimport { IIntersectionEngine } from \"../interfaces/IIntersectionEngine\";\r\nimport { EventEngine, EVENTTYPE } from \"@shapediver/viewer.shared.services\";\r\n\r\nexport class IntersectionEngine implements IIntersectionEngine {\r\n    // #region Properties (4)\r\n\r\n    private readonly _eventEngine: EventEngine = EventEngine.instance;\r\n    private readonly _tree: ITree = Tree.instance;\r\n\r\n    private static _instance: IntersectionEngine;\r\n\r\n    private _intersectNodes: {\r\n        node: ITreeNode,\r\n        visible: boolean,\r\n        excludeViewports: string[],\r\n        restrictViewports: string[],\r\n    }[] = [];\r\n\r\n    // #endregion Properties (4)\r\n\r\n    // #region Constructors (1)\r\n\r\n    private constructor() {\r\n        this.gatherNodes();\r\n        this._eventEngine.addListener(EVENTTYPE.VIEWPORT.VIEWPORT_UPDATED, () => {\r\n            this.gatherNodes();\r\n        })\r\n    }\r\n\r\n    // #endregion Constructors (1)\r\n\r\n    // #region Public Static Accessors (1)\r\n\r\n    public static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n\r\n    // #endregion Public Static Accessors (1)\r\n\r\n    // #region Public Methods (2)\r\n\r\n\r\n    public intersect(\r\n        ray: IRay, \r\n        filterCriteria?: IIntersectionFilter[], \r\n        intersectionOptions?: { opacity: number, rendererType: RENDERER_TYPE }, \r\n        root: ITreeNode = this._tree.root, \r\n        viewerID?: string\r\n    ): IIntersection[] {\r\n        let intersections: IIntersection[] = [];\r\n        const intersectNode = (node: ITreeNode, visible: boolean, excludeViewports: string[], restrictViewports: string[]) => {\r\n            if(visible === false) return;\r\n\r\n            if(viewerID !== undefined) {\r\n                if(excludeViewports.includes(viewerID)) return;\r\n                if(restrictViewports.length > 0 && !restrictViewports.includes(viewerID)) return;\r\n            }\r\n\r\n            if(filterCriteria) {\r\n                for (let i = 0; i < filterCriteria.length; i++) {\r\n                    if (filterCriteria[i](node)) {\r\n                        const intersection = this.intersectNode(node, ray, intersectionOptions)\r\n                        if (intersection) {\r\n                            intersection.forEach(i => i.node = node);\r\n                            intersections = intersections.concat(intersection);\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                const intersection = this.intersectNode(node, ray)\r\n                if (intersection) {\r\n                    intersection.forEach(i => i.node = node);\r\n                    intersections = intersections.concat(intersection);\r\n                }\r\n            }\r\n\r\n            for (let i = 0; i < node.children.length; i++)\r\n                intersectNode(node.children[i], visible && node.children[i].visible, excludeViewports.concat(node.children[i].excludeViewports), restrictViewports.concat(node.children[i].restrictViewports))\r\n        }\r\n        for (let i = 0; i < this._intersectNodes.length; i++)\r\n             intersectNode(this._intersectNodes[i].node, this._intersectNodes[i].visible, this._intersectNodes[i].excludeViewports, this._intersectNodes[i].restrictViewports)\r\n\r\n        intersections.sort((a, b) => a.distance - b.distance);\r\n        return intersections;\r\n    }\r\n\r\n    public intersectNode(node: ITreeNode, rayIn: IRay, intersectionOptions?: { opacity: number, rendererType: RENDERER_TYPE }): IIntersection[] | undefined {\r\n        if (node.visible === false) return;\r\n\r\n        const inverseMatrix = mat4.invert(mat4.create(), node.worldMatrix);\r\n        const ray = {\r\n            origin: vec3.transformMat4(vec3.create(), rayIn.origin, inverseMatrix),\r\n            direction: vec3.normalize(vec3.create(), vec3.fromValues(\r\n                inverseMatrix[0] * rayIn.direction[0] + inverseMatrix[4] * rayIn.direction[1] + inverseMatrix[8] * rayIn.direction[2],\r\n                inverseMatrix[1] * rayIn.direction[0] + inverseMatrix[5] * rayIn.direction[1] + inverseMatrix[9] * rayIn.direction[2],\r\n                inverseMatrix[2] * rayIn.direction[0] + inverseMatrix[6] * rayIn.direction[1] + inverseMatrix[10] * rayIn.direction[2]\r\n            ))\r\n        };\r\n\r\n        let geometryData: GeometryData | undefined;\r\n        for (let i = 0; i < node.data.length; i++) {\r\n            if (node.data[i] instanceof GeometryData) {\r\n                geometryData = <GeometryData>node.data[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        // quick out if the material does not fit the intersection options\r\n        if (geometryData && intersectionOptions) {\r\n            let materialData: IMaterialAbstractData | null = null;\r\n            if (geometryData.effectMaterials.length > 0) {\r\n                materialData = geometryData.effectMaterials[geometryData.effectMaterials.length - 1].material\r\n            } else if (intersectionOptions.rendererType === RENDERER_TYPE.ATTRIBUTES) {\r\n                materialData = geometryData.attributeMaterial;\r\n            } else {\r\n                materialData = geometryData.material;\r\n            }\r\n\r\n            // if opacity <= intersectionOptions.opacity\r\n            if (materialData && materialData.opacity <= intersectionOptions.opacity)\r\n                return;\r\n        }\r\n\r\n        if (!geometryData) {\r\n            let intersections: IIntersection[] = [];\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                let intersection = this.intersectNode(node.children[i], rayIn, intersectionOptions);\r\n                if (intersection)\r\n                    intersections = intersections.concat(intersection);\r\n            }\r\n            if (intersections.length > 0) {\r\n                intersections.sort((a, b) => a.distance - b.distance);\r\n                return intersections;\r\n            }\r\n            return;\r\n        } else if (geometryData.mode === PRIMITIVE_MODE.LINES) {\r\n            // if (node.boundingBox.boundingSphere.intersects(ray.origin, ray.direction) === false) return;\r\n            if (node.boundingBox.intersects(rayIn.origin, rayIn.direction) === false) return;\r\n\r\n            const index = geometryData.primitive.indices;\r\n            const position = geometryData.primitive.attributes['POSITION'];\r\n            const radius = 0.1;\r\n            let intersections: IIntersection[] = [];\r\n            if (index !== null) {\r\n                // indexed buffer geometry\r\n                for (let i = 0, il = +index.count; i < il; i += 2) {\r\n                    const a = index.array[(i) * index.itemSize];\r\n                    const b = index.array[(i + 1) * index.itemSize];\r\n\r\n                    let intersection = this.checkLineIntersection(node, ray, radius,\r\n                        vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]),\r\n                        vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]));\r\n                    if (intersection) intersections.push(Object.assign(intersection, { geometryData }))\r\n                }\r\n            } else if (position !== undefined) {\r\n                // non-indexed buffer geometry\r\n                for (let i = 0, il = +position.count; i < il; i += 2) {\r\n                    const a = i;\r\n                    const b = i + 1;\r\n                    let intersection = this.checkLineIntersection(node, ray, radius,\r\n                        vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]),\r\n                        vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]));\r\n                        if (intersection) intersections.push(Object.assign(intersection, { geometryData }))\r\n                }\r\n            }\r\n\r\n            intersections.sort((a, b) => a.distance - b.distance);\r\n            intersections.forEach(i => i.point = vec3.transformMat4(i.point, i.point, node.worldMatrix));\r\n            return intersections;\r\n        } else if (geometryData.mode === PRIMITIVE_MODE.LINE_LOOP || geometryData.mode === PRIMITIVE_MODE.LINE_STRIP) {\r\n            // if (node.boundingBox.boundingSphere.intersects(ray.origin, ray.direction) === false) return;\r\n            if (node.boundingBox.intersects(rayIn.origin, rayIn.direction) === false) return;\r\n\r\n            const index = geometryData.primitive.indices;\r\n            const position = geometryData.primitive.attributes['POSITION'];\r\n            const radius = 0.1;\r\n            let intersections: IIntersection[] = [];\r\n            if (index !== null) {\r\n                // indexed buffer geometry\r\n                for (let i = 0, il = +index.count - 1; i < il; i++) {\r\n                    const a = index.array[(i) * index.itemSize];\r\n                    const b = index.array[(i + 1) * index.itemSize];\r\n\r\n                    let intersection = this.checkLineIntersection(node, ray, radius,\r\n                        vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]),\r\n                        vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]));\r\n                    if (intersection) intersections.push(Object.assign(intersection, { geometryData }))\r\n                }\r\n            } else if (position !== undefined) {\r\n                // non-indexed buffer geometry\r\n                for (let i = 0, il = +position.count; i < il; i += 2) {\r\n                    const a = i;\r\n                    const b = i + 1;\r\n                    let intersection = this.checkLineIntersection(node, ray, radius,\r\n                        vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]),\r\n                        vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2])); \r\n                        if (intersection) intersections.push(Object.assign(intersection, { geometryData }))\r\n                }\r\n            }\r\n\r\n            intersections.sort((a, b) => a.distance - b.distance);\r\n            intersections.forEach(i => i.point = vec3.transformMat4(i.point, i.point, node.worldMatrix));\r\n            return intersections;\r\n        } else if (geometryData.mode === PRIMITIVE_MODE.POINTS) {\r\n            const position = geometryData.primitive.attributes['POSITION'];\r\n            const radius = 0.1;\r\n            let intersections: IIntersection[] = [];\r\n            if (position !== undefined) {\r\n                // non-indexed buffer geometry\r\n                for (let i = 0, il = +position.count; i < il; i++) {\r\n                    let intersection = this.checkPointIntersection(node, ray, radius,\r\n                        vec3.fromValues(position.array[i * position.itemSize], position.array[i * position.itemSize + 1], position.array[i * position.itemSize + 2]));\r\n                    if (intersection) intersections.push(Object.assign(intersection, { geometryData }))\r\n                }\r\n            }\r\n\r\n            intersections.sort((a, b) => a.distance - b.distance);\r\n            intersections.forEach(i => i.point = vec3.transformMat4(i.point, i.point, node.worldMatrix));\r\n            return intersections;\r\n        } else {\r\n            // Here, Vector is a vector in Rn, not a dynamic array.\r\n            let  v = vec3.sub(vec3.create(), node.boundingBox.boundingSphere.center, rayIn.origin);\r\n            let dotProd = vec3.dot(v, rayIn.direction);\r\n            dotProd = Math.max(dotProd, 0.0); // if dotProd is negative, the closest point is in the opposite direction to d.\r\n            let e = vec3.add(vec3.create(), rayIn.origin, vec3.scale(vec3.create(), rayIn.direction, dotProd));\r\n\r\n            let squaredDistance = vec3.squaredDistance(e, node.boundingBox.boundingSphere.center);\r\n            if (squaredDistance > node.boundingBox.boundingSphere.radius * node.boundingBox.boundingSphere.radius) return;\r\n\r\n            // if (node.boundingBox.boundingSphere.intersects(ray.origin, ray.direction) === false) return;\r\n            if (node.boundingBox.intersects(rayIn.origin, rayIn.direction) === false) return;\r\n\r\n            const material = geometryData.material;\r\n            const index = geometryData.primitive.indices;\r\n            const position = geometryData.primitive.attributes['POSITION'];\r\n\r\n            let intersections: IIntersection[] = [];\r\n\r\n            if (index !== null) {\r\n                // indexed buffer geometry\r\n                for (let i = 0, il = +index.count; i < il; i += 3) {\r\n                    const a = index.array[(i) * index.itemSize];\r\n                    const b = index.array[(i + 1) * index.itemSize];\r\n                    const c = index.array[(i + 2) * index.itemSize];\r\n\r\n                    let intersection = this.checkIntersection(node, material, ray,\r\n                        vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]),\r\n                        vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]),\r\n                        vec3.fromValues(position.array[c * position.itemSize], position.array[c * position.itemSize + 1], position.array[c * position.itemSize + 2]));\r\n                    if (intersection) intersections.push(Object.assign(intersection, { geometryData }))\r\n                }\r\n            } else if (position !== undefined) {\r\n                // non-indexed buffer geometry\r\n                for (let i = 0, il = +position.count; i < il; i += 3) {\r\n                    const a = i;\r\n                    const b = i + 1;\r\n                    const c = i + 2;\r\n                    let intersection = this.checkIntersection(node, material, ray,\r\n                        vec3.fromValues(position.array[a * position.itemSize], position.array[a * position.itemSize + 1], position.array[a * position.itemSize + 2]),\r\n                        vec3.fromValues(position.array[b * position.itemSize], position.array[b * position.itemSize + 1], position.array[b * position.itemSize + 2]),\r\n                        vec3.fromValues(position.array[c * position.itemSize], position.array[c * position.itemSize + 1], position.array[c * position.itemSize + 2]));\r\n                    if (intersection) intersections.push(Object.assign(intersection, { geometryData }))\r\n                }\r\n            }\r\n\r\n            intersections.sort((a, b) => a.distance - b.distance);\r\n            intersections.forEach(i => i.point = vec3.transformMat4(i.point, i.point, node.worldMatrix));\r\n            return intersections;\r\n        }\r\n    }\r\n\r\n    // #endregion Public Methods (2)\r\n\r\n    // #region Private Methods (4)\r\n\r\n    private checkIntersection(node: ITreeNode, material: IMaterialAbstractData | null, ray: IRay, pA: vec3, pB: vec3, pC: vec3): { distance: number, point: vec3, node: ITreeNode } | undefined {\r\n        let point: vec3 | null;\r\n\r\n        if (material && material.side === MATERIAL_SIDE.BACK) {\r\n            const triangle = new Triangle(pC, pB, pA);\r\n            point = triangle.intersect(ray.origin, ray.direction);\r\n        } else {\r\n            const triangle = new Triangle(pA, pB, pC);\r\n            point = triangle.intersect(ray.origin, ray.direction);\r\n        }\r\n\r\n        if (point === null) return;\r\n\r\n        const distance = vec3.distance(ray.origin, point);\r\n        return {\r\n            distance: distance,\r\n            point: vec3.clone(point),\r\n            node\r\n        };\r\n    }\r\n\r\n    private checkLineIntersection(node: ITreeNode, ray: IRay, radius: number, pA: vec3, pB: vec3): { distance: number, point: vec3, node: ITreeNode } | undefined {\r\n        const direction = vec3.sub(vec3.create(), pB, pA);\r\n        const lineLength = vec3.length(direction);\r\n        const lineRay = {\r\n            origin: pA,\r\n            direction: vec3.divide(vec3.create(), direction, vec3.fromValues(lineLength, lineLength, lineLength))\r\n        };\r\n        const planeNormal = vec3.cross(vec3.create(), ray.direction, lineRay.direction);\r\n\r\n        const Na = vec3.normalize(vec3.create(), vec3.cross(vec3.create(), ray.direction, planeNormal));\r\n        const Nb = vec3.normalize(vec3.create(), vec3.cross(vec3.create(), lineRay.direction, planeNormal));\r\n\r\n        const da = vec3.dot(vec3.sub(vec3.create(), pA, ray.origin), Nb) / vec3.dot(ray.direction, Nb);\r\n        const db = vec3.dot(vec3.sub(vec3.create(), ray.origin, pA), Na) / vec3.dot(lineRay.direction, Na);\r\n\r\n        let pointA: vec3 = vec3.create();\r\n        if (da < 0) {\r\n            vec3.copy(pointA, ray.origin);\r\n        } else {\r\n            pointA = vec3.add(vec3.create(), ray.origin, vec3.mul(vec3.create(), ray.direction, vec3.fromValues(da, da, da)));\r\n        }\r\n\r\n        let pointB: vec3 = vec3.create();\r\n        if (db < 0) {\r\n            vec3.copy(pointB, pA);\r\n        } else if (db < lineLength) {\r\n            pointB = vec3.add(vec3.create(), pA, vec3.mul(vec3.create(), lineRay.direction, vec3.fromValues(db, db, db)));\r\n        } else {\r\n            vec3.copy(pointB, pB);\r\n        }\r\n\r\n        const distance = vec3.distance(pointA, pointB);\r\n        if (distance < radius) {\r\n            return {\r\n                distance: distance,\r\n                point: vec3.clone(pointB),\r\n                node\r\n            }\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n\r\n    private checkPointIntersection(node: ITreeNode, ray: IRay, radius: number, p: vec3): { distance: number, point: vec3, node: ITreeNode } | undefined {\r\n        const closestPoint = vec3.sub(vec3.create(), p, ray.origin);\r\n        const directionDistance = vec3.dot(closestPoint, ray.direction);\r\n\r\n        if (directionDistance < 0) {\r\n            vec3.copy(closestPoint, ray.origin);\r\n        } else {\r\n            vec3.multiply(closestPoint, vec3.copy(closestPoint, ray.direction), vec3.fromValues(directionDistance, directionDistance, directionDistance));\r\n            vec3.add(closestPoint, closestPoint, ray.origin);\r\n        }\r\n\r\n        const distance = vec3.distance(closestPoint, p);\r\n        if (distance < radius) {\r\n            return {\r\n                distance: distance,\r\n                point: vec3.clone(closestPoint),\r\n                node\r\n            }\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n\r\n    private gatherNodes() {\r\n        this._intersectNodes = [];\r\n        this._tree.root.traverse(node => {\r\n            if (node.visible === false) return;\r\n\r\n            for(let i = 0; i < node.data.length; i++) {\r\n                if(node.data[i] instanceof GeometryData) {\r\n\r\n                    let tempNode = node;\r\n                    let visible = true, restrictViewports: string[] = [], excludeViewports: string[] = [];\r\n                    while(tempNode.parent) {\r\n                        visible = tempNode.visible && visible;\r\n                        restrictViewports = restrictViewports.concat(tempNode.restrictViewports)\r\n                        excludeViewports = excludeViewports.concat(tempNode.excludeViewports)\r\n                        tempNode = tempNode.parent;\r\n                    }\r\n\r\n                    this._intersectNodes.push({\r\n                        node,\r\n                        visible,\r\n                        restrictViewports: [...new Set(restrictViewports)],\r\n                        excludeViewports: [...new Set(excludeViewports)]\r\n                    })\r\n\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    // #endregion Private Methods (4)\r\n}"]}},"error":null,"hash":"e973ec685420403b9367c908353e4593","cacheData":{"env":{}}}