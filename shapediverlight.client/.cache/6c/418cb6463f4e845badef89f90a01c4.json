{"id":"node_modules/@shapediver/viewer.data-engine.geometry-engine/dist/gltfv1/SDGTFLoader.js","dependencies":[{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv1\\SDGTFLoader.js.map","includedInParent":true,"mtime":1706542087224},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\src\\gltfv1\\SDGTFLoader.ts","includedInParent":true,"mtime":1706542087376},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\package.json","includedInParent":true,"mtime":1706542184022},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\package.json","includedInParent":true,"mtime":1706542086828},{"name":"@shapediver/viewer.shared.node-tree","loc":{"line":13,"column":42,"index":842},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv1\\SDGTFLoader.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.node-tree\\dist\\index.js"},{"name":"@shapediver/viewer.shared.services","loc":{"line":14,"column":41,"index":924},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv1\\SDGTFLoader.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.services\\dist\\index.js"},{"name":"@shapediver/viewer.data-engine.shared-types","loc":{"line":15,"column":50,"index":1014},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv1\\SDGTFLoader.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.data-engine.shared-types\\dist\\index.js"},{"name":"@shapediver/viewer.shared.types","loc":{"line":16,"column":38,"index":1101},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv1\\SDGTFLoader.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.types\\dist\\index.js"},{"name":"gl-matrix","loc":{"line":17,"column":28,"index":1166},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv1\\SDGTFLoader.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\gl-matrix\\esm\\index.js"}],"generated":{"js":"\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SDGTFLoader = void 0;\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst viewer_data_engine_shared_types_1 = require(\"@shapediver/viewer.data-engine.shared-types\");\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nclass SDGTFLoader {\r\n    constructor() {\r\n        // #region Properties (5)\r\n        this.BINARY_EXTENSION_HEADER_LENGTH = 20;\r\n        this._logger = viewer_shared_services_1.Logger.instance;\r\n        // #endregion Private Methods (6)\r\n    }\r\n    // #endregion Properties (5)\r\n    // #region Public Methods (1)\r\n    load(binaryGeometry, gltfLength) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (gltfLength < binaryGeometry.byteLength) {\r\n                const headerDataView = new DataView(binaryGeometry, gltfLength, this.BINARY_EXTENSION_HEADER_LENGTH + 1);\r\n                const header = {\r\n                    magic: String.fromCharCode(headerDataView.getUint8(0)) + String.fromCharCode(headerDataView.getUint8(1)) + String.fromCharCode(headerDataView.getUint8(2)) + String.fromCharCode(headerDataView.getUint8(3)) + String.fromCharCode(headerDataView.getUint8(4)),\r\n                    version: headerDataView.getUint32(5, true),\r\n                    length: headerDataView.getUint32(9, true),\r\n                    contentLength: headerDataView.getUint32(13, true),\r\n                    contentFormat: headerDataView.getUint32(17, true)\r\n                };\r\n                if (header.magic != 'sdgTF')\r\n                    throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('SDGTFLoader.load: Invalid data: sdgTF magic wrong.');\r\n                // create content\r\n                const contentDataView = new DataView(binaryGeometry, gltfLength + this.BINARY_EXTENSION_HEADER_LENGTH + 1, header.contentLength);\r\n                const contentDecoded = new TextDecoder().decode(contentDataView);\r\n                this._content = JSON.parse(contentDecoded);\r\n                this._body = binaryGeometry.slice(gltfLength + this.BINARY_EXTENSION_HEADER_LENGTH + 1 + header.contentLength, gltfLength + header.length);\r\n            }\r\n            else {\r\n                return new viewer_shared_node_tree_1.TreeNode();\r\n            }\r\n            return yield this.loadScene();\r\n        });\r\n    }\r\n    // #endregion Public Methods (1)\r\n    // #region Private Methods (6)\r\n    convertToIndicesArray(indices) {\r\n        const max = Math.max(0, ...indices);\r\n        if (max < (1 << 8) - 1) {\r\n            return new Uint8Array(indices);\r\n        }\r\n        else if (max < (1 << 16) - 1) {\r\n            return new Uint16Array(indices);\r\n        }\r\n        else {\r\n            return new Uint32Array(indices);\r\n        }\r\n    }\r\n    loadAccessor(accessorName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.accessors[accessorName])\r\n                throw new Error('Accessor not available.');\r\n            const accessor = this._content.accessors[accessorName];\r\n            const bufferView = this._body;\r\n            const itemSize = viewer_data_engine_shared_types_1.ACCESSORTYPE_V1[accessor.type];\r\n            const ArrayType = viewer_data_engine_shared_types_1.ACCESSORCOMPONENTTYPE_V1[accessor.componentType];\r\n            const elementBytes = ArrayType.BYTES_PER_ELEMENT;\r\n            const itemBytes = elementBytes * itemSize;\r\n            const byteOffset = accessor.byteOffset || 0;\r\n            return new viewer_shared_types_1.AttributeData(new ArrayType(bufferView, byteOffset, itemSize * accessor.count), itemSize, itemBytes, byteOffset, elementBytes, false, accessor.count);\r\n        });\r\n    }\r\n    loadArcs() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.arcs)\r\n                throw new Error('Arcs not available.');\r\n            const arc = this._content.arcs;\r\n            const arcNode = new viewer_shared_node_tree_1.TreeNode('arcs');\r\n            const data = yield this.loadAccessor(arc.attributes['ARCS']);\r\n            // data with an absolute classic array of Vec12s ...\r\n            // like you usually have it in any good program\r\n            // not 4 Vec3s, no, that would be to logic, but a Vec12 instead\r\n            const count = data.array.length / data.itemSize;\r\n            for (let i = 0; i < count; ++i) {\r\n                const singleArcNode = new viewer_shared_node_tree_1.TreeNode('arc_' + i);\r\n                const index = i * 12;\r\n                const arcCenter = gl_matrix_1.vec3.fromValues(data.array[index + 0], data.array[index + 1], data.array[index + 2]);\r\n                const arcXAxis = gl_matrix_1.vec3.fromValues(data.array[index + 3], data.array[index + 4], data.array[index + 5]);\r\n                const arcYAxis = gl_matrix_1.vec3.fromValues(data.array[index + 6], data.array[index + 7], data.array[index + 8]);\r\n                const arcRadius = data.array[index + 9];\r\n                const arcMinAngle = data.array[index + 10];\r\n                const arcMaxAngle = data.array[index + 11];\r\n                const arcZAxis = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), arcXAxis, arcYAxis);\r\n                if (arcRadius <= 0) {\r\n                    this._logger.warn('SDGTFLoader.loadArcs: Arc radius is <= 0.');\r\n                    continue;\r\n                }\r\n                const points = [];\r\n                const getPointOnArc = (t) => {\r\n                    const twoPi = Math.PI * 2;\r\n                    let deltaAngle = arcMaxAngle - arcMinAngle;\r\n                    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;\r\n                    // ensures that deltaAngle is 0 .. 2 PI\r\n                    while (deltaAngle < 0)\r\n                        deltaAngle += twoPi;\r\n                    while (deltaAngle > twoPi)\r\n                        deltaAngle -= twoPi;\r\n                    deltaAngle = deltaAngle < Number.EPSILON ? samePoints ? 0 : twoPi : deltaAngle;\r\n                    const angle = arcMinAngle + t * deltaAngle;\r\n                    let x = arcRadius * Math.cos(angle);\r\n                    let y = arcRadius * Math.sin(angle);\r\n                    points.push(x, y, 0);\r\n                };\r\n                const numberOfPoints = Math.max(3, Math.round(50 * ((arcMaxAngle - arcMinAngle) / 2 * Math.PI)));\r\n                for (let d = 0; d <= numberOfPoints; d++)\r\n                    getPointOnArc(d / numberOfPoints);\r\n                const array = new Float32Array(points);\r\n                const attributes = {};\r\n                attributes['POSITION'] = new viewer_shared_types_1.AttributeData(array, 3, 0, 0, 0, false, array.length / 3);\r\n                const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, null), viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP);\r\n                singleArcNode.data.push(geometry);\r\n                singleArcNode.addTransformation({\r\n                    id: 'arc_' + i + '_translation',\r\n                    matrix: gl_matrix_1.mat4.translate(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(arcCenter[0], arcCenter[1], arcCenter[2]))\r\n                });\r\n                const arcRotationMatrix = gl_matrix_1.mat4.transpose(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.fromValues(arcXAxis[0], arcYAxis[0], arcZAxis[0], 0, arcXAxis[1], arcYAxis[1], arcZAxis[1], 0, arcXAxis[2], arcYAxis[2], arcZAxis[2], 0, 0, 0, 0, 1));\r\n                singleArcNode.addTransformation({\r\n                    id: 'arc_' + i + '_rotation',\r\n                    matrix: arcRotationMatrix\r\n                });\r\n                arcNode.addChild(singleArcNode);\r\n            }\r\n            return arcNode;\r\n        });\r\n    }\r\n    loadBeziercurve(beziercurveName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.beziercurves[beziercurveName])\r\n                throw new Error('Beziercurve not available.');\r\n            const beziercurve = this._content.beziercurves[beziercurveName];\r\n            const beziercurveNode = new viewer_shared_node_tree_1.TreeNode(beziercurveName);\r\n            const controlPointsData = yield this.loadAccessor(beziercurve.attributes['CONTROLPOINTS']); // vec3\r\n            const controlPoints = [];\r\n            for (let i = 0; i < controlPointsData.array.length; i += 3)\r\n                controlPoints.push(gl_matrix_1.vec4.fromValues(controlPointsData.array[i], controlPointsData.array[i + 1], controlPointsData.array[i + 2], 1));\r\n            const knotsData = yield this.loadAccessor(beziercurve.attributes['KNOTS']); // scalar\r\n            const knots = [knotsData.array[0]];\r\n            for (let i = 0; i < knotsData.array.length; i++)\r\n                knots.push(knotsData.array[i]);\r\n            knots.push(knotsData.array[knotsData.array.length - 1]);\r\n            const degree = beziercurve.degree;\r\n            const findSpan = (u) => {\r\n                const n = knots.length - degree - 1;\r\n                if (u >= knots[n])\r\n                    return n - 1;\r\n                if (u <= knots[degree])\r\n                    return degree;\r\n                let low = degree;\r\n                let high = n;\r\n                let mid = Math.floor((low + high) / 2);\r\n                while (u < knots[mid] || u >= knots[mid + 1]) {\r\n                    if (u < knots[mid]) {\r\n                        high = mid;\r\n                    }\r\n                    else {\r\n                        low = mid;\r\n                    }\r\n                    mid = Math.floor((low + high) / 2);\r\n                }\r\n                return mid;\r\n            };\r\n            const calcBasisFunctions = (span, u) => {\r\n                const N = [];\r\n                const left = [];\r\n                const right = [];\r\n                N[0] = 1.0;\r\n                for (let j = 1; j <= degree; ++j) {\r\n                    left[j] = u - knots[span + 1 - j];\r\n                    right[j] = knots[span + j] - u;\r\n                    let saved = 0.0;\r\n                    for (let r = 0; r < j; ++r) {\r\n                        const rv = right[r + 1];\r\n                        const lv = left[j - r];\r\n                        const temp = N[r] / (rv + lv);\r\n                        N[r] = saved + rv * temp;\r\n                        saved = lv * temp;\r\n                    }\r\n                    N[j] = saved;\r\n                }\r\n                return N;\r\n            };\r\n            const calcBSplinePoint = (u) => {\r\n                const span = findSpan(u);\r\n                const N = calcBasisFunctions(span, u);\r\n                const C = gl_matrix_1.vec4.create();\r\n                for (let j = 0; j <= degree; ++j) {\r\n                    const point = controlPoints[span - degree + j];\r\n                    const Nj = N[j];\r\n                    const wNj = point[3] * Nj;\r\n                    gl_matrix_1.vec4.add(C, C, gl_matrix_1.vec4.fromValues(point[0] * wNj, point[1] * wNj, point[2] * wNj, point[3] * Nj));\r\n                }\r\n                return C;\r\n            };\r\n            const points = [];\r\n            const getPointOnBezierCurve = (t) => {\r\n                const u = knots[0] + t * (knots[knots.length - 1] - knots[0]); // linear mapping t->u\r\n                // following results in (wx, wy, wz, w) homogeneous point\r\n                let hpoint = calcBSplinePoint(u);\r\n                if (hpoint[3] !== 1.0) {\r\n                    // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\r\n                    hpoint = gl_matrix_1.vec4.divide(gl_matrix_1.vec4.create(), hpoint, gl_matrix_1.vec4.fromValues(hpoint[3], hpoint[3], hpoint[3], hpoint[3]));\r\n                }\r\n                points.push(hpoint[0], hpoint[1], hpoint[2]);\r\n            };\r\n            // Number of points calculation\r\n            // We go through the control points, measure the distance\r\n            let distance = 0;\r\n            for (let i = 1; i < controlPoints.length; i++)\r\n                distance += gl_matrix_1.vec3.distance(gl_matrix_1.vec3.fromValues(controlPoints[i - 1][0], controlPoints[i - 1][1], controlPoints[i - 1][2]), gl_matrix_1.vec3.fromValues(controlPoints[i][0], controlPoints[i][1], controlPoints[i][2]));\r\n            const numberOfPoints = Math.min(100, Math.max(25, Math.floor(distance / 0.1)));\r\n            for (let d = 0; d <= numberOfPoints; d++)\r\n                getPointOnBezierCurve(d / numberOfPoints);\r\n            const array = new Float32Array(points);\r\n            const attributes = {};\r\n            attributes['POSITION'] = new viewer_shared_types_1.AttributeData(array, 3, 0, 0, 0, false, array.length / 3);\r\n            const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, null), viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP);\r\n            beziercurveNode.data.push(geometry);\r\n            return beziercurveNode;\r\n        });\r\n    }\r\n    loadCircles() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.circles)\r\n                throw new Error('Circles not available.');\r\n            const circle = this._content.circles;\r\n            const circleNode = new viewer_shared_node_tree_1.TreeNode('circles');\r\n            const data = yield this.loadAccessor(circle.attributes['CIRCLES']);\r\n            const count = data.array.length / data.itemSize;\r\n            for (let i = 0; i < count; i++) {\r\n                const singleCircleNode = new viewer_shared_node_tree_1.TreeNode('circle_' + i);\r\n                const index = i * 10;\r\n                const circleCenter = gl_matrix_1.vec3.fromValues(data.array[index + 0], data.array[index + 1], data.array[index + 2]);\r\n                const circleXAxis = gl_matrix_1.vec3.fromValues(data.array[index + 3], data.array[index + 4], data.array[index + 5]);\r\n                const circleYAxis = gl_matrix_1.vec3.fromValues(data.array[index + 6], data.array[index + 7], data.array[index + 8]);\r\n                const circleRadius = data.array[index + 9];\r\n                const circleZAxis = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), circleXAxis, circleYAxis);\r\n                if (circleRadius <= 0) {\r\n                    this._logger.warn('SDGTFLoader.loadCircles: Circle radius is <= 0.');\r\n                    continue;\r\n                }\r\n                const points = [];\r\n                const getPointOnArc = (t) => {\r\n                    const twoPi = Math.PI * 2;\r\n                    let deltaAngle = 2.0 * Math.PI - 0;\r\n                    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;\r\n                    // ensures that deltaAngle is 0 .. 2 PI\r\n                    while (deltaAngle < 0)\r\n                        deltaAngle += twoPi;\r\n                    while (deltaAngle > twoPi)\r\n                        deltaAngle -= twoPi;\r\n                    deltaAngle = deltaAngle < Number.EPSILON ? samePoints ? 0 : twoPi : deltaAngle;\r\n                    const angle = 0 + t * deltaAngle;\r\n                    let x = circleRadius * Math.cos(angle);\r\n                    let y = circleRadius * Math.sin(angle);\r\n                    points.push(x, y, 0);\r\n                };\r\n                const numberOfPoints = 50;\r\n                for (let d = 0; d <= numberOfPoints; d++)\r\n                    getPointOnArc(d / numberOfPoints);\r\n                const array = new Float32Array(points);\r\n                const attributes = {};\r\n                attributes['POSITION'] = new viewer_shared_types_1.AttributeData(array, 3, 0, 0, 0, false, array.length / 3);\r\n                const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, null), viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP);\r\n                singleCircleNode.data.push(geometry);\r\n                singleCircleNode.addTransformation({\r\n                    id: 'circle_' + i + '_translation',\r\n                    matrix: gl_matrix_1.mat4.translate(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(circleCenter[0], circleCenter[1], circleCenter[2]))\r\n                });\r\n                const circleRotationMatrix = gl_matrix_1.mat4.transpose(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.fromValues(circleXAxis[0], circleYAxis[0], circleZAxis[0], 0, circleXAxis[1], circleYAxis[1], circleZAxis[1], 0, circleXAxis[2], circleYAxis[2], circleZAxis[2], 0, 0, 0, 0, 1));\r\n                singleCircleNode.addTransformation({\r\n                    id: 'circle_' + i + '_rotation',\r\n                    matrix: circleRotationMatrix\r\n                });\r\n                circleNode.addChild(singleCircleNode);\r\n            }\r\n            return circleNode;\r\n        });\r\n    }\r\n    loadCylinders() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.cylinders)\r\n                throw new Error('Cylinders not available.');\r\n            const cylinder = this._content.cylinders;\r\n            const cylinderNode = new viewer_shared_node_tree_1.TreeNode('cylinders');\r\n            const data = yield this.loadAccessor(cylinder.attributes['CYLINDERS']);\r\n            const count = data.array.length / data.itemSize;\r\n            for (let i = 0; i < count; i++) {\r\n                const singleCylinderNode = new viewer_shared_node_tree_1.TreeNode('cylinder_' + i);\r\n                const index = i * 7;\r\n                const cylinderTop = gl_matrix_1.vec3.fromValues(data.array[index + 0], data.array[index + 1], data.array[index + 2]);\r\n                const cylinderBottom = gl_matrix_1.vec3.fromValues(data.array[index + 3], data.array[index + 4], data.array[index + 5]);\r\n                const cylinderRadius = data.array[index + 6];\r\n                const cylinderAxis = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), cylinderTop, cylinderBottom);\r\n                const dotX = Math.abs(gl_matrix_1.vec3.dot(cylinderAxis, gl_matrix_1.vec3.fromValues(1, 0, 0)));\r\n                const dotY = Math.abs(gl_matrix_1.vec3.dot(cylinderAxis, gl_matrix_1.vec3.fromValues(0, 1, 0)));\r\n                let cylinderXAxis;\r\n                if (dotX < dotY) {\r\n                    cylinderXAxis = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), cylinderAxis, gl_matrix_1.vec3.fromValues(1, 0, 0));\r\n                }\r\n                else {\r\n                    cylinderXAxis = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), cylinderAxis, gl_matrix_1.vec3.fromValues(0, 1, 0));\r\n                }\r\n                const cylinderYAxis = gl_matrix_1.vec3.cross(gl_matrix_1.vec3.create(), cylinderAxis, cylinderXAxis);\r\n                gl_matrix_1.vec3.normalize(cylinderAxis, cylinderAxis);\r\n                gl_matrix_1.vec3.normalize(cylinderXAxis, cylinderXAxis);\r\n                gl_matrix_1.vec3.normalize(cylinderYAxis, cylinderYAxis);\r\n                if (cylinderRadius <= 0) {\r\n                    this._logger.warn('SDGTFLoader.loadCylinders: Cylinder radius is <= 0.');\r\n                    continue;\r\n                }\r\n                const indices = [];\r\n                const vertices = [];\r\n                const normals = [];\r\n                const uvs = [];\r\n                const height = gl_matrix_1.vec3.distance(cylinderTop, cylinderBottom);\r\n                const halfHeight = height / 2;\r\n                const thetaStart = 0, thetaLength = Math.PI * 2;\r\n                let indexCounter = 0;\r\n                const indexArray = [];\r\n                const heightSegments = 1, radialSegments = 50;\r\n                const normal = gl_matrix_1.vec3.create();\r\n                const vertex = gl_matrix_1.vec3.create();\r\n                let groupCount = 0;\r\n                // this will be used to calculate the normal\r\n                const slope = 0;\r\n                // generate vertices, normals and uvs\r\n                for (let y = 0; y <= heightSegments; y++) {\r\n                    const indexRow = [];\r\n                    const v = y / heightSegments;\r\n                    // calculate the radius of the current row\r\n                    const radius = cylinderRadius;\r\n                    for (let x = 0; x <= radialSegments; x++) {\r\n                        const u = x / radialSegments;\r\n                        const theta = u * thetaLength + thetaStart;\r\n                        const sinTheta = Math.sin(theta);\r\n                        const cosTheta = Math.cos(theta);\r\n                        // vertex\r\n                        vertex[0] = radius * sinTheta;\r\n                        vertex[1] = -v * height + halfHeight;\r\n                        vertex[2] = radius * cosTheta;\r\n                        vertices.push(vertex[0], vertex[1], vertex[2]);\r\n                        // normal\r\n                        gl_matrix_1.vec3.normalize(normal, gl_matrix_1.vec3.fromValues(sinTheta, slope, cosTheta));\r\n                        normals.push(normal[0], normal[1], normal[2]);\r\n                        // uv\r\n                        uvs.push(u, 1 - v);\r\n                        // save index of vertex in respective row\r\n                        indexRow.push(indexCounter++);\r\n                    }\r\n                    // now save vertices of the row in our index array\r\n                    indexArray.push(indexRow);\r\n                }\r\n                // generate indices\r\n                for (let x = 0; x < radialSegments; x++) {\r\n                    for (let y = 0; y < heightSegments; y++) {\r\n                        // we use the index array to access the correct indices\r\n                        const a = indexArray[y][x];\r\n                        const b = indexArray[y + 1][x];\r\n                        const c = indexArray[y + 1][x + 1];\r\n                        const d = indexArray[y][x + 1];\r\n                        // faces\r\n                        indices.push(a, b, d);\r\n                        indices.push(b, c, d);\r\n                        // update group counter\r\n                        groupCount += 6;\r\n                    }\r\n                }\r\n                const attributes = {};\r\n                attributes['POSITION'] = new viewer_shared_types_1.AttributeData(new Float32Array(vertices), 3, 0, 0, 0, false, vertices.length / 3);\r\n                attributes['NORMAL'] = new viewer_shared_types_1.AttributeData(new Float32Array(normals), 3, 0, 0, 0, false, normals.length / 3);\r\n                attributes['TEXCOORD_0'] = new viewer_shared_types_1.AttributeData(new Float32Array(uvs), 2, 0, 0, 0, false, uvs.length / 2);\r\n                const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, new viewer_shared_types_1.AttributeData(this.convertToIndicesArray(indices), 1, 0, 0, 0, false, indices.length)), viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLES);\r\n                singleCylinderNode.data.push(geometry);\r\n                singleCylinderNode.addTransformation({\r\n                    id: 'cylinder_' + i + '_translation',\r\n                    matrix: gl_matrix_1.mat4.translate(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), cylinderBottom)\r\n                });\r\n                const cylinderRotationMatrix = gl_matrix_1.mat4.transpose(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.fromValues(cylinderXAxis[0], cylinderYAxis[0], cylinderAxis[0], 0, cylinderXAxis[1], cylinderYAxis[1], cylinderAxis[1], 0, cylinderXAxis[2], cylinderYAxis[2], cylinderAxis[2], 0, 0, 0, 0, 1));\r\n                singleCylinderNode.addTransformation({\r\n                    id: 'cylinder_' + i + '_rotation',\r\n                    matrix: cylinderRotationMatrix\r\n                });\r\n                singleCylinderNode.addTransformation({\r\n                    id: 'cylinder_' + i + '_rotation2',\r\n                    matrix: gl_matrix_1.mat4.rotateX(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), 0.5 * Math.PI)\r\n                });\r\n                singleCylinderNode.addTransformation({\r\n                    id: 'cylinder_' + i + '_translation2',\r\n                    matrix: gl_matrix_1.mat4.translate(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(0, 0, 0.5 * gl_matrix_1.vec3.distance(cylinderTop, cylinderBottom)))\r\n                });\r\n                cylinderNode.addChild(singleCylinderNode);\r\n            }\r\n            return cylinderNode;\r\n        });\r\n    }\r\n    loadSpheres() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.spheres)\r\n                throw new Error('Spheres not available.');\r\n            const sphere = this._content.spheres;\r\n            const sphereNode = new viewer_shared_node_tree_1.TreeNode('spheres');\r\n            const data = yield this.loadAccessor(sphere.attributes['SPHERES']);\r\n            const count = data.array.length / data.itemSize;\r\n            for (let i = 0; i < count; i++) {\r\n                const singleSphereNode = new viewer_shared_node_tree_1.TreeNode('sphere_' + i);\r\n                const index = i * 4;\r\n                const sphereTranslation = gl_matrix_1.vec3.fromValues(data.array[index + 0], data.array[index + 1], data.array[index + 2]);\r\n                const sphereRadius = data.array[index + 3];\r\n                if (sphereRadius <= 0) {\r\n                    this._logger.warn('SDGTFLoader.loadSpheres: Sphere radius is <= 0.');\r\n                    continue;\r\n                }\r\n                const indices = [];\r\n                const vertices = [];\r\n                const normals = [];\r\n                const uvs = [];\r\n                const grid = [];\r\n                // for some reason, this doesn't work with values > 15\r\n                // let's not look into it, it's legacy stuff\r\n                const heightSegments = 15, widthSegments = 15;\r\n                const phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI;\r\n                const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\r\n                let indexCounter = 0;\r\n                // generate vertices, normals and uvs\r\n                for (let iy = 0; iy <= heightSegments; iy++) {\r\n                    const verticesRow = [];\r\n                    const v = iy / heightSegments;\r\n                    // special case for the poles\r\n                    let uOffset = 0;\r\n                    if (iy == 0 && thetaStart == 0) {\r\n                        uOffset = 0.5 / widthSegments;\r\n                    }\r\n                    else if (iy == heightSegments && thetaEnd == Math.PI) {\r\n                        uOffset = -0.5 / widthSegments;\r\n                    }\r\n                    for (let ix = 0; ix <= widthSegments; ix++) {\r\n                        const u = ix / widthSegments;\r\n                        // vertex\r\n                        const vertex = gl_matrix_1.vec3.fromValues(-sphereRadius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength), sphereRadius * Math.cos(thetaStart + v * thetaLength), sphereRadius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength));\r\n                        vertices.push(vertex[0], vertex[1], vertex[2]);\r\n                        // normal\r\n                        const normal = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), vertex);\r\n                        normals.push(normal[0], normal[1], normal[2]);\r\n                        // uv\r\n                        uvs.push(u + uOffset, 1 - v);\r\n                        verticesRow.push(indexCounter++);\r\n                    }\r\n                    grid.push(verticesRow);\r\n                }\r\n                // indices\r\n                for (let iy = 0; iy < heightSegments; iy++) {\r\n                    for (let ix = 0; ix < widthSegments; ix++) {\r\n                        const a = grid[iy][ix + 1];\r\n                        const b = grid[iy][ix];\r\n                        const c = grid[iy + 1][ix];\r\n                        const d = grid[iy + 1][ix + 1];\r\n                        if (iy !== 0 || thetaStart > 0)\r\n                            indices.push(a, b, d);\r\n                        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)\r\n                            indices.push(b, c, d);\r\n                    }\r\n                }\r\n                const attributes = {};\r\n                attributes['POSITION'] = new viewer_shared_types_1.AttributeData(new Float32Array(vertices), 3, 0, 0, 0, false, vertices.length / 3);\r\n                attributes['NORMAL'] = new viewer_shared_types_1.AttributeData(new Float32Array(normals), 3, 0, 0, 0, false, normals.length / 3);\r\n                attributes['TEXCOORD_0'] = new viewer_shared_types_1.AttributeData(new Float32Array(uvs), 2, 0, 0, 0, false, uvs.length / 2);\r\n                const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, new viewer_shared_types_1.AttributeData(this.convertToIndicesArray(indices), 1, 0, 0, 0, false, indices.length)), viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLES);\r\n                singleSphereNode.data.push(geometry);\r\n                singleSphereNode.addTransformation({\r\n                    id: 'sphere_' + i + '_translation',\r\n                    matrix: gl_matrix_1.mat4.translate(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.create(), sphereTranslation)\r\n                });\r\n                sphereNode.addChild(singleSphereNode);\r\n            }\r\n            return sphereNode;\r\n        });\r\n    }\r\n    loadPoint(pointName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.points[pointName])\r\n                throw new Error('Point not available.');\r\n            const point = this._content.points[pointName];\r\n            const pointNode = new viewer_shared_node_tree_1.TreeNode(pointName);\r\n            const attributes = {};\r\n            const data = yield this.loadAccessor(point.attributes['POINTS']);\r\n            attributes['POSITION'] = new viewer_shared_types_1.AttributeData(data.array, 3, data.itemBytes, data.byteOffset, data.elementBytes, data.normalized, data.count);\r\n            const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, null), viewer_shared_types_1.PRIMITIVE_MODE.POINTS);\r\n            pointNode.data.push(geometry);\r\n            return pointNode;\r\n        });\r\n    }\r\n    loadPolyline(polylineName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.polylines[polylineName])\r\n                throw new Error('Polyline not available.');\r\n            const polyLine = this._content.polylines[polylineName];\r\n            const polyLineNode = new viewer_shared_node_tree_1.TreeNode(polylineName);\r\n            const attributes = {};\r\n            const data = yield this.loadAccessor(polyLine.attributes['VERTICES']);\r\n            attributes['POSITION'] = new viewer_shared_types_1.AttributeData(data.array, 3, data.itemBytes, data.byteOffset, data.elementBytes, data.normalized, data.count);\r\n            const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, null), viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP);\r\n            polyLineNode.data.push(geometry);\r\n            return polyLineNode;\r\n        });\r\n    }\r\n    loadSurfacepatch(surfacepatchName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.surfacepatches[surfacepatchName])\r\n                throw new Error('Surfacepatch not available.');\r\n            const surfacepatch = this._content.surfacepatches[surfacepatchName];\r\n            const surfacepatchNode = new viewer_shared_node_tree_1.TreeNode(surfacepatchName);\r\n            const controlPointCountU = surfacepatch.controlPointCountU;\r\n            const controlPointCountV = surfacepatch.controlPointCountV;\r\n            const controlPointsData = yield this.loadAccessor(surfacepatch.attributes['CONTROLPOINTS']); // vec3\r\n            const controlPoints = [];\r\n            let pointCount = 0;\r\n            for (let u = 0; u < controlPointCountU; u++) {\r\n                let innerArray = [];\r\n                for (let v = 0; v < controlPointCountV; v++) {\r\n                    innerArray.push(gl_matrix_1.vec4.fromValues(controlPointsData.array[pointCount * 3], controlPointsData.array[pointCount * 3 + 1], controlPointsData.array[pointCount * 3 + 2], 1));\r\n                    pointCount++;\r\n                }\r\n                controlPoints.push(innerArray);\r\n            }\r\n            const knotsUData = yield this.loadAccessor(surfacepatch.attributes['KNOTSU']); // scalar\r\n            const knotsU = [knotsUData.array[0]];\r\n            for (let i = 0; i < knotsUData.array.length; i++)\r\n                knotsU.push(knotsUData.array[i]);\r\n            knotsU.push(knotsUData.array[knotsUData.array.length - 1]);\r\n            const knotsVData = yield this.loadAccessor(surfacepatch.attributes['KNOTSV']); // scalar\r\n            const knotsV = [knotsVData.array[0]];\r\n            for (let i = 0; i < knotsVData.array.length; i++)\r\n                knotsV.push(knotsVData.array[i]);\r\n            knotsV.push(knotsVData.array[knotsVData.array.length - 1]);\r\n            const degreeU = surfacepatch.degreeU;\r\n            const degreeV = surfacepatch.degreeV;\r\n            const findSpan = (knots, degree, u) => {\r\n                const n = knots.length - degree - 1;\r\n                if (u >= knots[n])\r\n                    return n - 1;\r\n                if (u <= knots[degree])\r\n                    return degree;\r\n                let low = degree;\r\n                let high = n;\r\n                let mid = Math.floor((low + high) / 2);\r\n                while (u < knots[mid] || u >= knots[mid + 1]) {\r\n                    if (u < knots[mid]) {\r\n                        high = mid;\r\n                    }\r\n                    else {\r\n                        low = mid;\r\n                    }\r\n                    mid = Math.floor((low + high) / 2);\r\n                }\r\n                return mid;\r\n            };\r\n            const calcBasisFunctions = (knots, degree, span, u) => {\r\n                const N = [];\r\n                const left = [];\r\n                const right = [];\r\n                N[0] = 1.0;\r\n                for (let j = 1; j <= degree; ++j) {\r\n                    left[j] = u - knots[span + 1 - j];\r\n                    right[j] = knots[span + j] - u;\r\n                    let saved = 0.0;\r\n                    for (let r = 0; r < j; ++r) {\r\n                        const rv = right[r + 1];\r\n                        const lv = left[j - r];\r\n                        const temp = N[r] / (rv + lv);\r\n                        N[r] = saved + rv * temp;\r\n                        saved = lv * temp;\r\n                    }\r\n                    N[j] = saved;\r\n                }\r\n                return N;\r\n            };\r\n            const calcSurfacePoint = (u, v) => {\r\n                const uspan = findSpan(knotsU, degreeU, u);\r\n                const vspan = findSpan(knotsV, degreeV, v);\r\n                const Nu = calcBasisFunctions(knotsU, degreeU, uspan, u);\r\n                const Nv = calcBasisFunctions(knotsV, degreeV, vspan, v);\r\n                const temp = [];\r\n                for (let l = 0; l <= degreeV; ++l) {\r\n                    temp[l] = gl_matrix_1.vec4.create();\r\n                    for (let k = 0; k <= degreeU; ++k) {\r\n                        const point = gl_matrix_1.vec4.clone(controlPoints[uspan - degreeU + k][vspan - degreeV + l]);\r\n                        const w = point[3];\r\n                        point[0] *= w;\r\n                        point[1] *= w;\r\n                        point[2] *= w;\r\n                        gl_matrix_1.vec4.add(temp[l], temp[l], gl_matrix_1.vec4.multiply(gl_matrix_1.vec4.create(), point, gl_matrix_1.vec4.fromValues(Nu[k], Nu[k], Nu[k], Nu[k])));\r\n                    }\r\n                }\r\n                const Sw = gl_matrix_1.vec4.create();\r\n                for (let l = 0; l <= degreeV; ++l) {\r\n                    gl_matrix_1.vec4.add(Sw, Sw, gl_matrix_1.vec4.multiply(gl_matrix_1.vec4.create(), temp[l], gl_matrix_1.vec4.fromValues(Nv[l], Nv[l], Nv[l], Nv[l])));\r\n                }\r\n                gl_matrix_1.vec4.divide(Sw, Sw, gl_matrix_1.vec4.fromValues(Sw[3], Sw[3], Sw[3], Sw[3]));\r\n                return gl_matrix_1.vec3.fromValues(Sw[0], Sw[1], Sw[2]);\r\n            };\r\n            const getPointOnSurfacepatch = (t1, t2) => {\r\n                const u = knotsU[0] + t1 * (knotsU[knotsU.length - 1] - knotsU[0]); // linear mapping t1->u\r\n                const v = knotsV[0] + t2 * (knotsV[knotsV.length - 1] - knotsV[0]); // linear mapping t2->u\r\n                return calcSurfacePoint(u, v);\r\n            };\r\n            const numberOfPoints = 15;\r\n            const indices = [];\r\n            const vertices = [];\r\n            for (let d = 0; d <= numberOfPoints; d++) {\r\n                const v = d / numberOfPoints;\r\n                for (let f = 0; f <= numberOfPoints; f++) {\r\n                    const u = f / numberOfPoints;\r\n                    const vertex = getPointOnSurfacepatch(u, v);\r\n                    vertices.push(vertex[0], vertex[1], vertex[2]);\r\n                }\r\n            }\r\n            for (let d = 0; d < numberOfPoints; d++) {\r\n                for (let f = 0; f < numberOfPoints; f++) {\r\n                    const i1 = d * (numberOfPoints + 1) + f;\r\n                    const i2 = d * (numberOfPoints + 1) + f + 1;\r\n                    const i3 = (d + 1) * (numberOfPoints + 1) + f;\r\n                    const i4 = (d + 1) * (numberOfPoints + 1) + f + 1;\r\n                    // faces one and two\r\n                    indices.push(i3, i2, i1);\r\n                    indices.push(i2, i3, i4);\r\n                }\r\n            }\r\n            const attributes = {};\r\n            attributes['POSITION'] = new viewer_shared_types_1.AttributeData(new Float32Array(vertices), 3, 0, 0, 0, false, vertices.length / 3);\r\n            // to not compute normals ourselves, we just let three.js do it\r\n            // in our geometry loader, this array will cause the computation of vertex normals\r\n            attributes['NORMAL'] = new viewer_shared_types_1.AttributeData(new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), 3, 0, 0, 0, false, vertices.length / 3);\r\n            const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, new viewer_shared_types_1.AttributeData(this.convertToIndicesArray(indices), 1, 0, 0, 0, false, indices.length)), viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLES);\r\n            surfacepatchNode.data.push(geometry);\r\n            return surfacepatchNode;\r\n        });\r\n    }\r\n    loadScene() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const sceneNode = new viewer_shared_node_tree_1.TreeNode('sdgtf_content');\r\n            // arcs\r\n            if (this._content.arcs)\r\n                sceneNode.addChild(yield this.loadArcs());\r\n            // beziercurves\r\n            if (this._content.beziercurves) {\r\n                for (let beziercurve in this._content.beziercurves)\r\n                    sceneNode.addChild(yield this.loadBeziercurve(beziercurve));\r\n            }\r\n            // circles\r\n            if (this._content.circles)\r\n                sceneNode.addChild(yield this.loadCircles());\r\n            // cylinders\r\n            if (this._content.cylinders)\r\n                sceneNode.addChild(yield this.loadCylinders());\r\n            //points\r\n            if (this._content.points) {\r\n                for (let point in this._content.points)\r\n                    sceneNode.addChild(yield this.loadPoint(point));\r\n            }\r\n            // polylines\r\n            if (this._content.polylines) {\r\n                for (let line in this._content.polylines)\r\n                    sceneNode.addChild(yield this.loadPolyline(line));\r\n            }\r\n            // spheres\r\n            if (this._content.spheres)\r\n                sceneNode.addChild(yield this.loadSpheres());\r\n            // surfacepatches\r\n            if (this._content.surfacepatches) {\r\n                for (let surfacepatch in this._content.surfacepatches)\r\n                    sceneNode.addChild(yield this.loadSurfacepatch(surfacepatch));\r\n            }\r\n            return sceneNode;\r\n        });\r\n    }\r\n}\r\nexports.SDGTFLoader = SDGTFLoader;\r\n"},"sourceMaps":{"js":{"version":3,"file":"SDGTFLoader.js","sourceRoot":"","sources":["../../src/gltfv1/SDGTFLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import { ITreeNode, TreeNode } from '@shapediver/viewer.shared.node-tree'\r\nimport { Logger, ShapeDiverViewerDataProcessingError } from '@shapediver/viewer.shared.services'\r\nimport {\r\n  ACCESSORCOMPONENTTYPE_V1 as ACCESSOR_COMPONENTTYPE,\r\n  ACCESSORTYPE_V1 as ACCESSORTYPE,\r\n  ISDGTF_v1,\r\n} from '@shapediver/viewer.data-engine.shared-types'\r\nimport {\r\n  AttributeData,\r\n  GeometryData,\r\n  MaterialStandardData,\r\n  PRIMITIVE_MODE,\r\n  PrimitiveData,\r\n} from '@shapediver/viewer.shared.types'\r\nimport { mat4, vec3, vec4 } from 'gl-matrix'\r\n\r\nexport class SDGTFLoader {\r\n    // #region Properties (5)\r\n\r\n    private readonly BINARY_EXTENSION_HEADER_LENGTH = 20;\r\n    private readonly _logger: Logger = Logger.instance;\r\n\r\n    private _body!: ArrayBuffer;\r\n    private _content!: ISDGTF_v1;\r\n\r\n    // #endregion Properties (5)\r\n\r\n    // #region Public Methods (1)\r\n\r\n    public async load(binaryGeometry: ArrayBuffer, gltfLength: number): Promise<ITreeNode> {\r\n        if (gltfLength < binaryGeometry.byteLength) {\r\n            const headerDataView = new DataView(binaryGeometry, gltfLength, this.BINARY_EXTENSION_HEADER_LENGTH + 1);\r\n            const header = {\r\n                magic: String.fromCharCode(headerDataView.getUint8(0)) + String.fromCharCode(headerDataView.getUint8(1)) + String.fromCharCode(headerDataView.getUint8(2)) + String.fromCharCode(headerDataView.getUint8(3)) + String.fromCharCode(headerDataView.getUint8(4)),\r\n                version: headerDataView.getUint32(5, true),\r\n                length: headerDataView.getUint32(9, true),\r\n                contentLength: headerDataView.getUint32(13, true),\r\n                contentFormat: headerDataView.getUint32(17, true)\r\n            }\r\n            if (header.magic != 'sdgTF') \r\n                throw new ShapeDiverViewerDataProcessingError('SDGTFLoader.load: Invalid data: sdgTF magic wrong.');\r\n\r\n            // create content\r\n            const contentDataView = new DataView(binaryGeometry, gltfLength + this.BINARY_EXTENSION_HEADER_LENGTH + 1, header.contentLength);\r\n            const contentDecoded = new TextDecoder().decode(contentDataView);\r\n            this._content = JSON.parse(contentDecoded);\r\n            this._body = binaryGeometry.slice(gltfLength + this.BINARY_EXTENSION_HEADER_LENGTH + 1 + header.contentLength, gltfLength + header.length);\r\n        } else {\r\n            return new TreeNode();\r\n        }\r\n\r\n        return await this.loadScene();\r\n    }\r\n\r\n    // #endregion Public Methods (1)\r\n\r\n    // #region Private Methods (6)\r\n\r\n    private convertToIndicesArray(indices: number[]): Uint8Array | Uint16Array | Uint32Array {\r\n        const max = Math.max(0, ...indices);\r\n        if(max < (1 << 8) - 1) {\r\n            return new Uint8Array(indices);\r\n        } else if (max < (1 << 16) - 1) {\r\n            return new Uint16Array(indices);\r\n        } else {\r\n            return new Uint32Array(indices);\r\n        }\r\n    }\r\n\r\n    private async loadAccessor(accessorName: string): Promise<AttributeData> {\r\n        if (!this._content.accessors![accessorName]) throw new Error('Accessor not available.')\r\n        const accessor = this._content.accessors![accessorName];\r\n        const bufferView = this._body;\r\n\r\n        const itemSize = ACCESSORTYPE[<keyof typeof ACCESSORTYPE>accessor.type];\r\n        const ArrayType = ACCESSOR_COMPONENTTYPE[<keyof typeof ACCESSOR_COMPONENTTYPE>accessor.componentType];\r\n\r\n        const elementBytes = ArrayType.BYTES_PER_ELEMENT;\r\n        const itemBytes = elementBytes * itemSize;\r\n        const byteOffset = accessor.byteOffset || 0;\r\n\r\n        return new AttributeData(new ArrayType(bufferView, byteOffset, itemSize * accessor.count), itemSize, itemBytes, byteOffset, elementBytes, false, accessor.count);\r\n    }\r\n\r\n    private async loadArcs(): Promise<ITreeNode> {\r\n        if (!this._content.arcs) throw new Error('Arcs not available.')\r\n        const arc = this._content.arcs;\r\n        const arcNode = new TreeNode('arcs');\r\n\r\n        const data = await this.loadAccessor(arc.attributes['ARCS']);\r\n\r\n        // data with an absolute classic array of Vec12s ...\r\n        // like you usually have it in any good program\r\n        // not 4 Vec3s, no, that would be to logic, but a Vec12 instead\r\n\r\n        const count = data.array.length / data.itemSize;\r\n\r\n        for (let i = 0; i < count; ++i) {\r\n            const singleArcNode = new TreeNode('arc_' + i);\r\n\r\n            const index = i * 12;\r\n            const arcCenter = vec3.fromValues(data.array[index + 0], data.array[index + 1], data.array[index + 2]);\r\n            const arcXAxis = vec3.fromValues(data.array[index + 3], data.array[index + 4], data.array[index + 5]);\r\n            const arcYAxis = vec3.fromValues(data.array[index + 6], data.array[index + 7], data.array[index + 8]);\r\n            const arcRadius = data.array[index + 9];\r\n            const arcMinAngle = data.array[index + 10];\r\n            const arcMaxAngle = data.array[index + 11];\r\n            const arcZAxis = vec3.cross(vec3.create(), arcXAxis, arcYAxis)\r\n\r\n            if (arcRadius <= 0) {\r\n                this._logger.warn('SDGTFLoader.loadArcs: Arc radius is <= 0.');\r\n                continue;\r\n            }\r\n            const points: number[] = [];\r\n            const getPointOnArc = (t: number): void => {\r\n                const twoPi = Math.PI * 2;\r\n                let deltaAngle = arcMaxAngle - arcMinAngle;\r\n                const samePoints = Math.abs(deltaAngle) < Number.EPSILON;\r\n                // ensures that deltaAngle is 0 .. 2 PI\r\n                while (deltaAngle < 0) deltaAngle += twoPi;\r\n                while (deltaAngle > twoPi) deltaAngle -= twoPi;\r\n                deltaAngle = deltaAngle < Number.EPSILON ? samePoints ? 0 : twoPi : deltaAngle;\r\n                const angle = arcMinAngle + t * deltaAngle;\r\n                let x = arcRadius * Math.cos(angle);\r\n                let y = arcRadius * Math.sin(angle);\r\n                points.push(x, y, 0);\r\n            }\r\n\r\n            const numberOfPoints = Math.max(3, Math.round(50 * ((arcMaxAngle - arcMinAngle) / 2 * Math.PI)));\r\n            for (let d = 0; d <= numberOfPoints; d++)\r\n                getPointOnArc(d / numberOfPoints);\r\n\r\n            const array = new Float32Array(points);\r\n            const attributes: {\r\n                [key: string]: AttributeData\r\n            } = {};\r\n            attributes['POSITION'] = new AttributeData(array, 3, 0, 0, 0, false, array.length / 3)\r\n\r\n            const geometry = new GeometryData(new PrimitiveData(attributes, null), PRIMITIVE_MODE.LINE_STRIP);\r\n            singleArcNode.data.push(geometry);\r\n\r\n            singleArcNode.addTransformation({\r\n                id: 'arc_' + i + '_translation',\r\n                matrix: mat4.translate(mat4.create(), mat4.create(), vec3.fromValues(arcCenter[0], arcCenter[1], arcCenter[2]))\r\n            });\r\n\r\n            const arcRotationMatrix = mat4.transpose(mat4.create(), mat4.fromValues(\r\n                arcXAxis[0], arcYAxis[0], arcZAxis[0], 0,\r\n                arcXAxis[1], arcYAxis[1], arcZAxis[1], 0,\r\n                arcXAxis[2], arcYAxis[2], arcZAxis[2], 0,\r\n                0, 0, 0, 1\r\n            ));\r\n            singleArcNode.addTransformation({\r\n                id: 'arc_' + i + '_rotation',\r\n                matrix: arcRotationMatrix\r\n            });\r\n\r\n            arcNode.addChild(singleArcNode);\r\n        }\r\n        return arcNode;\r\n    }\r\n\r\n    private async loadBeziercurve(beziercurveName: string): Promise<ITreeNode> {\r\n        if (!this._content.beziercurves![beziercurveName]) throw new Error('Beziercurve not available.')\r\n        const beziercurve = this._content.beziercurves![beziercurveName];\r\n        const beziercurveNode = new TreeNode(beziercurveName);\r\n\r\n        const controlPointsData = await this.loadAccessor(beziercurve.attributes['CONTROLPOINTS']); // vec3\r\n        const controlPoints: vec4[] = [];\r\n        for (let i = 0; i < controlPointsData.array.length; i += 3)\r\n            controlPoints.push(vec4.fromValues(controlPointsData.array[i], controlPointsData.array[i + 1], controlPointsData.array[i + 2], 1));\r\n\r\n        const knotsData = await this.loadAccessor(beziercurve.attributes['KNOTS']); // scalar\r\n        const knots: number[] = [knotsData.array[0]];\r\n        for (let i = 0; i < knotsData.array.length; i++)\r\n            knots.push(knotsData.array[i]);\r\n        knots.push(knotsData.array[knotsData.array.length - 1])\r\n        const degree = beziercurve.degree;\r\n\r\n        const findSpan = (u: number): number => {\r\n            const n = knots.length - degree - 1;\r\n            if (u >= knots[n])\r\n                return n - 1;\r\n            if (u <= knots[degree])\r\n                return degree;\r\n\r\n            let low = degree;\r\n            let high = n;\r\n            let mid = Math.floor((low + high) / 2);\r\n\r\n            while (u < knots[mid] || u >= knots[mid + 1]) {\r\n                if (u < knots[mid]) {\r\n                    high = mid;\r\n                } else {\r\n                    low = mid;\r\n                }\r\n                mid = Math.floor((low + high) / 2);\r\n            }\r\n            return mid;\r\n        }\r\n\r\n        const calcBasisFunctions = (span: number, u: number) => {\r\n            const N = [];\r\n            const left = [];\r\n            const right = [];\r\n            N[0] = 1.0;\r\n\r\n            for (let j = 1; j <= degree; ++j) {\r\n                left[j] = u - knots[span + 1 - j];\r\n                right[j] = knots[span + j] - u;\r\n\r\n                let saved = 0.0;\r\n                for (let r = 0; r < j; ++r) {\r\n                    const rv = right[r + 1];\r\n                    const lv = left[j - r];\r\n                    const temp: number = N[r] / (rv + lv);\r\n                    N[r] = saved + rv * temp;\r\n                    saved = lv * temp;\r\n                }\r\n                N[j] = saved;\r\n            }\r\n            return N;\r\n        }\r\n\r\n        const calcBSplinePoint = (u: number): vec4 => {\r\n            const span = findSpan(u);\r\n            const N = calcBasisFunctions(span, u);\r\n            const C = vec4.create();\r\n            for (let j = 0; j <= degree; ++j) {\r\n                const point = controlPoints[span - degree + j];\r\n                const Nj = N[j];\r\n                const wNj = point[3] * Nj;\r\n                vec4.add(C, C, vec4.fromValues(point[0] * wNj, point[1] * wNj, point[2] * wNj, point[3] * Nj))\r\n            }\r\n            return C;\r\n        }\r\n\r\n        const points: number[] = [];\r\n        const getPointOnBezierCurve = (t: number): void => {\r\n            const u = knots[0] + t * (knots[knots.length - 1] - knots[0]); // linear mapping t->u\r\n            // following results in (wx, wy, wz, w) homogeneous point\r\n            let hpoint = calcBSplinePoint(u);\r\n            if (hpoint[3] !== 1.0) {\r\n                // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\r\n                hpoint = vec4.divide(vec4.create(), hpoint, vec4.fromValues(hpoint[3], hpoint[3], hpoint[3], hpoint[3]))\r\n            }\r\n            points.push(hpoint[0], hpoint[1], hpoint[2]);\r\n        }\r\n\r\n        // Number of points calculation\r\n        // We go through the control points, measure the distance\r\n        let distance = 0;\r\n        for (let i = 1; i < controlPoints.length; i++)\r\n            distance += vec3.distance(vec3.fromValues(controlPoints[i - 1][0], controlPoints[i - 1][1], controlPoints[i - 1][2]), vec3.fromValues(controlPoints[i][0], controlPoints[i][1], controlPoints[i][2]));\r\n\r\n        const numberOfPoints = Math.min(100, Math.max(25, Math.floor(distance / 0.1)));\r\n        for (let d = 0; d <= numberOfPoints; d++)\r\n            getPointOnBezierCurve(d / numberOfPoints);\r\n\r\n        const array = new Float32Array(points);\r\n        const attributes: {\r\n            [key: string]: AttributeData\r\n        } = {};\r\n        attributes['POSITION'] = new AttributeData(array, 3, 0, 0, 0, false, array.length / 3)\r\n\r\n        const geometry = new GeometryData(new PrimitiveData(attributes, null), PRIMITIVE_MODE.LINE_STRIP);\r\n        beziercurveNode.data.push(geometry);\r\n\r\n        return beziercurveNode;\r\n    }\r\n\r\n    private async loadCircles(): Promise<ITreeNode> {\r\n        if (!this._content.circles) throw new Error('Circles not available.')\r\n        const circle = this._content.circles;\r\n        const circleNode = new TreeNode('circles');\r\n\r\n        const data = await this.loadAccessor(circle.attributes['CIRCLES']);\r\n\r\n        const count = data.array.length / data.itemSize;\r\n        for (let i = 0; i < count; i++) {\r\n            const singleCircleNode = new TreeNode('circle_' + i);\r\n\r\n            const index = i * 10;\r\n            const circleCenter = vec3.fromValues(data.array[index + 0], data.array[index + 1], data.array[index + 2]);\r\n            const circleXAxis = vec3.fromValues(data.array[index + 3], data.array[index + 4], data.array[index + 5]);\r\n            const circleYAxis = vec3.fromValues(data.array[index + 6], data.array[index + 7], data.array[index + 8]);\r\n            const circleRadius = data.array[index + 9];\r\n            const circleZAxis = vec3.cross(vec3.create(), circleXAxis, circleYAxis)\r\n\r\n            if (circleRadius <= 0) {\r\n                this._logger.warn('SDGTFLoader.loadCircles: Circle radius is <= 0.');\r\n                continue;\r\n            }\r\n\r\n            const points: number[] = [];\r\n            const getPointOnArc = (t: number): void => {\r\n                const twoPi = Math.PI * 2;\r\n                let deltaAngle = 2.0 * Math.PI - 0;\r\n                const samePoints = Math.abs(deltaAngle) < Number.EPSILON;\r\n                // ensures that deltaAngle is 0 .. 2 PI\r\n                while (deltaAngle < 0) deltaAngle += twoPi;\r\n                while (deltaAngle > twoPi) deltaAngle -= twoPi;\r\n                deltaAngle = deltaAngle < Number.EPSILON ? samePoints ? 0 : twoPi : deltaAngle;\r\n                const angle = 0 + t * deltaAngle;\r\n                let x = circleRadius * Math.cos(angle);\r\n                let y = circleRadius * Math.sin(angle);\r\n                points.push(x, y, 0);\r\n            }\r\n\r\n            const numberOfPoints = 50;\r\n            for (let d = 0; d <= numberOfPoints; d++)\r\n                getPointOnArc(d / numberOfPoints);\r\n\r\n            const array = new Float32Array(points);\r\n            const attributes: {\r\n                [key: string]: AttributeData\r\n            } = {};\r\n            attributes['POSITION'] = new AttributeData(array, 3, 0, 0, 0, false, array.length / 3)\r\n\r\n            const geometry = new GeometryData(new PrimitiveData(attributes, null), PRIMITIVE_MODE.LINE_STRIP);\r\n            singleCircleNode.data.push(geometry);\r\n\r\n            singleCircleNode.addTransformation({\r\n                id: 'circle_' + i + '_translation',\r\n                matrix: mat4.translate(mat4.create(), mat4.create(), vec3.fromValues(circleCenter[0], circleCenter[1], circleCenter[2]))\r\n            });\r\n\r\n            const circleRotationMatrix = mat4.transpose(mat4.create(), mat4.fromValues(\r\n                circleXAxis[0], circleYAxis[0], circleZAxis[0], 0,\r\n                circleXAxis[1], circleYAxis[1], circleZAxis[1], 0,\r\n                circleXAxis[2], circleYAxis[2], circleZAxis[2], 0,\r\n                0, 0, 0, 1\r\n            ));\r\n            singleCircleNode.addTransformation({\r\n                id: 'circle_' + i + '_rotation',\r\n                matrix: circleRotationMatrix\r\n            });\r\n\r\n            circleNode.addChild(singleCircleNode);\r\n\r\n        }\r\n        return circleNode;\r\n    }\r\n\r\n    private async loadCylinders(): Promise<ITreeNode> {\r\n        if (!this._content.cylinders) throw new Error('Cylinders not available.')\r\n        const cylinder = this._content.cylinders;\r\n        const cylinderNode = new TreeNode('cylinders');\r\n\r\n        const data = await this.loadAccessor(cylinder.attributes['CYLINDERS']);\r\n\r\n        const count = data.array.length / data.itemSize;\r\n        for (let i = 0; i < count; i++) {\r\n            const singleCylinderNode = new TreeNode('cylinder_' + i);\r\n\r\n            const index = i * 7;\r\n            const cylinderTop = vec3.fromValues(data.array[index + 0], data.array[index + 1], data.array[index + 2]);\r\n            const cylinderBottom = vec3.fromValues(data.array[index + 3], data.array[index + 4], data.array[index + 5]);\r\n            const cylinderRadius = data.array[index + 6];\r\n            const cylinderAxis = vec3.sub(vec3.create(), cylinderTop, cylinderBottom)\r\n            const dotX = Math.abs(vec3.dot(cylinderAxis, vec3.fromValues(1, 0, 0)));\r\n            const dotY = Math.abs(vec3.dot(cylinderAxis, vec3.fromValues(0, 1, 0)));\r\n\r\n            let cylinderXAxis: vec3;\r\n            if (dotX < dotY) {\r\n                cylinderXAxis = vec3.cross(vec3.create(), cylinderAxis, vec3.fromValues(1, 0, 0));\r\n            } else {\r\n                cylinderXAxis = vec3.cross(vec3.create(), cylinderAxis, vec3.fromValues(0, 1, 0));\r\n\r\n            }\r\n            const cylinderYAxis = vec3.cross(vec3.create(), cylinderAxis, cylinderXAxis);\r\n\r\n            vec3.normalize(cylinderAxis, cylinderAxis);\r\n            vec3.normalize(cylinderXAxis, cylinderXAxis);\r\n            vec3.normalize(cylinderYAxis, cylinderYAxis);\r\n\r\n            if (cylinderRadius <= 0) {\r\n                this._logger.warn('SDGTFLoader.loadCylinders: Cylinder radius is <= 0.');\r\n                continue;\r\n            }\r\n\r\n            const indices: number[] = [];\r\n            const vertices: number[] = [];\r\n            const normals: number[] = [];\r\n            const uvs: number[] = [];\r\n\r\n\r\n            const height = vec3.distance(cylinderTop, cylinderBottom);\r\n            const halfHeight = height / 2;\r\n            const thetaStart = 0, thetaLength = Math.PI * 2\r\n            let indexCounter = 0;\r\n            const indexArray: number[][] = [];\r\n\r\n            const heightSegments = 1, radialSegments = 50;\r\n\r\n            const normal = vec3.create();\r\n            const vertex = vec3.create();\r\n            let groupCount = 0;\r\n            // this will be used to calculate the normal\r\n            const slope = 0;\r\n            // generate vertices, normals and uvs\r\n            for (let y = 0; y <= heightSegments; y++) {\r\n                const indexRow = [];\r\n                const v = y / heightSegments;\r\n                // calculate the radius of the current row\r\n                const radius = cylinderRadius;\r\n                for (let x = 0; x <= radialSegments; x++) {\r\n                    const u = x / radialSegments;\r\n                    const theta = u * thetaLength + thetaStart;\r\n                    const sinTheta = Math.sin(theta);\r\n                    const cosTheta = Math.cos(theta);\r\n                    // vertex\r\n                    vertex[0] = radius * sinTheta;\r\n                    vertex[1] = - v * height + halfHeight;\r\n                    vertex[2] = radius * cosTheta;\r\n                    vertices.push(vertex[0], vertex[1], vertex[2]);\r\n                    // normal\r\n                    vec3.normalize(normal, vec3.fromValues(sinTheta, slope, cosTheta))\r\n                    normals.push(normal[0], normal[1], normal[2]);\r\n                    // uv\r\n                    uvs.push(u, 1 - v);\r\n                    // save index of vertex in respective row\r\n                    indexRow.push(indexCounter++);\r\n                }\r\n                // now save vertices of the row in our index array\r\n                indexArray.push(indexRow);\r\n            }\r\n\r\n            // generate indices\r\n            for (let x = 0; x < radialSegments; x++) {\r\n                for (let y = 0; y < heightSegments; y++) {\r\n                    // we use the index array to access the correct indices\r\n                    const a = indexArray[y][x];\r\n                    const b = indexArray[y + 1][x];\r\n                    const c = indexArray[y + 1][x + 1];\r\n                    const d = indexArray[y][x + 1];\r\n                    // faces\r\n                    indices.push(a, b, d);\r\n                    indices.push(b, c, d);\r\n                    // update group counter\r\n                    groupCount += 6;\r\n                }\r\n            }\r\n\r\n            const attributes: {\r\n                [key: string]: AttributeData\r\n            } = {};\r\n            attributes['POSITION'] = new AttributeData(new Float32Array(vertices), 3, 0, 0, 0, false, vertices.length / 3)\r\n            attributes['NORMAL'] = new AttributeData(new Float32Array(normals), 3, 0, 0, 0, false, normals.length / 3)\r\n            attributes['TEXCOORD_0'] = new AttributeData(new Float32Array(uvs), 2, 0, 0, 0, false, uvs.length / 2)\r\n\r\n            const geometry = new GeometryData(new PrimitiveData(attributes, new AttributeData(this.convertToIndicesArray(indices), 1, 0, 0, 0, false, indices.length)), PRIMITIVE_MODE.TRIANGLES);\r\n            singleCylinderNode.data.push(geometry);\r\n\r\n            singleCylinderNode.addTransformation({\r\n                id: 'cylinder_' + i + '_translation',\r\n                matrix: mat4.translate(mat4.create(), mat4.create(), cylinderBottom)\r\n            });\r\n\r\n            const cylinderRotationMatrix = mat4.transpose(mat4.create(), mat4.fromValues(\r\n                cylinderXAxis[0], cylinderYAxis[0], cylinderAxis[0], 0,\r\n                cylinderXAxis[1], cylinderYAxis[1], cylinderAxis[1], 0,\r\n                cylinderXAxis[2], cylinderYAxis[2], cylinderAxis[2], 0,\r\n                0, 0, 0, 1\r\n            ));\r\n            singleCylinderNode.addTransformation({\r\n                id: 'cylinder_' + i + '_rotation',\r\n                matrix: cylinderRotationMatrix\r\n            });\r\n\r\n\r\n            singleCylinderNode.addTransformation({\r\n                id: 'cylinder_' + i + '_rotation2',\r\n                matrix: mat4.rotateX(mat4.create(), mat4.create(), 0.5 * Math.PI)\r\n            });\r\n            singleCylinderNode.addTransformation({\r\n                id: 'cylinder_' + i + '_translation2',\r\n                matrix: mat4.translate(mat4.create(), mat4.create(), vec3.fromValues(0, 0, 0.5 * vec3.distance(cylinderTop, cylinderBottom)))\r\n            });\r\n            cylinderNode.addChild(singleCylinderNode);\r\n\r\n        }\r\n        return cylinderNode;\r\n    }\r\n\r\n    private async loadSpheres(): Promise<ITreeNode> {\r\n        if (!this._content.spheres) throw new Error('Spheres not available.')\r\n        const sphere = this._content.spheres;\r\n        const sphereNode = new TreeNode('spheres');\r\n\r\n        const data = await this.loadAccessor(sphere.attributes['SPHERES']);\r\n\r\n        const count = data.array.length / data.itemSize;\r\n        for (let i = 0; i < count; i++) {\r\n            const singleSphereNode = new TreeNode('sphere_' + i);\r\n\r\n            const index = i * 4;\r\n            const sphereTranslation = vec3.fromValues(data.array[index + 0], data.array[index + 1], data.array[index + 2]);\r\n            const sphereRadius = data.array[index + 3];\r\n            if (sphereRadius <= 0) {\r\n                this._logger.warn('SDGTFLoader.loadSpheres: Sphere radius is <= 0.');\r\n                continue;\r\n            }\r\n\r\n            const indices: number[] = [];\r\n            const vertices: number[] = [];\r\n            const normals: number[] = [];\r\n            const uvs: number[] = [];\r\n            const grid: number[][] = [];\r\n\r\n            // for some reason, this doesn't work with values > 15\r\n            // let's not look into it, it's legacy stuff\r\n            const heightSegments = 15, widthSegments = 15;\r\n            const phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI;\r\n            const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\r\n\r\n            let indexCounter = 0;\r\n\r\n            // generate vertices, normals and uvs\r\n\r\n            for (let iy = 0; iy <= heightSegments; iy++) {\r\n                const verticesRow = [];\r\n                const v = iy / heightSegments;\r\n\r\n                // special case for the poles\r\n                let uOffset = 0;\r\n                if (iy == 0 && thetaStart == 0) {\r\n                    uOffset = 0.5 / widthSegments;\r\n                } else if (iy == heightSegments && thetaEnd == Math.PI) {\r\n                    uOffset = - 0.5 / widthSegments;\r\n                }\r\n                for (let ix = 0; ix <= widthSegments; ix++) {\r\n                    const u = ix / widthSegments;\r\n                    // vertex\r\n                    const vertex = vec3.fromValues(\r\n                        - sphereRadius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength),\r\n                        sphereRadius * Math.cos(thetaStart + v * thetaLength),\r\n                        sphereRadius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength)\r\n                    );\r\n                    vertices.push(vertex[0], vertex[1], vertex[2]);\r\n                    // normal\r\n                    const normal = vec3.normalize(vec3.create(), vertex);\r\n                    normals.push(normal[0], normal[1], normal[2]);\r\n                    // uv\r\n                    uvs.push(u + uOffset, 1 - v);\r\n                    verticesRow.push(indexCounter++);\r\n                }\r\n                grid.push(verticesRow);\r\n            }\r\n\r\n            // indices\r\n            for (let iy = 0; iy < heightSegments; iy++) {\r\n                for (let ix = 0; ix < widthSegments; ix++) {\r\n                    const a = grid[iy][ix + 1];\r\n                    const b = grid[iy][ix];\r\n                    const c = grid[iy + 1][ix];\r\n                    const d = grid[iy + 1][ix + 1];\r\n                    if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);\r\n                    if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);\r\n                }\r\n            }\r\n\r\n            const attributes: {\r\n                [key: string]: AttributeData\r\n            } = {};\r\n            attributes['POSITION'] = new AttributeData(new Float32Array(vertices), 3, 0, 0, 0, false, vertices.length / 3)\r\n            attributes['NORMAL'] = new AttributeData(new Float32Array(normals), 3, 0, 0, 0, false, normals.length / 3)\r\n            attributes['TEXCOORD_0'] = new AttributeData(new Float32Array(uvs), 2, 0, 0, 0, false, uvs.length / 2)\r\n\r\n            const geometry = new GeometryData(new PrimitiveData(attributes, new AttributeData(this.convertToIndicesArray(indices), 1, 0, 0, 0, false, indices.length)), PRIMITIVE_MODE.TRIANGLES);\r\n            singleSphereNode.data.push(geometry);\r\n\r\n            singleSphereNode.addTransformation({\r\n                id: 'sphere_' + i + '_translation',\r\n                matrix: mat4.translate(mat4.create(), mat4.create(), sphereTranslation)\r\n            });\r\n            sphereNode.addChild(singleSphereNode);\r\n\r\n        }\r\n        return sphereNode;\r\n    }\r\n\r\n    private async loadPoint(pointName: string): Promise<ITreeNode> {\r\n        if (!this._content.points![pointName]) throw new Error('Point not available.')\r\n        const point = this._content.points![pointName];\r\n        const pointNode = new TreeNode(pointName);\r\n\r\n        const attributes: {\r\n            [key: string]: AttributeData\r\n        } = {};\r\n\r\n        const data = await this.loadAccessor(point.attributes['POINTS']);\r\n        attributes['POSITION'] = new AttributeData(data.array, 3, data.itemBytes, data.byteOffset, data.elementBytes, data.normalized, data.count)\r\n\r\n        const geometry = new GeometryData(new PrimitiveData(attributes, null), PRIMITIVE_MODE.POINTS);\r\n        pointNode.data.push(geometry);\r\n\r\n        return pointNode;\r\n    }\r\n\r\n    private async loadPolyline(polylineName: string): Promise<ITreeNode> {\r\n        if (!this._content.polylines![polylineName]) throw new Error('Polyline not available.')\r\n        const polyLine = this._content.polylines![polylineName];\r\n        const polyLineNode = new TreeNode(polylineName);\r\n\r\n        const attributes: {\r\n            [key: string]: AttributeData\r\n        } = {};\r\n\r\n        const data = await this.loadAccessor(polyLine.attributes['VERTICES']);\r\n        attributes['POSITION'] = new AttributeData(data.array, 3, data.itemBytes, data.byteOffset, data.elementBytes, data.normalized, data.count)\r\n\r\n        const geometry = new GeometryData(new PrimitiveData(attributes, null), PRIMITIVE_MODE.LINE_STRIP);\r\n        polyLineNode.data.push(geometry);\r\n\r\n        return polyLineNode;\r\n    }\r\n\r\n    private async loadSurfacepatch(surfacepatchName: string): Promise<ITreeNode> {\r\n        if (!this._content.surfacepatches![surfacepatchName]) throw new Error('Surfacepatch not available.')\r\n        const surfacepatch = this._content.surfacepatches![surfacepatchName];\r\n        const surfacepatchNode = new TreeNode(surfacepatchName);\r\n\r\n        const controlPointCountU = surfacepatch.controlPointCountU;\r\n        const controlPointCountV = surfacepatch.controlPointCountV;\r\n\r\n        const controlPointsData = await this.loadAccessor(surfacepatch.attributes['CONTROLPOINTS']); // vec3\r\n        const controlPoints: vec4[][] = [];\r\n        let pointCount = 0;\r\n        for (let u = 0; u < controlPointCountU; u++) {\r\n            let innerArray = []\r\n            for (let v = 0; v < controlPointCountV; v++) {\r\n                innerArray.push(vec4.fromValues(controlPointsData.array[pointCount * 3], controlPointsData.array[pointCount * 3 + 1], controlPointsData.array[pointCount * 3 + 2], 1));\r\n                pointCount++;\r\n            }\r\n            controlPoints.push(innerArray);\r\n        }\r\n\r\n        const knotsUData = await this.loadAccessor(surfacepatch.attributes['KNOTSU']); // scalar\r\n        const knotsU: number[] = [knotsUData.array[0]];\r\n        for (let i = 0; i < knotsUData.array.length; i++)\r\n            knotsU.push(knotsUData.array[i]);\r\n        knotsU.push(knotsUData.array[knotsUData.array.length - 1])\r\n\r\n        const knotsVData = await this.loadAccessor(surfacepatch.attributes['KNOTSV']); // scalar\r\n        const knotsV: number[] = [knotsVData.array[0]];\r\n        for (let i = 0; i < knotsVData.array.length; i++)\r\n            knotsV.push(knotsVData.array[i]);\r\n        knotsV.push(knotsVData.array[knotsVData.array.length - 1])\r\n\r\n        const degreeU = surfacepatch.degreeU;\r\n        const degreeV = surfacepatch.degreeV;\r\n\r\n        const findSpan = (knots: number[], degree: number, u: number): number => {\r\n            const n = knots.length - degree - 1;\r\n            if (u >= knots[n])\r\n                return n - 1;\r\n            if (u <= knots[degree])\r\n                return degree;\r\n\r\n            let low = degree;\r\n            let high = n;\r\n            let mid = Math.floor((low + high) / 2);\r\n\r\n            while (u < knots[mid] || u >= knots[mid + 1]) {\r\n                if (u < knots[mid]) {\r\n                    high = mid;\r\n                } else {\r\n                    low = mid;\r\n                }\r\n                mid = Math.floor((low + high) / 2);\r\n            }\r\n            return mid;\r\n        }\r\n\r\n        const calcBasisFunctions = (knots: number[], degree: number, span: number, u: number) => {\r\n            const N = [];\r\n            const left = [];\r\n            const right = [];\r\n            N[0] = 1.0;\r\n\r\n            for (let j = 1; j <= degree; ++j) {\r\n                left[j] = u - knots[span + 1 - j];\r\n                right[j] = knots[span + j] - u;\r\n\r\n                let saved = 0.0;\r\n                for (let r = 0; r < j; ++r) {\r\n                    const rv = right[r + 1];\r\n                    const lv = left[j - r];\r\n                    const temp: number = N[r] / (rv + lv);\r\n                    N[r] = saved + rv * temp;\r\n                    saved = lv * temp;\r\n                }\r\n                N[j] = saved;\r\n            }\r\n            return N;\r\n        }\r\n\r\n        const calcSurfacePoint = (u: number, v: number): vec3 => {\r\n\r\n            const uspan = findSpan(knotsU, degreeU, u);\r\n            const vspan = findSpan(knotsV, degreeV, v);\r\n            const Nu = calcBasisFunctions(knotsU, degreeU, uspan, u);\r\n            const Nv = calcBasisFunctions(knotsV, degreeV, vspan, v);\r\n            const temp: vec4[] = [];\r\n\r\n            for (let l = 0; l <= degreeV; ++l) {\r\n\r\n                temp[l] = vec4.create();\r\n                for (let k = 0; k <= degreeU; ++k) {\r\n\r\n                    const point = vec4.clone(controlPoints[uspan - degreeU + k][vspan - degreeV + l]);\r\n                    const w = point[3];\r\n                    point[0] *= w;\r\n                    point[1] *= w;\r\n                    point[2] *= w;\r\n                    vec4.add(temp[l], temp[l], vec4.multiply(vec4.create(), point, vec4.fromValues(Nu[k], Nu[k], Nu[k], Nu[k])))\r\n                }\r\n            }\r\n\r\n            const Sw = vec4.create();\r\n            for (let l = 0; l <= degreeV; ++l) {\r\n                vec4.add(Sw, Sw, vec4.multiply(vec4.create(), temp[l], vec4.fromValues(Nv[l], Nv[l], Nv[l], Nv[l])))\r\n            }\r\n\r\n            vec4.divide(Sw, Sw, vec4.fromValues(Sw[3], Sw[3], Sw[3], Sw[3]))\r\n            return vec3.fromValues(Sw[0], Sw[1], Sw[2]);\r\n        }\r\n\r\n        const getPointOnSurfacepatch = (t1: number, t2: number): vec3 => {\r\n            const u = knotsU[0] + t1 * (knotsU[knotsU.length - 1] - knotsU[0]); // linear mapping t1->u\r\n            const v = knotsV[0] + t2 * (knotsV[knotsV.length - 1] - knotsV[0]); // linear mapping t2->u\r\n            return calcSurfacePoint(u, v);\r\n        }\r\n\r\n        const numberOfPoints = 15;\r\n\r\n        const indices: number[] = [];\r\n        const vertices = [];\r\n\r\n        for (let d = 0; d <= numberOfPoints; d++) {\r\n            const v = d / numberOfPoints;\r\n            for (let f = 0; f <= numberOfPoints; f++) {\r\n                const u = f / numberOfPoints;\r\n                const vertex = getPointOnSurfacepatch(u, v);\r\n                vertices.push(vertex[0], vertex[1], vertex[2]);\r\n            }\r\n        }\r\n\r\n        for (let d = 0; d < numberOfPoints; d++) {\r\n            for (let f = 0; f < numberOfPoints; f++) {\r\n                const i1 = d * (numberOfPoints + 1) + f;\r\n                const i2 = d * (numberOfPoints + 1) + f + 1;\r\n                const i3 = (d+1) * (numberOfPoints + 1) + f;\r\n                const i4 = (d+1) * (numberOfPoints + 1) + f + 1;\r\n                // faces one and two\r\n                indices.push(i3, i2, i1);\r\n                indices.push(i2, i3, i4);\r\n            }\r\n        }\r\n\r\n        const attributes: {\r\n            [key: string]: AttributeData\r\n        } = {};\r\n        attributes['POSITION'] = new AttributeData(new Float32Array(vertices), 3, 0, 0, 0, false, vertices.length / 3);\r\n        // to not compute normals ourselves, we just let three.js do it\r\n        // in our geometry loader, this array will cause the computation of vertex normals\r\n        attributes['NORMAL'] = new AttributeData(new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), 3, 0, 0, 0, false, vertices.length / 3);\r\n        \r\n        const geometry = new GeometryData(new PrimitiveData(attributes, new AttributeData(this.convertToIndicesArray(indices), 1, 0, 0, 0, false, indices.length)), PRIMITIVE_MODE.TRIANGLES);\r\n        surfacepatchNode.data.push(geometry);\r\n\r\n        return surfacepatchNode;\r\n    }\r\n\r\n\r\n    private async loadScene(): Promise<ITreeNode> {\r\n        const sceneNode = new TreeNode('sdgtf_content');\r\n\r\n        // arcs\r\n        if (this._content.arcs)\r\n            sceneNode.addChild(await this.loadArcs());\r\n\r\n        // beziercurves\r\n        if (this._content.beziercurves) {\r\n            for (let beziercurve in this._content.beziercurves)\r\n                sceneNode.addChild(await this.loadBeziercurve(beziercurve));\r\n        }\r\n\r\n        // circles\r\n        if (this._content.circles)\r\n            sceneNode.addChild(await this.loadCircles());\r\n\r\n        // cylinders\r\n        if (this._content.cylinders)\r\n            sceneNode.addChild(await this.loadCylinders());\r\n\r\n        //points\r\n        if (this._content.points) {\r\n            for (let point in this._content.points)\r\n                sceneNode.addChild(await this.loadPoint(point));\r\n        }\r\n\r\n        // polylines\r\n        if (this._content.polylines) {\r\n            for (let line in this._content.polylines)\r\n                sceneNode.addChild(await this.loadPolyline(line));\r\n        }\r\n\r\n        // spheres\r\n        if (this._content.spheres)\r\n            sceneNode.addChild(await this.loadSpheres());\r\n\r\n        // surfacepatches\r\n        if (this._content.surfacepatches) {\r\n            for (let surfacepatch in this._content.surfacepatches)\r\n                sceneNode.addChild(await this.loadSurfacepatch(surfacepatch));\r\n        }\r\n        return sceneNode;\r\n    }\r\n\r\n    // #endregion Private Methods (6)\r\n}"]}},"error":null,"hash":"b7caa7e63ebe6c6ccfac1f8101cc9856","cacheData":{"env":{}}}