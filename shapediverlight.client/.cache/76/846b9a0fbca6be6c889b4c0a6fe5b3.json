{"id":"node_modules/@shapediver/viewer.rendering-engine.animation-engine/dist/implementation/AnimationEngine.js","dependencies":[{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.animation-engine\\dist\\implementation\\AnimationEngine.js.map","includedInParent":true,"mtime":1706542084613},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.animation-engine\\src\\implementation\\AnimationEngine.ts","includedInParent":true,"mtime":1706542085186},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\package.json","includedInParent":true,"mtime":1706542184022},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.animation-engine\\package.json","includedInParent":true,"mtime":1706542084235},{"name":"gl-matrix","loc":{"line":4,"column":28,"index":142},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.animation-engine\\dist\\implementation\\AnimationEngine.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\gl-matrix\\esm\\index.js"},{"name":"@shapediver/viewer.shared.node-tree","loc":{"line":5,"column":42,"index":199},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.animation-engine\\dist\\implementation\\AnimationEngine.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.node-tree\\dist\\index.js"},{"name":"@shapediver/viewer.shared.types","loc":{"line":6,"column":38,"index":278},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.animation-engine\\dist\\implementation\\AnimationEngine.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.types\\dist\\index.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AnimationEngine = void 0;\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nclass AnimationEngine {\r\n    constructor() {\r\n        // #region Properties (3)\r\n        this._tree = viewer_shared_node_tree_1.Tree.instance;\r\n        this._animations = {};\r\n        // #endregion Private Methods (1)\r\n    }\r\n    // #endregion Properties (3)\r\n    // #region Public Static Accessors (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Accessors (1)\r\n    // #region Public Accessors (1)\r\n    get animations() {\r\n        return this._animations;\r\n    }\r\n    // #endregion Public Accessors (1)\r\n    // #region Public Methods (3)\r\n    init() { }\r\n    update(deltaTime) {\r\n        const animations = Object.values(this._animations);\r\n        let running = false;\r\n        for (let i = 0; i < animations.length; i++) {\r\n            const animation = animations[i];\r\n            if (animation.animationTime === -1) {\r\n                // if we just stopped we need to render one more time\r\n                running = true;\r\n                animation.animationTime = 0;\r\n            }\r\n            if (!animation.animate)\r\n                continue;\r\n            running = true;\r\n            animation.animationTime += deltaTime;\r\n            if (animation.animationTime / 1000.0 > animation.duration) {\r\n                if (animation.repeat) {\r\n                    animation.startAnimation();\r\n                }\r\n                else {\r\n                    animation.stopAnimation();\r\n                }\r\n            }\r\n            const animationDuration = animation.duration;\r\n            const currentAnimationDeltaTime = (animation.animationTime / 1000.0) % animationDuration;\r\n            for (let j = 0; j < animation.tracks.length; j++) {\r\n                const track = animation.tracks[j];\r\n                const id = animation.id + '_' + j;\r\n                if (currentAnimationDeltaTime < track.times[0] || currentAnimationDeltaTime > track.times[track.times.length - 1])\r\n                    continue;\r\n                for (let k = 1; k < track.times.length; k++) {\r\n                    if (currentAnimationDeltaTime < track.times[k] && currentAnimationDeltaTime > track.times[k - 1]) {\r\n                        const prevAnimation = track.node.transformations.filter(t => t.id === id);\r\n                        track.node.transformations = track.node.transformations.filter((el) => {\r\n                            return !prevAnimation.includes(el);\r\n                        });\r\n                        const factor = (currentAnimationDeltaTime - track.times[k - 1]) / (track.times[k] - track.times[k - 1]);\r\n                        let translationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');\r\n                        if (!translationTransformation) {\r\n                            translationTransformation = {\r\n                                id: 'gltf_matrix_translation',\r\n                                matrix: gl_matrix_1.mat4.create()\r\n                            };\r\n                            track.node.transformations.push(translationTransformation);\r\n                        }\r\n                        let rotationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');\r\n                        if (!rotationTransformation) {\r\n                            rotationTransformation = {\r\n                                id: 'gltf_matrix_rotation',\r\n                                matrix: gl_matrix_1.mat4.create()\r\n                            };\r\n                            track.node.transformations.push(rotationTransformation);\r\n                        }\r\n                        let scaleTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');\r\n                        if (!scaleTransformation) {\r\n                            scaleTransformation = {\r\n                                id: 'gltf_matrix_scale',\r\n                                matrix: gl_matrix_1.mat4.create()\r\n                            };\r\n                            track.node.transformations.push(scaleTransformation);\r\n                        }\r\n                        if (track.path === 'rotation') {\r\n                            let pivotMatrix, pivotMatrixInverse;\r\n                            if (track.pivot) {\r\n                                pivotMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(track.pivot[0], track.pivot[1], track.pivot[2]));\r\n                                pivotMatrixInverse = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(-track.pivot[0], -track.pivot[1], -track.pivot[2]));\r\n                            }\r\n                            let quaternion;\r\n                            if (track.interpolation === 'step') {\r\n                                quaternion = gl_matrix_1.quat.fromValues(track.values[(k - 1) * 4 + 0], track.values[(k - 1) * 4 + 1], track.values[(k - 1) * 4 + 2], track.values[(k - 1) * 4 + 3]);\r\n                            }\r\n                            else {\r\n                                quaternion = gl_matrix_1.quat.slerp(gl_matrix_1.vec4.create(), gl_matrix_1.vec4.fromValues(track.values[(k - 1) * 4 + 0], track.values[(k - 1) * 4 + 1], track.values[(k - 1) * 4 + 2], track.values[(k - 1) * 4 + 3]), gl_matrix_1.vec4.fromValues(track.values[(k) * 4 + 0], track.values[(k) * 4 + 1], track.values[(k) * 4 + 2], track.values[(k) * 4 + 3]), factor);\r\n                            }\r\n                            const rotationMatrix = gl_matrix_1.mat4.fromQuat(gl_matrix_1.mat4.create(), quaternion);\r\n                            if (pivotMatrix && pivotMatrixInverse) {\r\n                                rotationTransformation.matrix = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), pivotMatrix, rotationMatrix), pivotMatrixInverse);\r\n                            }\r\n                            else {\r\n                                rotationTransformation.matrix = rotationMatrix;\r\n                            }\r\n                        }\r\n                        else if (track.path === 'translation') {\r\n                            let vector;\r\n                            if (track.interpolation === 'step') {\r\n                                vector = gl_matrix_1.vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]);\r\n                            }\r\n                            else {\r\n                                vector = gl_matrix_1.vec3.lerp(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]), gl_matrix_1.vec3.fromValues(track.values[(k) * 3 + 0], track.values[(k) * 3 + 1], track.values[(k) * 3 + 2]), factor);\r\n                            }\r\n                            translationTransformation.matrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), vector);\r\n                        }\r\n                        else if (track.path === 'scale') {\r\n                            let pivotMatrix, pivotMatrixInverse;\r\n                            if (track.pivot) {\r\n                                pivotMatrix = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(track.pivot[0], track.pivot[1], track.pivot[2]));\r\n                                pivotMatrixInverse = gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(-track.pivot[0], -track.pivot[1], -track.pivot[2]));\r\n                            }\r\n                            let vector;\r\n                            if (track.interpolation === 'step') {\r\n                                vector = gl_matrix_1.vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]);\r\n                            }\r\n                            else {\r\n                                vector = gl_matrix_1.vec3.lerp(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]), gl_matrix_1.vec3.fromValues(track.values[(k) * 3 + 0], track.values[(k) * 3 + 1], track.values[(k) * 3 + 2]), factor);\r\n                            }\r\n                            const scalingMatrix = gl_matrix_1.mat4.fromScaling(gl_matrix_1.mat4.create(), vector);\r\n                            if (pivotMatrix && pivotMatrixInverse) {\r\n                                scaleTransformation.matrix = gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.multiply(gl_matrix_1.mat4.create(), pivotMatrix, scalingMatrix), pivotMatrixInverse);\r\n                            }\r\n                            else {\r\n                                scaleTransformation.matrix = scalingMatrix;\r\n                            }\r\n                        }\r\n                        else if (track.path === 'weights') {\r\n                            let weights = [];\r\n                            const weightCount = track.values.length / track.times.length;\r\n                            if (track.interpolation === 'step') {\r\n                                for (let l = 0; l < weightCount; l++)\r\n                                    weights.push(track.values[(k - 1) * weightCount + l]);\r\n                            }\r\n                            else {\r\n                                for (let l = 0; l < weightCount; l++)\r\n                                    weights.push(track.values[(k - 1) * weightCount + l] * (1.0 - factor) + (factor) * track.values[(k - 1) * weightCount + l]);\r\n                            }\r\n                            const applyWeights = (node) => {\r\n                                for (let l = 0; l < node.data.length; l++)\r\n                                    if (node.data[l] instanceof viewer_shared_types_1.GeometryData && node.data[l].morphWeights.length === weightCount)\r\n                                        node.data[l].morphWeights = weights;\r\n                                for (let l = 0; l < node.children.length; l++)\r\n                                    applyWeights(node.children[l]);\r\n                            };\r\n                            applyWeights(track.node);\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return running;\r\n    }\r\n    updateAnimationData() {\r\n        this._animations = {};\r\n        const animationArray = this.gatherAnimations();\r\n        const names = animationArray.map(a => a.name);\r\n        for (let i = 0; i < animationArray.length; i++) {\r\n            const animationName = animationArray[i].name;\r\n            const nameIndices = [];\r\n            for (let j = 0; j < names.length; j++)\r\n                if (animationName === names[j])\r\n                    nameIndices.push(j);\r\n            let animationNameAdjusted = animationName;\r\n            // name adjustement if the name occurs multiple times\r\n            if (nameIndices.length > 1) {\r\n                animationNameAdjusted = animationName + '_' + nameIndices.indexOf(i);\r\n                // even further name adjustement if the name is even then the same after adjustements (probably will never happen)\r\n                while (names.includes(animationNameAdjusted))\r\n                    animationNameAdjusted += \"_0\";\r\n            }\r\n            this._animations[animationNameAdjusted] = animationArray[i];\r\n        }\r\n    }\r\n    // #endregion Public Methods (3)\r\n    // #region Private Methods (1)\r\n    gatherAnimations(node = this._tree.root) {\r\n        let out = [];\r\n        for (let i = 0, len = node.data.length; i < len; i++)\r\n            if (node.data[i] instanceof viewer_shared_types_1.AnimationData)\r\n                out.push(node.data[i]);\r\n        for (let i = 0, len = node.children.length; i < len; i++)\r\n            out = out.concat(this.gatherAnimations(node.children[i]));\r\n        return out;\r\n    }\r\n}\r\nexports.AnimationEngine = AnimationEngine;\r\n"},"sourceMaps":{"js":{"version":3,"file":"AnimationEngine.js","sourceRoot":"","sources":["../../src/implementation/AnimationEngine.ts"],"names":[],"mappings":"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","sourcesContent":["import { mat4, quat, vec3, vec4 } from 'gl-matrix'\r\nimport { ITree, ITreeNode, Tree } from '@shapediver/viewer.shared.node-tree'\r\nimport { AnimationData, GeometryData, IAnimationData } from '@shapediver/viewer.shared.types'\r\nimport { IManager } from '@shapediver/viewer.rendering-engine.rendering-engine';\r\nimport { IAnimationEngine } from '../interfaces/IAnimationEngine';\r\n\r\nexport class AnimationEngine implements IManager, IAnimationEngine {\r\n    // #region Properties (3)\r\n\r\n    private readonly _tree: ITree = Tree.instance;\r\n\r\n    private static _instance: AnimationEngine;\r\n\r\n    private _animations: {\r\n        [key: string]: IAnimationData\r\n    } = {};\r\n\r\n    // #endregion Properties (3)\r\n\r\n    // #region Public Static Accessors (1)\r\n\r\n    public static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n\r\n    // #endregion Public Static Accessors (1)\r\n\r\n    // #region Public Accessors (1)\r\n\r\n    public get animations(): {\r\n        [key: string]: IAnimationData\r\n    } \r\n    {\r\n        return this._animations;\r\n    }\r\n\r\n    // #endregion Public Accessors (1)\r\n\r\n    // #region Public Methods (3)\r\n\r\n    public init(): void { }\r\n\r\n    public update(deltaTime: number): boolean {\r\n        const animations = Object.values(this._animations);\r\n        let running = false;\r\n\r\n        for (let i = 0; i < animations.length; i++) {\r\n            const animation = animations[i];\r\n            if (animation.animationTime === -1) {\r\n                // if we just stopped we need to render one more time\r\n                running = true;\r\n                animation.animationTime = 0;\r\n            }\r\n            if (!animation.animate) continue;\r\n            running = true;\r\n\r\n            animation.animationTime += deltaTime;\r\n            if (animation.animationTime / 1000.0 > animation.duration) {\r\n                if (animation.repeat) {\r\n                    animation.startAnimation();\r\n                } else {\r\n                    animation.stopAnimation();\r\n                }\r\n            }\r\n\r\n            const animationDuration = animation.duration!;\r\n            const currentAnimationDeltaTime = (animation.animationTime / 1000.0) % animationDuration;\r\n\r\n            for (let j = 0; j < animation.tracks.length; j++) {\r\n                const track = animation.tracks[j];\r\n                const id = animation.id + '_' + j;\r\n                if (currentAnimationDeltaTime < track.times[0] || currentAnimationDeltaTime > track.times[track.times.length - 1]) continue;\r\n\r\n                for (let k = 1; k < track.times.length; k++) {\r\n                    if (currentAnimationDeltaTime < track.times[k] && currentAnimationDeltaTime > track.times[k - 1]) {\r\n                        const prevAnimation = track.node.transformations.filter(t => t.id === id);\r\n                        track.node.transformations = track.node.transformations.filter((el) => {\r\n                            return !prevAnimation.includes(el);\r\n                        });\r\n\r\n                        const factor = (currentAnimationDeltaTime - track.times[k - 1]) / (track.times[k] - track.times[k - 1]);\r\n\r\n                        let translationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_translation');\r\n                        if (!translationTransformation) {\r\n                            translationTransformation = {\r\n                                id: 'gltf_matrix_translation',\r\n                                matrix: mat4.create()\r\n                            }\r\n                            track.node.transformations.push(translationTransformation)\r\n                        }\r\n\r\n                        let rotationTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_rotation');\r\n                        if (!rotationTransformation) {\r\n                            rotationTransformation = {\r\n                                id: 'gltf_matrix_rotation',\r\n                                matrix: mat4.create()\r\n                            }\r\n                            track.node.transformations.push(rotationTransformation)\r\n                        }\r\n\r\n                        let scaleTransformation = track.node.transformations.find(t => t.id === 'gltf_matrix_scale');\r\n                        if (!scaleTransformation) {\r\n                            scaleTransformation = {\r\n                                id: 'gltf_matrix_scale',\r\n                                matrix: mat4.create()\r\n                            }\r\n                            track.node.transformations.push(scaleTransformation)\r\n                        }\r\n\r\n                        if (track.path === 'rotation') {\r\n                            let pivotMatrix: mat4 | undefined, pivotMatrixInverse: mat4 | undefined;\r\n                            if (track.pivot) {\r\n                                pivotMatrix = mat4.fromTranslation(mat4.create(), vec3.fromValues(track.pivot[0], track.pivot[1], track.pivot[2]));\r\n                                pivotMatrixInverse = mat4.fromTranslation(mat4.create(), vec3.fromValues(-track.pivot[0], -track.pivot[1], -track.pivot[2]));\r\n                            }\r\n\r\n                            let quaternion: quat;\r\n                            if (track.interpolation === 'step') {\r\n                                quaternion = quat.fromValues(track.values[(k - 1) * 4 + 0], track.values[(k - 1) * 4 + 1], track.values[(k - 1) * 4 + 2], track.values[(k - 1) * 4 + 3]);\r\n                            } else {\r\n                                quaternion = quat.slerp(\r\n                                    vec4.create(),\r\n                                    vec4.fromValues(track.values[(k - 1) * 4 + 0], track.values[(k - 1) * 4 + 1], track.values[(k - 1) * 4 + 2], track.values[(k - 1) * 4 + 3]),\r\n                                    vec4.fromValues(track.values[(k) * 4 + 0], track.values[(k) * 4 + 1], track.values[(k) * 4 + 2], track.values[(k) * 4 + 3]),\r\n                                    factor)\r\n                            }\r\n\r\n                            const rotationMatrix = mat4.fromQuat(mat4.create(), quaternion);\r\n                            if (pivotMatrix && pivotMatrixInverse) {\r\n                                rotationTransformation.matrix = mat4.multiply(mat4.create(), mat4.multiply(mat4.create(), pivotMatrix, rotationMatrix), pivotMatrixInverse);\r\n                            } else {\r\n                                rotationTransformation.matrix = rotationMatrix;\r\n                            }\r\n                        } else if (track.path === 'translation') {\r\n                            let vector: vec3;\r\n                            if (track.interpolation === 'step') {\r\n                                vector = vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]);\r\n                            } else {\r\n                                vector = vec3.lerp(\r\n                                    vec3.create(),\r\n                                    vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]),\r\n                                    vec3.fromValues(track.values[(k) * 3 + 0], track.values[(k) * 3 + 1], track.values[(k) * 3 + 2]),\r\n                                    factor)\r\n                            }\r\n                            translationTransformation.matrix = mat4.fromTranslation(mat4.create(), vector);\r\n                        } else if (track.path === 'scale') {\r\n                            let pivotMatrix: mat4 | undefined, pivotMatrixInverse: mat4 | undefined;\r\n                            if (track.pivot) {\r\n                                pivotMatrix = mat4.fromTranslation(mat4.create(), vec3.fromValues(track.pivot[0], track.pivot[1], track.pivot[2]));\r\n                                pivotMatrixInverse = mat4.fromTranslation(mat4.create(), vec3.fromValues(-track.pivot[0], -track.pivot[1], -track.pivot[2]));\r\n                            }\r\n\r\n                            let vector: vec3;\r\n                            if (track.interpolation === 'step') {\r\n                                vector = vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]);\r\n                            } else {\r\n                                vector = vec3.lerp(\r\n                                    vec3.create(),\r\n                                    vec3.fromValues(track.values[(k - 1) * 3 + 0], track.values[(k - 1) * 3 + 1], track.values[(k - 1) * 3 + 2]),\r\n                                    vec3.fromValues(track.values[(k) * 3 + 0], track.values[(k) * 3 + 1], track.values[(k) * 3 + 2]),\r\n                                    factor)\r\n                            }\r\n\r\n                            const scalingMatrix = mat4.fromScaling(mat4.create(), vector);\r\n                            if (pivotMatrix && pivotMatrixInverse) {\r\n                                scaleTransformation.matrix = mat4.multiply(mat4.create(), mat4.multiply(mat4.create(), pivotMatrix, scalingMatrix), pivotMatrixInverse);\r\n                            } else {\r\n                                scaleTransformation.matrix = scalingMatrix;\r\n                            }\r\n                        } else if (track.path === 'weights') {\r\n                            let weights: number[] = [];\r\n                            const weightCount = track.values.length / track.times.length;\r\n\r\n                            if (track.interpolation === 'step') {\r\n                                for (let l = 0; l < weightCount; l++)\r\n                                    weights.push(track.values[(k - 1) * weightCount + l])\r\n                            } else {\r\n                                for (let l = 0; l < weightCount; l++)\r\n                                    weights.push(track.values[(k - 1) * weightCount + l] * (1.0 - factor) + (factor) * track.values[(k - 1) * weightCount + l]);\r\n                            }\r\n\r\n                            const applyWeights = (node: ITreeNode) => {\r\n                                for (let l = 0; l < node.data.length; l++)\r\n                                    if (node.data[l] instanceof GeometryData && (<GeometryData>node.data[l]).morphWeights.length === weightCount)\r\n                                        (<GeometryData>node.data[l]).morphWeights = weights;\r\n\r\n                                for (let l = 0; l < node.children.length; l++)\r\n                                    applyWeights(node.children[l])\r\n                            }\r\n                            applyWeights(track.node);\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return running;\r\n    }\r\n\r\n    public updateAnimationData(): void {\r\n        this._animations = {};\r\n\r\n        const animationArray = this.gatherAnimations();\r\n        const names = animationArray.map(a => a.name);\r\n\r\n        for (let i = 0; i < animationArray.length; i++) {\r\n            const animationName = animationArray[i].name;\r\n\r\n            const nameIndices = [];\r\n            for (let j = 0; j < names.length; j++)\r\n                if (animationName === names[j])\r\n                    nameIndices.push(j);\r\n\r\n            let animationNameAdjusted = animationName;\r\n            // name adjustement if the name occurs multiple times\r\n            if (nameIndices.length > 1) {\r\n                animationNameAdjusted = animationName + '_' + nameIndices.indexOf(i);\r\n                // even further name adjustement if the name is even then the same after adjustements (probably will never happen)\r\n                while (names.includes(animationNameAdjusted))\r\n                    animationNameAdjusted += \"_0\";\r\n            }\r\n\r\n            this._animations[animationNameAdjusted] = animationArray[i];\r\n        }\r\n    }\r\n\r\n    // #endregion Public Methods (3)\r\n\r\n    // #region Private Methods (1)\r\n\r\n    private gatherAnimations(node: ITreeNode = this._tree.root): AnimationData[] {\r\n        let out: AnimationData[] = [];\r\n        for (let i = 0, len = node.data.length; i < len; i++)\r\n            if (node.data[i] instanceof AnimationData)\r\n                out.push(<AnimationData>node.data[i])\r\n\r\n        for (let i = 0, len = node.children.length; i < len; i++)\r\n            out = out.concat(this.gatherAnimations(node.children[i]))\r\n\r\n        return out;\r\n    }\r\n\r\n    // #endregion Private Methods (1)\r\n}"]}},"error":null,"hash":"a2f78aebf59fc03b50df63eb08ffb18f","cacheData":{"env":{}}}