{"id":"node_modules/@shapediver/viewer.data-engine.geometry-engine/dist/GeometryEngine.js","dependencies":[{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\GeometryEngine.js.map","includedInParent":true,"mtime":1706527153729},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\src\\GeometryEngine.ts","includedInParent":true,"mtime":1706527153930},{"name":"D:\\projects\\myProjects\\shapeApp\\package.json","includedInParent":true,"mtime":1706533774939},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\package.json","includedInParent":true,"mtime":1706527153303},{"name":"@shapediver/viewer.shared.services","loc":{"line":13,"column":41,"index":844},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\GeometryEngine.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.services\\dist\\index.js"},{"name":"./gltfv1/GLTFLoader","loc":{"line":14,"column":29,"index":913},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\GeometryEngine.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv1\\GLTFLoader.js"},{"name":"./gltfv2/GLTFLoader","loc":{"line":15,"column":29,"index":967},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\GeometryEngine.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv2\\GLTFLoader.js"}],"generated":{"js":"\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GeometryEngine = void 0;\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst GLTFLoader_1 = require(\"./gltfv1/GLTFLoader\");\r\nconst GLTFLoader_2 = require(\"./gltfv2/GLTFLoader\");\r\nclass GeometryEngine {\r\n    constructor() {\r\n        // #region Properties (7)\r\n        this.BINARY_EXTENSION_HEADER_LENGTH = 20;\r\n        this._httpClient = viewer_shared_services_1.HttpClient.instance;\r\n        this._loadingQueue = [];\r\n        this._logger = viewer_shared_services_1.Logger.instance;\r\n        this._performanceEvaluator = viewer_shared_services_1.PerformanceEvaluator.instance;\r\n        this._loadingQueueLength = Infinity;\r\n        // #endregion Public Methods (1)\r\n    }\r\n    // #endregion Properties (7)\r\n    // #region Public Static Accessors (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Accessors (1)\r\n    // #region Public Accessors (2)\r\n    get parallelGlTFProcessing() {\r\n        return this._loadingQueueLength;\r\n    }\r\n    set parallelGlTFProcessing(value) {\r\n        this._loadingQueueLength = value;\r\n    }\r\n    // #endregion Public Accessors (2)\r\n    // #region Public Methods (1)\r\n    /**\r\n     * Load the geometry content into a scene graph node.\r\n     *\r\n     * @param content the geometry content\r\n     * @returns the scene graph node\r\n     */\r\n    loadContent(content, taskEventId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!content || (content && !content.href))\r\n                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GeometryEngine cannot load content.');\r\n            while (this._loadingQueueLength <= this._loadingQueue.length)\r\n                yield new Promise(resolve => setTimeout(resolve, 10));\r\n            const url = content.href;\r\n            // eslint-disable-next-line no-async-promise-executor\r\n            const loadingPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\r\n                let gltfContent, gltfBinary, gltfBaseUrl, gltfHeader;\r\n                let version = '2.0';\r\n                if (content.format === 'glb' || content.format === 'gltf') {\r\n                    this._performanceEvaluator.startSection('gltfProcessing.' + url);\r\n                    this._performanceEvaluator.startSection('loadGltf.' + url);\r\n                    const axiosResponse = yield this._httpClient.get(url, {\r\n                        responseType: 'arraybuffer'\r\n                    });\r\n                    this._performanceEvaluator.endSection('loadGltf.' + url);\r\n                    const magic = new TextDecoder().decode(new Uint8Array(axiosResponse.data, 0, 4));\r\n                    const isBinary = magic === 'glTF';\r\n                    if (isBinary) {\r\n                        gltfBinary = axiosResponse.data;\r\n                        // create header data\r\n                        const headerDataView = new DataView(gltfBinary, 0, this.BINARY_EXTENSION_HEADER_LENGTH);\r\n                        gltfHeader = {\r\n                            magic: magic,\r\n                            version: headerDataView.getUint32(4, true),\r\n                            length: headerDataView.getUint32(8, true),\r\n                            contentLength: headerDataView.getUint32(12, true),\r\n                            contentFormat: headerDataView.getUint32(16, true)\r\n                        };\r\n                        if (gltfHeader.magic != 'glTF')\r\n                            throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('Invalid data: glTF magic wrong.');\r\n                        // create content\r\n                        const contentDataView = new DataView(gltfBinary, this.BINARY_EXTENSION_HEADER_LENGTH, gltfHeader.contentLength);\r\n                        const contentDecoded = new TextDecoder().decode(contentDataView);\r\n                        gltfContent = JSON.parse(contentDecoded);\r\n                        if (gltfContent && gltfContent.asset && gltfContent.asset.version) {\r\n                            const assetVersion = (gltfContent.asset.version + '').endsWith('.0') ? gltfContent.asset.version : gltfContent.asset.version + '.0';\r\n                            if (gltfHeader.version + '.0' === assetVersion) {\r\n                                version = gltfHeader.version + '.0';\r\n                            }\r\n                            else {\r\n                                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GeometryEngine.loadContent: glTF header version (' + gltfHeader.version + ') is not the same as asset version (' + assetVersion + ').');\r\n                            }\r\n                        }\r\n                        else {\r\n                            version = gltfHeader.version + '.0';\r\n                        }\r\n                    }\r\n                    else {\r\n                        gltfContent = JSON.parse(new TextDecoder().decode(axiosResponse.data));\r\n                        if (gltfContent && gltfContent.asset && gltfContent.asset.version) {\r\n                            if (gltfContent.asset.version !== '2.0')\r\n                                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GeometryEngine.loadContent: Only gltf v2 is supported in a non-binary format.');\r\n                        }\r\n                        else {\r\n                            this._logger.warn('GeometryEngine.loadContent: No version specified in asset, trying to load as v2.');\r\n                            version = '2.0';\r\n                        }\r\n                        const removeLastDirectoryPartOf = (the_url) => {\r\n                            const dir_char = the_url.includes(\"/\") ? \"/\" : \"\\\\\";\r\n                            const the_arr = the_url.split(dir_char);\r\n                            the_arr.pop();\r\n                            return the_arr.join(dir_char);\r\n                        };\r\n                        gltfBaseUrl = removeLastDirectoryPartOf(url);\r\n                        if (!gltfBaseUrl && window && window.location && window.location.href)\r\n                            gltfBaseUrl = removeLastDirectoryPartOf(window.location.href);\r\n                    }\r\n                }\r\n                let promise;\r\n                if (version === '1.0') {\r\n                    promise = new GLTFLoader_1.GLTFLoader().load(gltfContent, gltfBinary, gltfHeader, gltfBaseUrl, taskEventId);\r\n                }\r\n                else {\r\n                    promise = new GLTFLoader_2.GLTFLoader().load(gltfContent, gltfBinary, gltfHeader, gltfBaseUrl, taskEventId);\r\n                }\r\n                promise.catch(e => { reject(e); });\r\n                resolve(promise);\r\n            }));\r\n            this._loadingQueue.push(loadingPromise);\r\n            const node = yield loadingPromise;\r\n            this._loadingQueue.splice(this._loadingQueue.indexOf(loadingPromise), 1);\r\n            this._performanceEvaluator.endSection('gltfProcessing.' + url);\r\n            return node;\r\n        });\r\n    }\r\n}\r\nexports.GeometryEngine = GeometryEngine;\r\n"},"sourceMaps":{"js":{"version":3,"file":"GeometryEngine.js","sourceRoot":"","sources":["../src/GeometryEngine.ts"],"names":[],"mappings":"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","sourcesContent":["import { ITreeNode } from '@shapediver/viewer.shared.node-tree'\r\nimport { HttpClient, Logger, PerformanceEvaluator, ShapeDiverViewerDataProcessingError } from '@shapediver/viewer.shared.services'\r\n\r\nimport { GLTFLoader as GLTF_v1Loader } from './gltfv1/GLTFLoader'\r\nimport { GLTFLoader as GLTF_v2Loader } from './gltfv2/GLTFLoader'\r\nimport { ShapeDiverResponseOutputContent } from '@shapediver/sdk.geometry-api-sdk-v2'\r\n\r\nexport class GeometryEngine {\r\n    // #region Properties (7)\r\n\r\n    private readonly BINARY_EXTENSION_HEADER_LENGTH = 20;\r\n    private readonly _httpClient: HttpClient = HttpClient.instance;\r\n    private readonly _loadingQueue: Promise<ITreeNode>[] = [];\r\n    private readonly _logger: Logger = Logger.instance;\r\n    private readonly _performanceEvaluator = PerformanceEvaluator.instance;\r\n\r\n    private static _instance: GeometryEngine;\r\n\r\n    private _loadingQueueLength = Infinity;\r\n\r\n    // #endregion Properties (7)\r\n\r\n    // #region Public Static Accessors (1)\r\n\r\n    public static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n\r\n    // #endregion Public Static Accessors (1)\r\n\r\n    // #region Public Accessors (2)\r\n\r\n    public get parallelGlTFProcessing(): number {\r\n        return this._loadingQueueLength;\r\n    }\r\n\r\n    public set parallelGlTFProcessing(value: number) {\r\n        this._loadingQueueLength = value;\r\n    }\r\n\r\n    // #endregion Public Accessors (2)\r\n\r\n    // #region Public Methods (1)\r\n\r\n    /**\r\n     * Load the geometry content into a scene graph node.\r\n     * \r\n     * @param content the geometry content\r\n     * @returns the scene graph node \r\n     */\r\n    public async loadContent(content: ShapeDiverResponseOutputContent, taskEventId: string): Promise<ITreeNode> {\r\n        if (!content || (content && !content.href))\r\n            throw new ShapeDiverViewerDataProcessingError('GeometryEngine cannot load content.');\r\n\r\n        while(this._loadingQueueLength <= this._loadingQueue.length) \r\n            await new Promise(resolve => setTimeout(resolve, 10));\r\n\r\n        const url = content.href!;\r\n        // eslint-disable-next-line no-async-promise-executor\r\n        const loadingPromise = new Promise<ITreeNode>(async (resolve, reject) => {\r\n            let gltfContent, gltfBinary, gltfBaseUrl, gltfHeader;\r\n            let version = '2.0';\r\n    \r\n            if (content.format === 'glb' || content.format === 'gltf') {\r\n                this._performanceEvaluator.startSection('gltfProcessing.' + url);\r\n    \r\n                this._performanceEvaluator.startSection('loadGltf.' + url);\r\n                const axiosResponse = await this._httpClient.get(url!, {\r\n                    responseType: 'arraybuffer'\r\n                });\r\n                this._performanceEvaluator.endSection('loadGltf.' + url);\r\n    \r\n                const magic = new TextDecoder().decode(new Uint8Array(axiosResponse.data, 0, 4));\r\n                const isBinary = magic === 'glTF';\r\n    \r\n                if (isBinary) {\r\n                    gltfBinary = axiosResponse.data;\r\n                    // create header data\r\n                    const headerDataView = new DataView(gltfBinary, 0, this.BINARY_EXTENSION_HEADER_LENGTH);\r\n                    gltfHeader = {\r\n                        magic: magic,\r\n                        version: headerDataView.getUint32(4, true),\r\n                        length: headerDataView.getUint32(8, true),\r\n                        contentLength: headerDataView.getUint32(12, true),\r\n                        contentFormat: headerDataView.getUint32(16, true)\r\n                    }\r\n                    if (gltfHeader.magic != 'glTF') \r\n                        throw new ShapeDiverViewerDataProcessingError('Invalid data: glTF magic wrong.');\r\n                    \r\n                    // create content\r\n                    const contentDataView = new DataView(gltfBinary, this.BINARY_EXTENSION_HEADER_LENGTH, gltfHeader.contentLength);\r\n                    const contentDecoded = new TextDecoder().decode(contentDataView);\r\n                    gltfContent = JSON.parse(contentDecoded);\r\n    \r\n                    if(gltfContent && gltfContent.asset && gltfContent.asset.version) {\r\n                        const assetVersion = (gltfContent.asset.version + '').endsWith('.0') ? gltfContent.asset.version : gltfContent.asset.version + '.0';\r\n                        if(gltfHeader.version + '.0' === assetVersion) {\r\n                            version = gltfHeader.version + '.0';\r\n                        } else {\r\n                            throw new ShapeDiverViewerDataProcessingError('GeometryEngine.loadContent: glTF header version (' + gltfHeader.version + ') is not the same as asset version (' + assetVersion + ').');\r\n                        }\r\n                    } else {\r\n                        version = gltfHeader.version + '.0';\r\n                    }\r\n                } else {\r\n                    gltfContent = JSON.parse(new TextDecoder().decode(axiosResponse.data));\r\n    \r\n                    if(gltfContent && gltfContent.asset && gltfContent.asset.version) {\r\n                        if(gltfContent.asset.version !== '2.0')\r\n                            throw new ShapeDiverViewerDataProcessingError('GeometryEngine.loadContent: Only gltf v2 is supported in a non-binary format.');\r\n                    } else {\r\n                        this._logger.warn('GeometryEngine.loadContent: No version specified in asset, trying to load as v2.');\r\n                        version = '2.0';\r\n                    }\r\n    \r\n                    const removeLastDirectoryPartOf = (the_url: string): string => {\r\n                        const dir_char = the_url.includes(\"/\") ? \"/\" : \"\\\\\";\r\n                        const the_arr = the_url.split(dir_char);\r\n                        the_arr.pop();\r\n                        return the_arr.join(dir_char);\r\n                    }\r\n    \r\n                    gltfBaseUrl = removeLastDirectoryPartOf(url!);\r\n                    if (!gltfBaseUrl && window && window.location && window.location.href)\r\n                        gltfBaseUrl = removeLastDirectoryPartOf(window.location.href);\r\n                }\r\n            }\r\n            \r\n            let promise: Promise<ITreeNode>;\r\n            if (version === '1.0') {\r\n                promise = new GLTF_v1Loader().load(gltfContent, gltfBinary, gltfHeader, gltfBaseUrl, taskEventId)\r\n            } else {\r\n                promise = new GLTF_v2Loader().load(gltfContent, gltfBinary, gltfHeader, gltfBaseUrl, taskEventId);\r\n            }\r\n            promise.catch(e => { reject(e) })\r\n            resolve(promise);\r\n        })\r\n\r\n        this._loadingQueue.push(loadingPromise);\r\n        const node = await loadingPromise;\r\n        this._loadingQueue.splice(this._loadingQueue.indexOf(loadingPromise), 1);\r\n       \r\n        this._performanceEvaluator.endSection('gltfProcessing.' + url);\r\n\r\n        return node;\r\n    }\r\n\r\n    // #endregion Public Methods (1)\r\n}"]}},"error":null,"hash":"53cd289e08aad450fd502e12cabac0dd","cacheData":{"env":{}}}