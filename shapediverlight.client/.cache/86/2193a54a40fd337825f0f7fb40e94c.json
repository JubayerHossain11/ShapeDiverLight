{"id":"node_modules/@shapediver/viewer.rendering-engine-threejs.standard/dist/three/loaders/RGBELoader.js","dependencies":[{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\dist\\three\\loaders\\RGBELoader.js.map","includedInParent":true,"mtime":1706527153644},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\src\\three\\loaders\\RGBELoader.js","includedInParent":true,"mtime":1706527152670},{"name":"D:\\projects\\myProjects\\shapeApp\\package.json","includedInParent":true,"mtime":1706533774939},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\package.json","includedInParent":true,"mtime":1706527152875},{"name":"three","loc":{"line":4,"column":24,"index":133},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\dist\\three\\loaders\\RGBELoader.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\three\\build\\three.module.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RGBELoader = void 0;\r\nconst three_1 = require(\"three\");\r\n// https://github.com/mrdoob/three.js/issues/5552\r\n// http://en.wikipedia.org/wiki/RGBE_image_format\r\nclass RGBELoader extends three_1.DataTextureLoader {\r\n    constructor(manager) {\r\n        super(manager);\r\n        this.type = three_1.HalfFloatType;\r\n    }\r\n    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\r\n    parse(buffer) {\r\n        const \r\n        /* return codes for rgbe routines */\r\n        //RGBE_RETURN_SUCCESS = 0,\r\n        RGBE_RETURN_FAILURE = -1, \r\n        /* default error routine.  change this to change error handling */\r\n        rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function (rgbe_error_code, msg) {\r\n            switch (rgbe_error_code) {\r\n                case rgbe_read_error:\r\n                    console.error('THREE.RGBELoader Read Error: ' + (msg || ''));\r\n                    break;\r\n                case rgbe_write_error:\r\n                    console.error('THREE.RGBELoader Write Error: ' + (msg || ''));\r\n                    break;\r\n                case rgbe_format_error:\r\n                    console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));\r\n                    break;\r\n                default:\r\n                case rgbe_memory_error: console.error('THREE.RGBELoader: Error: ' + (msg || ''));\r\n            }\r\n            return RGBE_RETURN_FAILURE;\r\n        }, \r\n        /* offsets to red, green, and blue components in a data (float) pixel */\r\n        //RGBE_DATA_RED = 0,\r\n        //RGBE_DATA_GREEN = 1,\r\n        //RGBE_DATA_BLUE = 2,\r\n        /* number of floats per pixel, use 4 since stored in rgba image format */\r\n        //RGBE_DATA_SIZE = 4,\r\n        /* flags indicating which fields in an rgbe_header_info are valid */\r\n        RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = '\\n', fgets = function (buffer, lineLimit, consume) {\r\n            const chunkSize = 128;\r\n            lineLimit = !lineLimit ? 1024 : lineLimit;\r\n            let p = buffer.pos, i = -1, len = 0, s = '', chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\r\n            while ((0 > (i = chunk.indexOf(NEWLINE))) && (len < lineLimit) && (p < buffer.byteLength)) {\r\n                s += chunk;\r\n                len += chunk.length;\r\n                p += chunkSize;\r\n                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\r\n            }\r\n            if (-1 < i) {\r\n                /*for (i=l-1; i>=0; i--) {\r\n                    byteCode = m.charCodeAt(i);\r\n                    if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\r\n                    else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\r\n                    if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\r\n                }*/\r\n                if (false !== consume)\r\n                    buffer.pos += len + i + 1;\r\n                return s + chunk.slice(0, i);\r\n            }\r\n            return false;\r\n        }, \r\n        /* minimal header reading.  modify if you want to parse more information */\r\n        RGBE_ReadHeader = function (buffer) {\r\n            // regexes to parse header info fields\r\n            const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, \r\n            // RGBE format header struct\r\n            header = {\r\n                valid: 0,\r\n                string: '',\r\n                comments: '',\r\n                programtype: 'RGBE',\r\n                format: '',\r\n                gamma: 1.0,\r\n                exposure: 1.0,\r\n                width: 0, height: 0 /* image dimensions, width/height */\r\n            };\r\n            let line, match;\r\n            if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\r\n                return rgbe_error(rgbe_read_error, 'no header found');\r\n            }\r\n            /* if you want to require the magic token then uncomment the next line */\r\n            if (!(match = line.match(magic_token_re))) {\r\n                return rgbe_error(rgbe_format_error, 'bad initial token');\r\n            }\r\n            header.valid |= RGBE_VALID_PROGRAMTYPE;\r\n            header.programtype = match[1];\r\n            header.string += line + '\\n';\r\n            while (true) {\r\n                line = fgets(buffer);\r\n                if (false === line)\r\n                    break;\r\n                header.string += line + '\\n';\r\n                if ('#' === line.charAt(0)) {\r\n                    header.comments += line + '\\n';\r\n                    continue; // comment line\r\n                }\r\n                if (match = line.match(gamma_re)) {\r\n                    header.gamma = parseFloat(match[1]);\r\n                }\r\n                if (match = line.match(exposure_re)) {\r\n                    header.exposure = parseFloat(match[1]);\r\n                }\r\n                if (match = line.match(format_re)) {\r\n                    header.valid |= RGBE_VALID_FORMAT;\r\n                    header.format = match[1]; //'32-bit_rle_rgbe';\r\n                }\r\n                if (match = line.match(dimensions_re)) {\r\n                    header.valid |= RGBE_VALID_DIMENSIONS;\r\n                    header.height = parseInt(match[1], 10);\r\n                    header.width = parseInt(match[2], 10);\r\n                }\r\n                if ((header.valid & RGBE_VALID_FORMAT) && (header.valid & RGBE_VALID_DIMENSIONS))\r\n                    break;\r\n            }\r\n            if (!(header.valid & RGBE_VALID_FORMAT)) {\r\n                return rgbe_error(rgbe_format_error, 'missing format specifier');\r\n            }\r\n            if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\r\n                return rgbe_error(rgbe_format_error, 'missing image size specifier');\r\n            }\r\n            return header;\r\n        }, RGBE_ReadPixels_RLE = function (buffer, w, h) {\r\n            const scanline_width = w;\r\n            if (\r\n            // run length encoding is not allowed so read flat\r\n            ((scanline_width < 8) || (scanline_width > 0x7fff)) ||\r\n                // this file is not run length encoded\r\n                ((2 !== buffer[0]) || (2 !== buffer[1]) || (buffer[2] & 0x80))) {\r\n                // return the flat buffer\r\n                return new Uint8Array(buffer);\r\n            }\r\n            if (scanline_width !== ((buffer[2] << 8) | buffer[3])) {\r\n                return rgbe_error(rgbe_format_error, 'wrong scanline width');\r\n            }\r\n            const data_rgba = new Uint8Array(4 * w * h);\r\n            if (!data_rgba.length) {\r\n                return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');\r\n            }\r\n            let offset = 0, pos = 0;\r\n            const ptr_end = 4 * scanline_width;\r\n            const rgbeStart = new Uint8Array(4);\r\n            const scanline_buffer = new Uint8Array(ptr_end);\r\n            let num_scanlines = h;\r\n            // read in each successive scanline\r\n            while ((num_scanlines > 0) && (pos < buffer.byteLength)) {\r\n                if (pos + 4 > buffer.byteLength) {\r\n                    return rgbe_error(rgbe_read_error);\r\n                }\r\n                rgbeStart[0] = buffer[pos++];\r\n                rgbeStart[1] = buffer[pos++];\r\n                rgbeStart[2] = buffer[pos++];\r\n                rgbeStart[3] = buffer[pos++];\r\n                if ((2 != rgbeStart[0]) || (2 != rgbeStart[1]) || (((rgbeStart[2] << 8) | rgbeStart[3]) != scanline_width)) {\r\n                    return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\r\n                }\r\n                // read each of the four channels for the scanline into the buffer\r\n                // first red, then green, then blue, then exponent\r\n                let ptr = 0, count;\r\n                while ((ptr < ptr_end) && (pos < buffer.byteLength)) {\r\n                    count = buffer[pos++];\r\n                    const isEncodedRun = count > 128;\r\n                    if (isEncodedRun)\r\n                        count -= 128;\r\n                    if ((0 === count) || (ptr + count > ptr_end)) {\r\n                        return rgbe_error(rgbe_format_error, 'bad scanline data');\r\n                    }\r\n                    if (isEncodedRun) {\r\n                        // a (encoded) run of the same value\r\n                        const byteValue = buffer[pos++];\r\n                        for (let i = 0; i < count; i++) {\r\n                            scanline_buffer[ptr++] = byteValue;\r\n                        }\r\n                        //ptr += count;\r\n                    }\r\n                    else {\r\n                        // a literal-run\r\n                        scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\r\n                        ptr += count;\r\n                        pos += count;\r\n                    }\r\n                }\r\n                // now convert data from buffer into rgba\r\n                // first red, then green, then blue, then exponent (alpha)\r\n                const l = scanline_width; //scanline_buffer.byteLength;\r\n                for (let i = 0; i < l; i++) {\r\n                    let off = 0;\r\n                    data_rgba[offset] = scanline_buffer[i + off];\r\n                    off += scanline_width; //1;\r\n                    data_rgba[offset + 1] = scanline_buffer[i + off];\r\n                    off += scanline_width; //1;\r\n                    data_rgba[offset + 2] = scanline_buffer[i + off];\r\n                    off += scanline_width; //1;\r\n                    data_rgba[offset + 3] = scanline_buffer[i + off];\r\n                    offset += 4;\r\n                }\r\n                num_scanlines--;\r\n            }\r\n            return data_rgba;\r\n        };\r\n        const RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\r\n            const e = sourceArray[sourceOffset + 3];\r\n            const scale = Math.pow(2.0, e - 128.0) / 255.0;\r\n            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\r\n            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\r\n            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\r\n            destArray[destOffset + 3] = 1;\r\n        };\r\n        const RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {\r\n            const e = sourceArray[sourceOffset + 3];\r\n            const scale = Math.pow(2.0, e - 128.0) / 255.0;\r\n            // clamping to 65504, the maximum representable value in float16\r\n            destArray[destOffset + 0] = three_1.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\r\n            destArray[destOffset + 1] = three_1.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\r\n            destArray[destOffset + 2] = three_1.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\r\n            destArray[destOffset + 3] = three_1.DataUtils.toHalfFloat(1);\r\n        };\r\n        const byteArray = new Uint8Array(buffer);\r\n        byteArray.pos = 0;\r\n        const rgbe_header_info = RGBE_ReadHeader(byteArray);\r\n        if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\r\n            const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\r\n            if (RGBE_RETURN_FAILURE !== image_rgba_data) {\r\n                let data, format, type;\r\n                let numElements;\r\n                switch (this.type) {\r\n                    case three_1.FloatType:\r\n                        numElements = image_rgba_data.length / 4;\r\n                        const floatArray = new Float32Array(numElements * 4);\r\n                        for (let j = 0; j < numElements; j++) {\r\n                            RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\r\n                        }\r\n                        data = floatArray;\r\n                        type = three_1.FloatType;\r\n                        break;\r\n                    case three_1.HalfFloatType:\r\n                        numElements = image_rgba_data.length / 4;\r\n                        const halfArray = new Uint16Array(numElements * 4);\r\n                        for (let j = 0; j < numElements; j++) {\r\n                            RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\r\n                        }\r\n                        data = halfArray;\r\n                        type = three_1.HalfFloatType;\r\n                        break;\r\n                    default:\r\n                        console.error('THREE.RGBELoader: unsupported type: ', this.type);\r\n                        break;\r\n                }\r\n                return {\r\n                    width: w, height: h,\r\n                    data: data,\r\n                    header: rgbe_header_info.string,\r\n                    gamma: rgbe_header_info.gamma,\r\n                    exposure: rgbe_header_info.exposure,\r\n                    format: format,\r\n                    type: type\r\n                };\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    setDataType(value) {\r\n        this.type = value;\r\n        return this;\r\n    }\r\n    load(url, onLoad, onProgress, onError) {\r\n        function onLoadCallback(texture, texData) {\r\n            switch (texture.type) {\r\n                case three_1.FloatType:\r\n                    texture.encoding = three_1.LinearEncoding;\r\n                    texture.minFilter = three_1.LinearFilter;\r\n                    texture.magFilter = three_1.LinearFilter;\r\n                    texture.generateMipmaps = false;\r\n                    texture.flipY = true;\r\n                    break;\r\n                case three_1.HalfFloatType:\r\n                    texture.encoding = three_1.LinearEncoding;\r\n                    texture.minFilter = three_1.LinearFilter;\r\n                    texture.magFilter = three_1.LinearFilter;\r\n                    texture.generateMipmaps = false;\r\n                    texture.flipY = true;\r\n                    break;\r\n            }\r\n            if (onLoad)\r\n                onLoad(texture, texData);\r\n        }\r\n        return super.load(url, onLoadCallback, onProgress, onError);\r\n    }\r\n}\r\nexports.RGBELoader = RGBELoader;\r\n"},"sourceMaps":{"js":{"version":3,"file":"RGBELoader.js","sourceRoot":"","sources":["../../../src/three/loaders/RGBELoader.js"],"names":[],"mappings":"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","sourcesContent":["import {\r\n\tDataTextureLoader,\r\n\tDataUtils,\r\n\tFloatType,\r\n\tHalfFloatType,\r\n\tLinearEncoding,\r\n\tLinearFilter\r\n} from 'three';\r\n\r\n// https://github.com/mrdoob/three.js/issues/5552\r\n// http://en.wikipedia.org/wiki/RGBE_image_format\r\n\r\nclass RGBELoader extends DataTextureLoader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t\tthis.type = HalfFloatType;\r\n\r\n\t}\r\n\r\n\t// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\r\n\r\n\tparse( buffer ) {\r\n\r\n\t\tconst\r\n\t\t\t/* return codes for rgbe routines */\r\n\t\t\t//RGBE_RETURN_SUCCESS = 0,\r\n\t\t\tRGBE_RETURN_FAILURE = - 1,\r\n\r\n\t\t\t/* default error routine.  change this to change error handling */\r\n\t\t\trgbe_read_error = 1,\r\n\t\t\trgbe_write_error = 2,\r\n\t\t\trgbe_format_error = 3,\r\n\t\t\trgbe_memory_error = 4,\r\n\t\t\trgbe_error = function ( rgbe_error_code, msg ) {\r\n\r\n\t\t\t\tswitch ( rgbe_error_code ) {\r\n\r\n\t\t\t\t\tcase rgbe_read_error: console.error( 'THREE.RGBELoader Read Error: ' + ( msg || '' ) );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase rgbe_write_error: console.error( 'THREE.RGBELoader Write Error: ' + ( msg || '' ) );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase rgbe_format_error: console.error( 'THREE.RGBELoader Bad File Format: ' + ( msg || '' ) );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\tcase rgbe_memory_error: console.error( 'THREE.RGBELoader: Error: ' + ( msg || '' ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn RGBE_RETURN_FAILURE;\r\n\r\n\t\t\t},\r\n\r\n\t\t\t/* offsets to red, green, and blue components in a data (float) pixel */\r\n\t\t\t//RGBE_DATA_RED = 0,\r\n\t\t\t//RGBE_DATA_GREEN = 1,\r\n\t\t\t//RGBE_DATA_BLUE = 2,\r\n\r\n\t\t\t/* number of floats per pixel, use 4 since stored in rgba image format */\r\n\t\t\t//RGBE_DATA_SIZE = 4,\r\n\r\n\t\t\t/* flags indicating which fields in an rgbe_header_info are valid */\r\n\t\t\tRGBE_VALID_PROGRAMTYPE = 1,\r\n\t\t\tRGBE_VALID_FORMAT = 2,\r\n\t\t\tRGBE_VALID_DIMENSIONS = 4,\r\n\r\n\t\t\tNEWLINE = '\\n',\r\n\r\n\t\t\tfgets = function ( buffer, lineLimit, consume ) {\r\n\r\n\t\t\t\tconst chunkSize = 128;\r\n\r\n\t\t\t\tlineLimit = ! lineLimit ? 1024 : lineLimit;\r\n\t\t\t\tlet p = buffer.pos,\r\n\t\t\t\t\ti = - 1, len = 0, s = '',\r\n\t\t\t\t\tchunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\r\n\r\n\t\t\t\twhile ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {\r\n\r\n\t\t\t\t\ts += chunk; len += chunk.length;\r\n\t\t\t\t\tp += chunkSize;\r\n\t\t\t\t\tchunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( - 1 < i ) {\r\n\r\n\t\t\t\t\t/*for (i=l-1; i>=0; i--) {\r\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\r\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\r\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\r\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\r\n\t\t\t\t\t}*/\r\n\t\t\t\t\tif ( false !== consume ) buffer.pos += len + i + 1;\r\n\t\t\t\t\treturn s + chunk.slice( 0, i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t},\r\n\r\n\t\t\t/* minimal header reading.  modify if you want to parse more information */\r\n\t\t\tRGBE_ReadHeader = function ( buffer ) {\r\n\r\n\r\n\t\t\t\t// regexes to parse header info fields\r\n\t\t\t\tconst magic_token_re = /^#\\?(\\S+)/,\r\n\t\t\t\t\tgamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\r\n\t\t\t\t\texposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\r\n\t\t\t\t\tformat_re = /^\\s*FORMAT=(\\S+)\\s*$/,\r\n\t\t\t\t\tdimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\r\n\r\n\t\t\t\t\t// RGBE format header struct\r\n\t\t\t\t\theader = {\r\n\r\n\t\t\t\t\t\tvalid: 0, /* indicate which fields are valid */\r\n\r\n\t\t\t\t\t\tstring: '', /* the actual header string */\r\n\r\n\t\t\t\t\t\tcomments: '', /* comments found in header */\r\n\r\n\t\t\t\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\r\n\r\n\t\t\t\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\r\n\r\n\t\t\t\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\r\n\r\n\t\t\t\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\r\n\r\n\t\t\t\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\r\n\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\tlet line, match;\r\n\r\n\t\t\t\tif ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {\r\n\r\n\t\t\t\t\treturn rgbe_error( rgbe_read_error, 'no header found' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* if you want to require the magic token then uncomment the next line */\r\n\t\t\t\tif ( ! ( match = line.match( magic_token_re ) ) ) {\r\n\r\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad initial token' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\r\n\t\t\t\theader.programtype = match[ 1 ];\r\n\t\t\t\theader.string += line + '\\n';\r\n\r\n\t\t\t\twhile ( true ) {\r\n\r\n\t\t\t\t\tline = fgets( buffer );\r\n\t\t\t\t\tif ( false === line ) break;\r\n\t\t\t\t\theader.string += line + '\\n';\r\n\r\n\t\t\t\t\tif ( '#' === line.charAt( 0 ) ) {\r\n\r\n\t\t\t\t\t\theader.comments += line + '\\n';\r\n\t\t\t\t\t\tcontinue; // comment line\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( match = line.match( gamma_re ) ) {\r\n\r\n\t\t\t\t\t\theader.gamma = parseFloat( match[ 1 ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( match = line.match( exposure_re ) ) {\r\n\r\n\t\t\t\t\t\theader.exposure = parseFloat( match[ 1 ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( match = line.match( format_re ) ) {\r\n\r\n\t\t\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\r\n\t\t\t\t\t\theader.format = match[ 1 ];//'32-bit_rle_rgbe';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( match = line.match( dimensions_re ) ) {\r\n\r\n\t\t\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\r\n\t\t\t\t\t\theader.height = parseInt( match[ 1 ], 10 );\r\n\t\t\t\t\t\theader.width = parseInt( match[ 2 ], 10 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {\r\n\r\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'missing format specifier' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {\r\n\r\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'missing image size specifier' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn header;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tRGBE_ReadPixels_RLE = function ( buffer, w, h ) {\r\n\r\n\t\t\t\tconst scanline_width = w;\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\t// run length encoding is not allowed so read flat\r\n\t\t\t\t\t( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||\r\n\t\t\t\t\t// this file is not run length encoded\r\n\t\t\t\t\t( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )\r\n\t\t\t\t) {\r\n\r\n\t\t\t\t\t// return the flat buffer\r\n\t\t\t\t\treturn new Uint8Array( buffer );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {\r\n\r\n\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'wrong scanline width' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst data_rgba = new Uint8Array( 4 * w * h );\r\n\r\n\t\t\t\tif ( ! data_rgba.length ) {\r\n\r\n\t\t\t\t\treturn rgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet offset = 0, pos = 0;\r\n\r\n\t\t\t\tconst ptr_end = 4 * scanline_width;\r\n\t\t\t\tconst rgbeStart = new Uint8Array( 4 );\r\n\t\t\t\tconst scanline_buffer = new Uint8Array( ptr_end );\r\n\t\t\t\tlet num_scanlines = h;\r\n\r\n\t\t\t\t// read in each successive scanline\r\n\t\t\t\twhile ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {\r\n\r\n\t\t\t\t\tif ( pos + 4 > buffer.byteLength ) {\r\n\r\n\t\t\t\t\t\treturn rgbe_error( rgbe_read_error );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\trgbeStart[ 0 ] = buffer[ pos ++ ];\r\n\t\t\t\t\trgbeStart[ 1 ] = buffer[ pos ++ ];\r\n\t\t\t\t\trgbeStart[ 2 ] = buffer[ pos ++ ];\r\n\t\t\t\t\trgbeStart[ 3 ] = buffer[ pos ++ ];\r\n\r\n\t\t\t\t\tif ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {\r\n\r\n\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad rgbe scanline format' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// read each of the four channels for the scanline into the buffer\r\n\t\t\t\t\t// first red, then green, then blue, then exponent\r\n\t\t\t\t\tlet ptr = 0, count;\r\n\r\n\t\t\t\t\twhile ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {\r\n\r\n\t\t\t\t\t\tcount = buffer[ pos ++ ];\r\n\t\t\t\t\t\tconst isEncodedRun = count > 128;\r\n\t\t\t\t\t\tif ( isEncodedRun ) count -= 128;\r\n\r\n\t\t\t\t\t\tif ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {\r\n\r\n\t\t\t\t\t\t\treturn rgbe_error( rgbe_format_error, 'bad scanline data' );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( isEncodedRun ) {\r\n\r\n\t\t\t\t\t\t\t// a (encoded) run of the same value\r\n\t\t\t\t\t\t\tconst byteValue = buffer[ pos ++ ];\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tscanline_buffer[ ptr ++ ] = byteValue;\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t//ptr += count;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// a literal-run\r\n\t\t\t\t\t\t\tscanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );\r\n\t\t\t\t\t\t\tptr += count; pos += count;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t// now convert data from buffer into rgba\r\n\t\t\t\t\t// first red, then green, then blue, then exponent (alpha)\r\n\t\t\t\t\tconst l = scanline_width; //scanline_buffer.byteLength;\r\n\t\t\t\t\tfor ( let i = 0; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tlet off = 0;\r\n\t\t\t\t\t\tdata_rgba[ offset ] = scanline_buffer[ i + off ];\r\n\t\t\t\t\t\toff += scanline_width; //1;\r\n\t\t\t\t\t\tdata_rgba[ offset + 1 ] = scanline_buffer[ i + off ];\r\n\t\t\t\t\t\toff += scanline_width; //1;\r\n\t\t\t\t\t\tdata_rgba[ offset + 2 ] = scanline_buffer[ i + off ];\r\n\t\t\t\t\t\toff += scanline_width; //1;\r\n\t\t\t\t\t\tdata_rgba[ offset + 3 ] = scanline_buffer[ i + off ];\r\n\t\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnum_scanlines --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn data_rgba;\r\n\r\n\t\t\t};\r\n\r\n\t\tconst RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {\r\n\r\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\r\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\r\n\r\n\t\t\tdestArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;\r\n\t\t\tdestArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;\r\n\t\t\tdestArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;\r\n\t\t\tdestArray[ destOffset + 3 ] = 1;\r\n\r\n\t\t};\r\n\r\n\t\tconst RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {\r\n\r\n\t\t\tconst e = sourceArray[ sourceOffset + 3 ];\r\n\t\t\tconst scale = Math.pow( 2.0, e - 128.0 ) / 255.0;\r\n\r\n\t\t\t// clamping to 65504, the maximum representable value in float16\r\n\t\t\tdestArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );\r\n\t\t\tdestArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );\r\n\t\t\tdestArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );\r\n\t\t\tdestArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );\r\n\r\n\t\t};\r\n\r\n\t\tconst byteArray = new Uint8Array( buffer );\r\n\t\tbyteArray.pos = 0;\r\n\t\tconst rgbe_header_info = RGBE_ReadHeader( byteArray );\r\n\r\n\t\tif ( RGBE_RETURN_FAILURE !== rgbe_header_info ) {\r\n\r\n\t\t\tconst w = rgbe_header_info.width,\r\n\t\t\t\th = rgbe_header_info.height,\r\n\t\t\t\timage_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );\r\n\r\n\t\t\tif ( RGBE_RETURN_FAILURE !== image_rgba_data ) {\r\n\r\n\t\t\t\tlet data, format, type;\r\n\t\t\t\tlet numElements;\r\n\r\n\t\t\t\tswitch ( this.type ) {\r\n\r\n\t\t\t\t\tcase FloatType:\r\n\r\n\t\t\t\t\t\tnumElements = image_rgba_data.length / 4;\r\n\t\t\t\t\t\tconst floatArray = new Float32Array( numElements * 4 );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tRGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdata = floatArray;\r\n\t\t\t\t\t\ttype = FloatType;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase HalfFloatType:\r\n\r\n\t\t\t\t\t\tnumElements = image_rgba_data.length / 4;\r\n\t\t\t\t\t\tconst halfArray = new Uint16Array( numElements * 4 );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0; j < numElements; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tRGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdata = halfArray;\r\n\t\t\t\t\t\ttype = HalfFloatType;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.RGBELoader: unsupported type: ', this.type );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\twidth: w, height: h,\r\n\t\t\t\t\tdata: data,\r\n\t\t\t\t\theader: rgbe_header_info.string,\r\n\t\t\t\t\tgamma: rgbe_header_info.gamma,\r\n\t\t\t\t\texposure: rgbe_header_info.exposure,\r\n\t\t\t\t\tformat: format,\r\n\t\t\t\t\ttype: type\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\tsetDataType( value ) {\r\n\r\n\t\tthis.type = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tfunction onLoadCallback( texture, texData ) {\r\n\r\n\t\t\tswitch ( texture.type ) {\r\n\r\n\t\t\t\tcase FloatType:\r\n\r\n\t\t\t\t\ttexture.encoding = LinearEncoding;\r\n\t\t\t\t\ttexture.minFilter = LinearFilter;\r\n\t\t\t\t\ttexture.magFilter = LinearFilter;\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\t\t\t\t\ttexture.flipY = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase HalfFloatType:\r\n\r\n\t\t\t\t\ttexture.encoding = LinearEncoding;\r\n\t\t\t\t\ttexture.minFilter = LinearFilter;\r\n\t\t\t\t\ttexture.magFilter = LinearFilter;\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\t\t\t\t\ttexture.flipY = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( onLoad ) onLoad( texture, texData );\r\n\r\n\t\t}\r\n\r\n\t\treturn super.load( url, onLoadCallback, onProgress, onError );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { RGBELoader };\r\n"]}},"error":null,"hash":"a340b585d24fbaa11e6db377f3de86c3","cacheData":{"env":{}}}