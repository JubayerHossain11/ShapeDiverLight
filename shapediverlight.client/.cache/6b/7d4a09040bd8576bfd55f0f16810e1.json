{"id":"node_modules/@shapediver/viewer.data-engine.geometry-engine/dist/gltfv1/GLTFLoader.js","dependencies":[{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv1\\GLTFLoader.js.map","includedInParent":true,"mtime":1706527153804},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\src\\gltfv1\\GLTFLoader.ts","includedInParent":true,"mtime":1706527154047},{"name":"D:\\projects\\myProjects\\shapeApp\\package.json","includedInParent":true,"mtime":1706533774939},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\package.json","includedInParent":true,"mtime":1706527153303},{"name":"@shapediver/viewer.shared.node-tree","loc":{"line":13,"column":42,"index":841},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv1\\GLTFLoader.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.node-tree\\dist\\index.js"},{"name":"@shapediver/viewer.shared.services","loc":{"line":14,"column":41,"index":923},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv1\\GLTFLoader.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.services\\dist\\index.js"},{"name":"@shapediver/viewer.data-engine.shared-types","loc":{"line":15,"column":50,"index":1013},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv1\\GLTFLoader.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.shared-types\\dist\\index.js"},{"name":"gl-matrix","loc":{"line":16,"column":28,"index":1090},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv1\\GLTFLoader.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\gl-matrix\\esm\\index.js"},{"name":"@shapediver/viewer.shared.types","loc":{"line":17,"column":38,"index":1143},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv1\\GLTFLoader.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.types\\dist\\index.js"},{"name":"./SDGTFLoader","loc":{"line":18,"column":30,"index":1210},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv1\\GLTFLoader.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.geometry-engine\\dist\\gltfv1\\SDGTFLoader.js"}],"generated":{"js":"\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GLTFLoader = void 0;\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst viewer_data_engine_shared_types_1 = require(\"@shapediver/viewer.data-engine.shared-types\");\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst SDGTFLoader_1 = require(\"./SDGTFLoader\");\r\nclass GLTFLoader {\r\n    constructor() {\r\n        // #region Properties (5)\r\n        this.BINARY_EXTENSION_HEADER_LENGTH = 20;\r\n        this._httpClient = viewer_shared_services_1.HttpClient.instance;\r\n        this._uuidGenerator = viewer_shared_services_1.UuidGenerator.instance;\r\n        this._logger = viewer_shared_services_1.Logger.instance;\r\n        this._implementedExtensions = ['KHR_materials_common'];\r\n        this._globalTransformation = gl_matrix_1.mat4.fromValues(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);\r\n        this._eventEngine = viewer_shared_services_1.EventEngine.instance;\r\n        this._performanceEvaluator = viewer_shared_services_1.PerformanceEvaluator.instance;\r\n        this._progressUpdateLimit = 500;\r\n        this._eventId = \"\";\r\n        this._numberOfNodes = 0;\r\n        this._numberOfConvertedNodes = 0;\r\n        this._progressTimer = 0;\r\n        // #endregion Private Methods (6)\r\n    }\r\n    // #endregion Properties (5)\r\n    // #region Public Methods (1)\r\n    load(content, gltfBinary, gltfHeader, baseUri, taskEventId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._eventId = taskEventId || this._uuidGenerator.create();\r\n            const eventStart = { type: viewer_shared_types_1.TASK_TYPE.GLTF_CONTENT_LOADING, id: this._eventId, progress: 0, status: 'Starting glTF 1.0 loading.' };\r\n            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, eventStart);\r\n            this._numberOfConvertedNodes = 0;\r\n            this._numberOfNodes = content.nodes ? Object.values(content.nodes).length : 0;\r\n            this._progressTimer = performance.now();\r\n            this._baseUri = baseUri;\r\n            if (gltfBinary && gltfHeader)\r\n                this._body = gltfBinary.slice(this.BINARY_EXTENSION_HEADER_LENGTH + gltfHeader.contentLength, gltfHeader.length);\r\n            this._content = content;\r\n            let sdgtfNode;\r\n            if (gltfBinary && gltfHeader)\r\n                sdgtfNode = yield new SDGTFLoader_1.SDGTFLoader().load(gltfBinary, gltfHeader.length);\r\n            const eventProgressSDgTF = { type: viewer_shared_types_1.TASK_TYPE.GLTF_CONTENT_LOADING, id: this._eventId, progress: 0.25, status: 'Loaded SDgTF content.' };\r\n            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventProgressSDgTF);\r\n            this.validateVersionAndExtensions();\r\n            const node = yield this.loadScene();\r\n            if (sdgtfNode)\r\n                node.addChild(sdgtfNode);\r\n            const eventEnd = { type: viewer_shared_types_1.TASK_TYPE.GLTF_CONTENT_LOADING, id: this._eventId, progress: 1, status: 'GlTF loading complete.' };\r\n            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, eventEnd);\r\n            return node;\r\n        });\r\n    }\r\n    loadWithUrl(url) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._performanceEvaluator.startSection('gltfProcessing.' + url);\r\n            let binaryGeometry;\r\n            this._performanceEvaluator.startSection('loadGltf.' + url);\r\n            binaryGeometry = (yield this._httpClient.get(url, {\r\n                responseType: 'arraybuffer'\r\n            })).data;\r\n            this._performanceEvaluator.endSection('loadGltf.' + url);\r\n            // create header data\r\n            const headerDataView = new DataView(binaryGeometry, 0, this.BINARY_EXTENSION_HEADER_LENGTH);\r\n            const header = {\r\n                magic: String.fromCharCode(headerDataView.getUint8(0)) + String.fromCharCode(headerDataView.getUint8(1)) + String.fromCharCode(headerDataView.getUint8(2)) + String.fromCharCode(headerDataView.getUint8(3)),\r\n                version: headerDataView.getUint32(4, true),\r\n                length: headerDataView.getUint32(8, true),\r\n                contentLength: headerDataView.getUint32(12, true),\r\n                contentFormat: headerDataView.getUint32(16, true)\r\n            };\r\n            if (header.magic != 'glTF')\r\n                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('GLTFLoader.load: Invalid data: glTF magic wrong.');\r\n            // create content\r\n            const contentDataView = new DataView(binaryGeometry, this.BINARY_EXTENSION_HEADER_LENGTH, header.contentLength);\r\n            const contentDecoded = new TextDecoder().decode(contentDataView);\r\n            this._content = JSON.parse(contentDecoded);\r\n            // create body\r\n            this._body = binaryGeometry.slice(this.BINARY_EXTENSION_HEADER_LENGTH + header.contentLength, header.length);\r\n            const sdgtfNode = yield new SDGTFLoader_1.SDGTFLoader().load(binaryGeometry, header.length);\r\n            this.validateVersionAndExtensions();\r\n            const node = yield this.loadScene();\r\n            node.addChild(sdgtfNode);\r\n            this._performanceEvaluator.endSection('gltfProcessing.' + url);\r\n            return node;\r\n        });\r\n    }\r\n    // #endregion Public Methods (1)\r\n    // #region Private Methods (6)\r\n    validateVersionAndExtensions() {\r\n        if (this._content.extensionsUsed) {\r\n            const notSupported = [];\r\n            for (let i = 0; i < this._content.extensionsUsed.length; i++) {\r\n                if (!this._implementedExtensions.includes(this._content.extensionsUsed[i]))\r\n                    notSupported.push(this._content.extensionsUsed[i]);\r\n            }\r\n            if (notSupported.length > 0) {\r\n                let message = 'Extension' + (notSupported.length === 1 ? ' ' : 's ');\r\n                notSupported.forEach((element, index) => {\r\n                    message += '\"' + element + '\"' + (index === notSupported.length - 1 ? '' : index === notSupported.length - 2 ? ' and ' : ', ');\r\n                });\r\n                message += (notSupported.length === 1 ? ' is' : ' are') + ' not supported, but used. Loading glTF regardless.';\r\n                this._logger.info('GLTFLoader.validateVersionAndExtensions: ' + message);\r\n            }\r\n        }\r\n    }\r\n    loadAccessor(accessorName) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.accessors[accessorName])\r\n                throw new Error('Accessor not available.');\r\n            const accessor = this._content.accessors[accessorName];\r\n            const bufferView = yield this.loadBufferView(accessor.bufferView);\r\n            const itemSize = viewer_data_engine_shared_types_1.ACCESSORTYPE_V1[accessor.type];\r\n            if (accessor.componentType === 5124)\r\n                this._logger.warn('GLTFLoader.loadAccessor: The componentType for this accessor is 5124, which is not allowed. Trying to load it anyway.');\r\n            const ArrayType = viewer_data_engine_shared_types_1.ACCESSORCOMPONENTTYPE_V1[accessor.componentType];\r\n            const elementBytes = ArrayType.BYTES_PER_ELEMENT;\r\n            const itemBytes = elementBytes * itemSize;\r\n            const byteOffset = accessor.byteOffset || 0;\r\n            const byteStride = accessor.byteStride;\r\n            const normalized = false;\r\n            const target = this._content.bufferViews[accessor.bufferView] ? this._content.bufferViews[accessor.bufferView].target : undefined;\r\n            const min = this._content.asset && ((_a = this._content.asset) === null || _a === void 0 ? void 0 : _a.generator) === \"ShapeDiverGltfV1Writer\" ? accessor.min || [] : [];\r\n            const max = this._content.asset && ((_b = this._content.asset) === null || _b === void 0 ? void 0 : _b.generator) === \"ShapeDiverGltfV1Writer\" ? accessor.max || [] : [];\r\n            // The buffer is not interleaved if the stride is the item size in bytes.\r\n            return new viewer_shared_types_1.AttributeData(new ArrayType(bufferView), itemSize, itemBytes, byteOffset, elementBytes, normalized, accessor.count, min, max, byteStride, target);\r\n        });\r\n    }\r\n    loadBuffer(bufferName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.buffers[bufferName])\r\n                throw new Error('Buffer not available.');\r\n            const buffer = this._content.buffers[bufferName];\r\n            if (bufferName === 'binary_glTF')\r\n                return this._body;\r\n            if (buffer.type === 'arraybuffer') {\r\n                const binaryGeometry = (yield this._httpClient.get(buffer.uri, {\r\n                    responseType: 'arraybuffer'\r\n                })).data;\r\n                return binaryGeometry;\r\n            }\r\n            if (!this._body)\r\n                throw new Error('Buffer not available.');\r\n            return this._body;\r\n        });\r\n    }\r\n    loadBufferView(bufferViewName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.bufferViews[bufferViewName])\r\n                throw new Error('Buffer View not available.');\r\n            const bufferView = this._content.bufferViews[bufferViewName];\r\n            const buffer = yield this.loadBuffer(bufferView.buffer);\r\n            const byteLength = bufferView.byteLength !== undefined ? bufferView.byteLength : 0;\r\n            return buffer.slice(bufferView.byteOffset, bufferView.byteOffset + byteLength);\r\n        });\r\n    }\r\n    loadMaterial(materialName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.materials[materialName])\r\n                throw new Error('Material not available.');\r\n            const material = this._content.materials[materialName];\r\n            const materialData = new viewer_shared_types_1.MaterialStandardData();\r\n            if (material.name !== undefined)\r\n                materialData.name = material.name;\r\n            if (material.extensions && material.extensions.KHR_materials_common) {\r\n                const technique = material.extensions.KHR_materials_common.technique;\r\n                if (technique && technique !== 'BLINN')\r\n                    this._logger.warn('The technique ' + technique + ' is not supported. Trying to load the material either way.');\r\n                const values = material.extensions.KHR_materials_common.values;\r\n                if (values.hasOwnProperty('doubleSided'))\r\n                    materialData.side = values.doubleSided ? viewer_shared_types_1.MATERIAL_SIDE.DOUBLE : viewer_shared_types_1.MATERIAL_SIDE.FRONT;\r\n                materialData.color = '#d3d3d3';\r\n                if (values.hasOwnProperty('diffuse') && Array.isArray(values.diffuse)) {\r\n                    const diffuseScaled = values.diffuse.map(element => element *= 255.0);\r\n                    materialData.color = diffuseScaled;\r\n                    materialData.opacity = Math.max(0.0, Math.min(values.diffuse[3], 1.0));\r\n                }\r\n                else if (values.hasOwnProperty('diffuse')) {\r\n                    this._logger.warn('GLTFLoader.loadMaterial: The value diffuse was set for a material, but is not supported in that type.');\r\n                }\r\n                if (!values.hasOwnProperty('diffuse') && values.hasOwnProperty('ambient')) {\r\n                    const ambientScaled = values.ambient.map(element => element *= 255.0);\r\n                    materialData.color = ambientScaled;\r\n                }\r\n                if (values.hasOwnProperty('emission') && Array.isArray(values.emission)) {\r\n                    materialData.emissiveness = values.emission;\r\n                }\r\n                else if (values.hasOwnProperty('emission')) {\r\n                    this._logger.warn('GLTFLoader.loadMaterial: The value emission was set for a material, but is not supported in that type.');\r\n                }\r\n                if (values.hasOwnProperty('shininess')) {\r\n                    materialData.metalness = Math.min(1, values.shininess);\r\n                    materialData.roughness = 1 - Math.min(1, values.shininess);\r\n                }\r\n                if (values.hasOwnProperty('transparency'))\r\n                    materialData.opacity = Math.max(0.0, Math.min(values.transparency, 1.0));\r\n                if (!values.hasOwnProperty('transparency') && values.hasOwnProperty('transparent') && (values.transparency === 'true' || values.transparency === true))\r\n                    materialData.opacity = 0;\r\n                if (values.hasOwnProperty('_roughness'))\r\n                    materialData.roughness = Math.min(1, Math.max(0, values.roughness));\r\n                if (values.hasOwnProperty('_metalness'))\r\n                    materialData.metalness = Math.min(1, Math.max(0, values.metalness));\r\n            }\r\n            return materialData;\r\n        });\r\n    }\r\n    loadMesh(meshName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.meshes[meshName])\r\n                throw new Error('Mesh not available.');\r\n            const mesh = this._content.meshes[meshName];\r\n            const meshNode = new viewer_shared_node_tree_1.TreeNode(meshName);\r\n            if (!mesh.primitives)\r\n                return new viewer_shared_node_tree_1.TreeNode('primitive');\r\n            for (let i = 0, len = mesh.primitives.length; i < len; i++) {\r\n                const primitiveNode = new viewer_shared_node_tree_1.TreeNode('primitive_' + i);\r\n                meshNode.addChild(primitiveNode);\r\n                let primitive = mesh.primitives[i];\r\n                const attributes = {};\r\n                for (let attribute in primitive.attributes) {\r\n                    // attribute name conversion to be consistent witg gltf\r\n                    let attributeName = attribute;\r\n                    if (/\\d/.test(attributeName) && !attributeName.includes('_')) {\r\n                        const index = attributeName.search(/\\d/);\r\n                        attributeName = attributeName.substring(0, index) + '_' + attributeName.substring(index, attributeName.length);\r\n                    }\r\n                    else if (attributeName === 'TEXCOORD' || attributeName === 'COLOR' || attributeName === 'JOINTS' || attributeName === 'WEIGHTS') {\r\n                        attributeName += '_0';\r\n                    }\r\n                    else if (attributeName === 'UV') {\r\n                        attributeName = 'TEXCOORD_0';\r\n                    }\r\n                    attributes[attributeName] = yield this.loadAccessor(primitive.attributes[attribute]);\r\n                    if (attributeName.startsWith('COLOR'))\r\n                        attributes[attributeName] = new viewer_shared_types_1.AttributeData(attributes[attributeName].array, attributes[attributeName].itemSize, attributes[attributeName].itemBytes, attributes[attributeName].byteOffset, attributes[attributeName].elementBytes, true, attributes[attributeName].count, [], [], attributes[attributeName].byteStride, attributes[attributeName].target);\r\n                }\r\n                let material;\r\n                if (primitive.material)\r\n                    material = yield this.loadMaterial(primitive.material);\r\n                const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, yield this.loadAccessor(primitive.indices)), viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLES, material);\r\n                primitiveNode.data.push(geometry);\r\n            }\r\n            return meshNode;\r\n        });\r\n    }\r\n    loadNode(nodeName) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.nodes[nodeName])\r\n                throw new Error('Node not available.');\r\n            const node = this._content.nodes[nodeName];\r\n            const nodeDef = new viewer_shared_node_tree_1.TreeNode(nodeName);\r\n            if (node.matrix) {\r\n                nodeDef.addTransformation({\r\n                    id: this._uuidGenerator.create(),\r\n                    matrix: gl_matrix_1.mat4.fromValues(node.matrix[0], node.matrix[1], node.matrix[2], node.matrix[3], node.matrix[4], node.matrix[5], node.matrix[6], node.matrix[7], node.matrix[8], node.matrix[9], node.matrix[10], node.matrix[11], node.matrix[12], node.matrix[13], node.matrix[14], node.matrix[15])\r\n                });\r\n            }\r\n            else if (node.translation || node.scale || node.rotation) {\r\n                const matT = node.translation ? gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(node.translation[0], node.translation[1], node.translation[2])) : gl_matrix_1.mat4.create();\r\n                const matS = node.scale ? gl_matrix_1.mat4.fromScaling(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(node.scale[0], node.scale[1], node.scale[2])) : gl_matrix_1.mat4.create();\r\n                const matR = node.rotation ? gl_matrix_1.mat4.fromQuat(gl_matrix_1.mat4.create(), gl_matrix_1.vec4.fromValues(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3])) : gl_matrix_1.mat4.create();\r\n                const matrix = gl_matrix_1.mat4.mul(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.mul(gl_matrix_1.mat4.create(), matT, matS), matR);\r\n                nodeDef.addTransformation({\r\n                    id: this._uuidGenerator.create(),\r\n                    matrix: matrix\r\n                });\r\n            }\r\n            if (node.meshes) {\r\n                for (let i = 0, len = node.meshes.length; i < len; i++) {\r\n                    // we create a child node as we one want to have one mesh as in the GLTF2 def\r\n                    nodeDef.addChild(yield this.loadMesh(node.meshes[i]));\r\n                }\r\n            }\r\n            if (node.children) {\r\n                for (let i = 0, len = node.children.length; i < len; i++) {\r\n                    // got through all children\r\n                    nodeDef.addChild(yield this.loadNode(node.children[i]));\r\n                }\r\n            }\r\n            this._numberOfConvertedNodes++;\r\n            if (performance.now() - this._progressTimer > this._progressUpdateLimit) {\r\n                this._progressTimer = performance.now();\r\n                const eventProgress = { type: viewer_shared_types_1.TASK_TYPE.GLTF_CONTENT_LOADING, id: this._eventId, progress: (this._numberOfConvertedNodes / this._numberOfNodes) / 2 + 0.25, status: `GlTF conversion progress: ${this._numberOfConvertedNodes}/${this._numberOfNodes} nodes.` };\r\n                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventProgress);\r\n                yield new Promise(resolve => setTimeout(resolve, 0));\r\n            }\r\n            return nodeDef;\r\n        });\r\n    }\r\n    loadScene() {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this._content.scene)\r\n                throw new Error('No scene.');\r\n            if (!this._content.scenes[this._content.scene])\r\n                throw new Error('Scene not available.');\r\n            const scene = this._content.scenes[this._content.scene];\r\n            const sceneDef = new viewer_shared_node_tree_1.TreeNode(this._content.scene);\r\n            if (this._content.asset && ((_a = this._content.asset) === null || _a === void 0 ? void 0 : _a.generator) !== \"ShapeDiverGltfWriter\" && ((_b = this._content.asset) === null || _b === void 0 ? void 0 : _b.generator) !== \"ShapeDiverGltfV1Writer\") {\r\n                sceneDef.addTransformation({\r\n                    id: this._uuidGenerator.create(),\r\n                    matrix: this._globalTransformation\r\n                });\r\n            }\r\n            if (scene.nodes)\r\n                for (let i = 0, len = scene.nodes.length; i < len; i++)\r\n                    sceneDef.addChild(yield this.loadNode(scene.nodes[i]));\r\n            return sceneDef;\r\n        });\r\n    }\r\n}\r\nexports.GLTFLoader = GLTFLoader;\r\n"},"sourceMaps":{"js":{"version":3,"file":"GLTFLoader.js","sourceRoot":"","sources":["../../src/gltfv1/GLTFLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import { ITreeNode, TreeNode } from '@shapediver/viewer.shared.node-tree'\r\nimport { Converter, HttpClient, PerformanceEvaluator, UuidGenerator, Logger, ShapeDiverViewerDataProcessingError, EventEngine, EVENTTYPE } from '@shapediver/viewer.shared.services'\r\nimport {\r\n  ACCESSORCOMPONENTTYPE_V1 as ACCESSOR_COMPONENTTYPE,\r\n  ACCESSORTYPE_V1 as ACCESSORTYPE,\r\n  IGLTF_v1,\r\n  IGLTF_v1_Material,\r\n} from '@shapediver/viewer.data-engine.shared-types'\r\nimport { mat4, vec3, vec4 } from 'gl-matrix'\r\nimport {\r\n  AttributeData,\r\n  GeometryData,\r\n  MATERIAL_SIDE,\r\n  MaterialStandardData,\r\n  PrimitiveData,\r\n  ITaskEvent,\r\n  TASK_TYPE,\r\n  PRIMITIVE_MODE,\r\n} from '@shapediver/viewer.shared.types'\r\n\r\nimport { SDGTFLoader } from './SDGTFLoader'\r\n\r\nexport class GLTFLoader {\r\n    // #region Properties (5)\r\n\r\n    private readonly BINARY_EXTENSION_HEADER_LENGTH = 20;\r\n    private readonly _httpClient: HttpClient = HttpClient.instance;\r\n    private readonly _uuidGenerator: UuidGenerator = UuidGenerator.instance;\r\n    private readonly _logger: Logger = Logger.instance;\r\n    private readonly _implementedExtensions = ['KHR_materials_common'];\r\n    private readonly _globalTransformation = mat4.fromValues(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);\r\n    private readonly _eventEngine: EventEngine = EventEngine.instance;\r\n    private readonly _performanceEvaluator = PerformanceEvaluator.instance;\r\n    private readonly _progressUpdateLimit = 500;\r\n\r\n    private _baseUri: string | undefined;\r\n    private _body: ArrayBuffer | undefined;\r\n    private _content!: IGLTF_v1;\r\n    private _eventId: string = \"\";\r\n    private _numberOfNodes = 0;\r\n    private _numberOfConvertedNodes = 0;\r\n    private _progressTimer = 0;\r\n\r\n    // #endregion Properties (5)\r\n\r\n    // #region Public Methods (1)\r\n\r\n    public async load(content: IGLTF_v1, gltfBinary?: ArrayBuffer, gltfHeader?: { magic: string, version: number, length: number, contentLength: number, contentFormat: number }, baseUri?: string, taskEventId?: string): Promise<ITreeNode> {\r\n        this._eventId = taskEventId || this._uuidGenerator.create();\r\n        const eventStart: ITaskEvent = { type: TASK_TYPE.GLTF_CONTENT_LOADING, id: this._eventId, progress: 0, status: 'Starting glTF 1.0 loading.' };\r\n        this._eventEngine.emitEvent(EVENTTYPE.TASK.TASK_START, eventStart);\r\n        \r\n        this._numberOfConvertedNodes = 0;\r\n        this._numberOfNodes = content.nodes ? Object.values(content.nodes).length : 0;\r\n        this._progressTimer = performance.now();\r\n        \r\n        this._baseUri = baseUri;\r\n        if(gltfBinary && gltfHeader)\r\n            this._body = gltfBinary.slice(this.BINARY_EXTENSION_HEADER_LENGTH + gltfHeader.contentLength, gltfHeader.length);\r\n        this._content = content;\r\n\r\n        let sdgtfNode;\r\n        if(gltfBinary && gltfHeader)\r\n            sdgtfNode = await new SDGTFLoader().load(gltfBinary, gltfHeader.length);\r\n\r\n            \r\n        const eventProgressSDgTF: ITaskEvent = { type: TASK_TYPE.GLTF_CONTENT_LOADING, id: this._eventId, progress: 0.25, status: 'Loaded SDgTF content.' };\r\n        this._eventEngine.emitEvent(EVENTTYPE.TASK.TASK_PROCESS, eventProgressSDgTF);\r\n\r\n\r\n        this.validateVersionAndExtensions();\r\n        const node = await this.loadScene();\r\n        if(sdgtfNode) node.addChild(sdgtfNode);\r\n\r\n        const eventEnd: ITaskEvent = { type: TASK_TYPE.GLTF_CONTENT_LOADING, id: this._eventId, progress: 1, status: 'GlTF loading complete.' };\r\n        this._eventEngine.emitEvent(EVENTTYPE.TASK.TASK_END, eventEnd);\r\n\r\n        return node;\r\n    }\r\n\r\n    public async loadWithUrl(url?: string | undefined): Promise<ITreeNode> {\r\n        this._performanceEvaluator.startSection('gltfProcessing.' + url);\r\n        let binaryGeometry: ArrayBuffer;\r\n\r\n        this._performanceEvaluator.startSection('loadGltf.' + url);\r\n        binaryGeometry = (await this._httpClient.get(url!, {\r\n            responseType: 'arraybuffer'\r\n        })).data;\r\n        this._performanceEvaluator.endSection('loadGltf.' + url);\r\n\r\n        // create header data\r\n        const headerDataView = new DataView(binaryGeometry, 0, this.BINARY_EXTENSION_HEADER_LENGTH);\r\n        const header = {\r\n            magic: String.fromCharCode(headerDataView.getUint8(0)) + String.fromCharCode(headerDataView.getUint8(1)) + String.fromCharCode(headerDataView.getUint8(2)) + String.fromCharCode(headerDataView.getUint8(3)),\r\n            version: headerDataView.getUint32(4, true),\r\n            length: headerDataView.getUint32(8, true),\r\n            contentLength: headerDataView.getUint32(12, true),\r\n            contentFormat: headerDataView.getUint32(16, true)\r\n        }\r\n        if (header.magic != 'glTF') \r\n            throw new ShapeDiverViewerDataProcessingError('GLTFLoader.load: Invalid data: glTF magic wrong.');\r\n\r\n        // create content\r\n        const contentDataView = new DataView(binaryGeometry, this.BINARY_EXTENSION_HEADER_LENGTH, header.contentLength);\r\n        const contentDecoded = new TextDecoder().decode(contentDataView);\r\n        this._content = JSON.parse(contentDecoded);\r\n\r\n        // create body\r\n        this._body = binaryGeometry.slice(this.BINARY_EXTENSION_HEADER_LENGTH + header.contentLength, header.length);\r\n\r\n        const sdgtfNode = await new SDGTFLoader().load(binaryGeometry, header.length);\r\n\r\n        this.validateVersionAndExtensions();\r\n        const node = await this.loadScene();\r\n        node.addChild(sdgtfNode);\r\n        this._performanceEvaluator.endSection('gltfProcessing.' + url);\r\n        return node;\r\n    }\r\n\r\n    // #endregion Public Methods (1)\r\n\r\n    // #region Private Methods (6)\r\n\r\n    private validateVersionAndExtensions(): void {\r\n        if(this._content.extensionsUsed) {\r\n            const notSupported = [];\r\n            for(let i = 0; i < this._content.extensionsUsed.length; i++) {\r\n                if(!this._implementedExtensions.includes(this._content.extensionsUsed[i])) \r\n                    notSupported.push(this._content.extensionsUsed[i]);\r\n            }\r\n            if(notSupported.length > 0) {\r\n                let message = 'Extension' + (notSupported.length === 1 ? ' ' : 's ');\r\n                notSupported.forEach((element, index) => {\r\n                    message += '\"' + element + '\"' + (index === notSupported.length-1 ? '' : index === notSupported.length-2 ? ' and ' : ', ');\r\n                });\r\n                message += (notSupported.length === 1 ? ' is' : ' are') + ' not supported, but used. Loading glTF regardless.';\r\n                this._logger.info('GLTFLoader.validateVersionAndExtensions: ' + message);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async loadAccessor(accessorName: string): Promise<AttributeData> {\r\n        if (!this._content.accessors![accessorName]) throw new Error('Accessor not available.')\r\n        const accessor = this._content.accessors![accessorName];\r\n        const bufferView = await this.loadBufferView(accessor.bufferView!);\r\n\r\n        const itemSize = ACCESSORTYPE[<keyof typeof ACCESSORTYPE>accessor.type];\r\n        if(accessor.componentType === 5124) this._logger.warn('GLTFLoader.loadAccessor: The componentType for this accessor is 5124, which is not allowed. Trying to load it anyway.');\r\n        const ArrayType = ACCESSOR_COMPONENTTYPE[<keyof typeof ACCESSOR_COMPONENTTYPE>accessor.componentType];\r\n        const elementBytes = ArrayType.BYTES_PER_ELEMENT;\r\n        const itemBytes = elementBytes * itemSize;\r\n\r\n        const byteOffset = accessor.byteOffset || 0;\r\n        const byteStride = accessor.byteStride;\r\n        const normalized = false;\r\n        const target = this._content.bufferViews![accessor.bufferView] ? this._content.bufferViews![accessor.bufferView].target : undefined;\r\n\r\n        const min = this._content.asset && this._content.asset?.generator === \"ShapeDiverGltfV1Writer\" ? accessor.min || [] : [];\r\n        const max = this._content.asset && this._content.asset?.generator === \"ShapeDiverGltfV1Writer\" ? accessor.max || [] : [];\r\n\r\n        // The buffer is not interleaved if the stride is the item size in bytes.\r\n        return new AttributeData(new ArrayType(bufferView), itemSize, itemBytes, byteOffset, elementBytes, normalized, accessor.count, min, max, byteStride, target);\r\n    }\r\n\r\n    private async loadBuffer(bufferName: string): Promise<ArrayBuffer> {\r\n        if (!this._content.buffers![bufferName]) throw new Error('Buffer not available.')\r\n        const buffer = this._content.buffers![bufferName];\r\n\r\n        if (bufferName === 'binary_glTF')\r\n            return this._body!;\r\n\r\n        if (buffer.type === 'arraybuffer') {\r\n            const binaryGeometry: ArrayBuffer = (await this._httpClient.get(buffer.uri!, {\r\n                responseType: 'arraybuffer'\r\n            })).data;\r\n            return binaryGeometry;\r\n        }\r\n        if(!this._body) throw new Error('Buffer not available.');\r\n        return this._body;\r\n    }\r\n\r\n    private async loadBufferView(bufferViewName: string): Promise<ArrayBuffer> {\r\n        if (!this._content.bufferViews![bufferViewName]) throw new Error('Buffer View not available.')\r\n        const bufferView = this._content.bufferViews![bufferViewName];\r\n        const buffer: ArrayBuffer = await this.loadBuffer(bufferView.buffer!);\r\n        const byteLength = bufferView.byteLength !== undefined ? bufferView.byteLength : 0;\r\n\r\n        return buffer.slice(bufferView.byteOffset!, bufferView.byteOffset! + byteLength);\r\n    }\r\n\r\n\r\n    private async loadMaterial(materialName: string): Promise<MaterialStandardData> {\r\n        if(!this._content.materials![materialName]) throw new Error('Material not available.')\r\n        const material: IGLTF_v1_Material = this._content.materials![materialName];\r\n        const materialData = new MaterialStandardData();\r\n        if(material.name !== undefined) materialData.name = material.name;\r\n\r\n        if(material.extensions && material.extensions.KHR_materials_common) {\r\n            const technique = material.extensions.KHR_materials_common.technique;\r\n            if(technique && technique !== 'BLINN') this._logger.warn('The technique ' + technique + ' is not supported. Trying to load the material either way.')\r\n            const values = material.extensions.KHR_materials_common.values;\r\n\r\n            if (values.hasOwnProperty('doubleSided')) \r\n                materialData.side = values.doubleSided ? MATERIAL_SIDE.DOUBLE : MATERIAL_SIDE.FRONT;\r\n\r\n            materialData.color = '#d3d3d3';\r\n            if (values.hasOwnProperty('diffuse') && Array.isArray(values.diffuse)) {\r\n                const diffuseScaled = (<number[]>values.diffuse).map(element => element *= 255.0);\r\n                materialData.color = diffuseScaled;\r\n                materialData.opacity = Math.max(0.0, Math.min(values.diffuse[3], 1.0));\r\n            } else if(values.hasOwnProperty('diffuse')) {\r\n                this._logger.warn('GLTFLoader.loadMaterial: The value diffuse was set for a material, but is not supported in that type.')\r\n            }\r\n            \r\n            if (!values.hasOwnProperty('diffuse') && values.hasOwnProperty('ambient')) {\r\n                const ambientScaled = (<number[]>values.ambient).map(element => element *= 255.0);\r\n                materialData.color = ambientScaled;\r\n            }\r\n\r\n            if (values.hasOwnProperty('emission') && Array.isArray(values.emission)) {\r\n                materialData.emissiveness = values.emission;\r\n            } else if (values.hasOwnProperty('emission')) {\r\n                this._logger.warn('GLTFLoader.loadMaterial: The value emission was set for a material, but is not supported in that type.')\r\n            }\r\n\r\n            if (values.hasOwnProperty('shininess')) {\r\n                materialData.metalness = Math.min(1, values.shininess);\r\n                materialData.roughness = 1 - Math.min(1, values.shininess);\r\n            }\r\n\r\n            if (values.hasOwnProperty('transparency')) \r\n                materialData.opacity = Math.max(0.0, Math.min(values.transparency, 1.0));\r\n\r\n            if (!values.hasOwnProperty('transparency') && values.hasOwnProperty('transparent') && (values.transparency === 'true' || values.transparency === true))\r\n                materialData.opacity = 0;\r\n\r\n            if (values.hasOwnProperty('_roughness'))\r\n                materialData.roughness = Math.min(1, Math.max(0, values.roughness));\r\n\r\n            if (values.hasOwnProperty('_metalness'))\r\n                materialData.metalness = Math.min(1, Math.max(0, values.metalness));\r\n        }\r\n        return materialData;\r\n    }\r\n\r\n    private async loadMesh(meshName: string): Promise<ITreeNode> {\r\n        if (!this._content.meshes![meshName]) throw new Error('Mesh not available.')\r\n        const mesh = this._content.meshes![meshName];\r\n        const meshNode = new TreeNode(meshName);\r\n\r\n        if(!mesh.primitives) return new TreeNode('primitive');\r\n        for (let i = 0, len = mesh.primitives!.length; i < len; i++) {\r\n            const primitiveNode = new TreeNode('primitive_' + i);\r\n            meshNode.addChild(primitiveNode);\r\n            \r\n            let primitive = mesh.primitives![i];\r\n            const attributes: {\r\n                [key: string]: AttributeData\r\n            } = {};\r\n\r\n            for (let attribute in primitive.attributes) {\r\n                // attribute name conversion to be consistent witg gltf\r\n                let attributeName = attribute;\r\n                if(/\\d/.test(attributeName) && !attributeName.includes('_')) {\r\n                    const index = attributeName.search(/\\d/)\r\n                    attributeName = attributeName.substring(0, index) + '_' + attributeName.substring(index, attributeName.length);\r\n                } else if(attributeName === 'TEXCOORD' || attributeName === 'COLOR' || attributeName === 'JOINTS' || attributeName === 'WEIGHTS') {\r\n                    attributeName += '_0';\r\n                } else if (attributeName === 'UV') {\r\n                    attributeName = 'TEXCOORD_0';\r\n                }\r\n\r\n                attributes[attributeName] = await this.loadAccessor(primitive.attributes[attribute]);\r\n                if(attributeName.startsWith('COLOR'))\r\n                    attributes[attributeName] = new AttributeData(attributes[attributeName].array, attributes[attributeName].itemSize, attributes[attributeName].itemBytes, attributes[attributeName].byteOffset, attributes[attributeName].elementBytes, true, attributes[attributeName].count, [], [], attributes[attributeName].byteStride, attributes[attributeName].target)\r\n            }\r\n\r\n            let material: MaterialStandardData | undefined;\r\n            if(primitive.material) \r\n                material = await this.loadMaterial(primitive.material);\r\n\r\n            const geometry = new GeometryData(new PrimitiveData(attributes, await this.loadAccessor(primitive.indices!)), PRIMITIVE_MODE.TRIANGLES, material);\r\n            primitiveNode.data.push(geometry);\r\n        }\r\n        return meshNode;\r\n    }\r\n\r\n    private async loadNode(nodeName: string): Promise<ITreeNode> {\r\n        if (!this._content.nodes![nodeName]) throw new Error('Node not available.')\r\n        const node = this._content.nodes![nodeName];\r\n        const nodeDef = new TreeNode(nodeName);\r\n\r\n        if (node.matrix) {\r\n            nodeDef.addTransformation({\r\n                id: this._uuidGenerator.create(),\r\n                matrix: mat4.fromValues(node.matrix[0], node.matrix[1], node.matrix[2], node.matrix[3],\r\n                node.matrix[4], node.matrix[5], node.matrix[6], node.matrix[7],\r\n                node.matrix[8], node.matrix[9], node.matrix[10], node.matrix[11],\r\n                node.matrix[12], node.matrix[13], node.matrix[14], node.matrix[15])\r\n            });\r\n        } else if (node.translation || node.scale || node.rotation) {\r\n            const matT = node.translation ? mat4.fromTranslation(mat4.create(), vec3.fromValues(node.translation[0], node.translation[1], node.translation[2])) : mat4.create();\r\n            const matS = node.scale ? mat4.fromScaling(mat4.create(), vec3.fromValues(node.scale[0], node.scale[1], node.scale[2])) : mat4.create();\r\n            const matR = node.rotation ? mat4.fromQuat(mat4.create(), vec4.fromValues(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3])) : mat4.create();\r\n            const matrix = mat4.mul(mat4.create(), mat4.mul(mat4.create(), matT, matS), matR);\r\n            nodeDef.addTransformation({\r\n                id: this._uuidGenerator.create(),\r\n                matrix: matrix\r\n            });\r\n        }\r\n\r\n        if(node.meshes) {\r\n            for (let i = 0, len = node.meshes!.length; i < len; i++) {\r\n                // we create a child node as we one want to have one mesh as in the GLTF2 def\r\n                nodeDef.addChild(await this.loadMesh(node.meshes![i]));\r\n            }\r\n        }\r\n\r\n        if (node.children) {\r\n            for (let i = 0, len = node.children!.length; i < len; i++) {\r\n                // got through all children\r\n                nodeDef.addChild(await this.loadNode(node.children![i]));\r\n            }\r\n        }\r\n\r\n        \r\n        this._numberOfConvertedNodes++;\r\n\r\n        if(performance.now() - this._progressTimer > this._progressUpdateLimit) {\r\n            this._progressTimer = performance.now();\r\n            const eventProgress: ITaskEvent = { type: TASK_TYPE.GLTF_CONTENT_LOADING, id: this._eventId, progress: (this._numberOfConvertedNodes / this._numberOfNodes) / 2 + 0.25, status: `GlTF conversion progress: ${this._numberOfConvertedNodes}/${this._numberOfNodes} nodes.` };\r\n            this._eventEngine.emitEvent(EVENTTYPE.TASK.TASK_PROCESS, eventProgress);\r\n            await new Promise(resolve => setTimeout(resolve, 0));\r\n        }\r\n\r\n        return nodeDef;\r\n    }\r\n\r\n    private async loadScene(): Promise<ITreeNode> {\r\n        if (!this._content.scene) throw new Error('No scene.')\r\n        if (!this._content.scenes![this._content.scene!]) throw new Error('Scene not available.')\r\n        const scene = this._content.scenes![this._content.scene!];\r\n        const sceneDef = new TreeNode(this._content.scene!);\r\n        if(this._content.asset && this._content.asset?.generator !== \"ShapeDiverGltfWriter\" && this._content.asset?.generator !== \"ShapeDiverGltfV1Writer\") {\r\n            sceneDef.addTransformation({\r\n                id: this._uuidGenerator.create(),\r\n                matrix: this._globalTransformation\r\n            })\r\n        }\r\n        if(scene.nodes)\r\n            for (let i = 0, len = scene.nodes!.length; i < len; i++)\r\n                sceneDef.addChild(await this.loadNode(scene.nodes![i]));\r\n        return sceneDef;\r\n    }\r\n    // #endregion Private Methods (6)\r\n}"]}},"error":null,"hash":"ab293ed994fd8716db3f0c65bcf0ca70","cacheData":{"env":{}}}