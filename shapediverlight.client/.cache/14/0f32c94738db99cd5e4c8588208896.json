{"id":"node_modules/@shapediver/viewer.rendering-engine-threejs.standard/dist/shaders/PCSS.js","dependencies":[{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\dist\\shaders\\PCSS.js.map","includedInParent":true,"mtime":1706542086985},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\src\\shaders\\PCSS.ts","includedInParent":true,"mtime":1706542087461},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\package.json","includedInParent":true,"mtime":1706542184022},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\package.json","includedInParent":true,"mtime":1706542086641}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.entry = exports.main = void 0;\r\nexports.main = `\r\n\r\nuniform float lightSizeUV;\r\nuniform float blending;\r\n\r\n#ifdef SHADOWMAP_TYPE_PCF\r\n\r\n#define NEAR_PLANE 0.1\r\n#define NUM_SAMPLES 20\r\n#define NUM_RINGS 11\r\n\r\nvec2 poissonDisk[NUM_SAMPLES];\r\n\r\nvoid initPoissonSamples( const in vec2 randomSeed ) {\r\n    float ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\r\n    float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\r\n\r\n    // jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\r\n    float angle = rand(randomSeed) * PI2;\r\n    float radius = INV_NUM_SAMPLES;\r\n    float radiusStep = radius;\r\n\r\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\r\n        poissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\r\n        radius += radiusStep;\r\n        angle += ANGLE_STEP;\r\n    }\r\n}\r\n\r\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\r\n    return (zReceiver - zBlocker) / zBlocker;\r\n}\r\n\r\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\r\n    // This uses similar triangles to compute what\r\n    // area of the shadow map we should search\r\n    float searchRadius = lightSizeUV * (zReceiver - NEAR_PLANE) / zReceiver;\r\n    float blockerDepthSum = 0.0;\r\n    int numBlockers = 0;\r\n\r\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\r\n        float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\r\n        if (shadowMapDepth < zReceiver) {\r\n            blockerDepthSum += shadowMapDepth;\r\n            numBlockers++;\r\n        }\r\n    }\r\n\r\n    if (numBlockers == 0) return -1.0;\r\n\r\n    return blockerDepthSum / float(numBlockers);\r\n}\r\n\r\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\r\n    float sum = 0.0;\r\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\r\n        float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * filterRadius));\r\n        if (zReceiver <= depth) sum += 1.0;\r\n    }\r\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\r\n        float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[i].yx * filterRadius));\r\n        if (zReceiver <= depth) sum += 1.0;\r\n    }\r\n    return sum / (2.0 * float(NUM_SAMPLES));\r\n}\r\n\r\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\r\n    vec2 uv = coords.xy;\r\n    float zReceiver = coords.z; // Assumed to be eye-space z in this code\r\n\r\n    initPoissonSamples(uv);\r\n    // STEP 1: blocker search\r\n    float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\r\n\r\n    //There are no occluders so early out (this saves filtering)\r\n    if (avgBlockerDepth == -1.0) return 1.0;\r\n\r\n    // STEP 2: penumbra size\r\n    float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\r\n    float filterRadius = penumbraRatio * lightSizeUV * NEAR_PLANE / zReceiver;\r\n\r\n    // STEP 3: filtering\r\n    //return avgBlockerDepth;\r\n    return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\r\n}\r\n#endif\r\n`;\r\nexports.entry = `\r\n// PCSS implementation\r\nvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\nfloat dx = texelSize.x;\r\nfloat dy = texelSize.y;\r\nvec2 uv = shadowCoord.xy;\r\nvec2 f = fract( uv * shadowMapSize + 0.5 );\r\nuv -= f * texelSize;\r\nfloat shadow1 = (\r\n    texture2DCompare( shadowMap, uv, shadowCoord.z ) +\r\n    texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\r\n    texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\r\n    texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\r\n    mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \r\n         texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\r\n         f.x ) +\r\n    mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \r\n         texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\r\n         f.x ) +\r\n    mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \r\n         texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\r\n         f.y ) +\r\n    mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \r\n         texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\r\n         f.y ) +\r\n    mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \r\n              texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\r\n              f.x ),\r\n         mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \r\n              texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\r\n              f.x ),\r\n         f.y )\r\n) * ( 1.0 / 9.0 );\r\nfloat shadow2 = PCSS( shadowMap, shadowCoord );\r\nshadow = shadow1 * (1.0 - blending) + blending * shadow2;\r\n            `;\r\n"},"sourceMaps":{"js":{"version":3,"file":"PCSS.js","sourceRoot":"","sources":["../../src/shaders/PCSS.ts"],"names":[],"mappings":";;;AAAa,QAAA,IAAI,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsFnB,CAAC;AAEW,QAAA,KAAK,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;aAmCR,CAAA","sourcesContent":["export const main = `\r\n\r\nuniform float lightSizeUV;\r\nuniform float blending;\r\n\r\n#ifdef SHADOWMAP_TYPE_PCF\r\n\r\n#define NEAR_PLANE 0.1\r\n#define NUM_SAMPLES 20\r\n#define NUM_RINGS 11\r\n\r\nvec2 poissonDisk[NUM_SAMPLES];\r\n\r\nvoid initPoissonSamples( const in vec2 randomSeed ) {\r\n    float ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\r\n    float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\r\n\r\n    // jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\r\n    float angle = rand(randomSeed) * PI2;\r\n    float radius = INV_NUM_SAMPLES;\r\n    float radiusStep = radius;\r\n\r\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\r\n        poissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\r\n        radius += radiusStep;\r\n        angle += ANGLE_STEP;\r\n    }\r\n}\r\n\r\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\r\n    return (zReceiver - zBlocker) / zBlocker;\r\n}\r\n\r\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\r\n    // This uses similar triangles to compute what\r\n    // area of the shadow map we should search\r\n    float searchRadius = lightSizeUV * (zReceiver - NEAR_PLANE) / zReceiver;\r\n    float blockerDepthSum = 0.0;\r\n    int numBlockers = 0;\r\n\r\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\r\n        float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\r\n        if (shadowMapDepth < zReceiver) {\r\n            blockerDepthSum += shadowMapDepth;\r\n            numBlockers++;\r\n        }\r\n    }\r\n\r\n    if (numBlockers == 0) return -1.0;\r\n\r\n    return blockerDepthSum / float(numBlockers);\r\n}\r\n\r\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\r\n    float sum = 0.0;\r\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\r\n        float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * filterRadius));\r\n        if (zReceiver <= depth) sum += 1.0;\r\n    }\r\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\r\n        float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[i].yx * filterRadius));\r\n        if (zReceiver <= depth) sum += 1.0;\r\n    }\r\n    return sum / (2.0 * float(NUM_SAMPLES));\r\n}\r\n\r\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\r\n    vec2 uv = coords.xy;\r\n    float zReceiver = coords.z; // Assumed to be eye-space z in this code\r\n\r\n    initPoissonSamples(uv);\r\n    // STEP 1: blocker search\r\n    float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\r\n\r\n    //There are no occluders so early out (this saves filtering)\r\n    if (avgBlockerDepth == -1.0) return 1.0;\r\n\r\n    // STEP 2: penumbra size\r\n    float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\r\n    float filterRadius = penumbraRatio * lightSizeUV * NEAR_PLANE / zReceiver;\r\n\r\n    // STEP 3: filtering\r\n    //return avgBlockerDepth;\r\n    return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\r\n}\r\n#endif\r\n`;\r\n\r\nexport const entry = `\r\n// PCSS implementation\r\nvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\nfloat dx = texelSize.x;\r\nfloat dy = texelSize.y;\r\nvec2 uv = shadowCoord.xy;\r\nvec2 f = fract( uv * shadowMapSize + 0.5 );\r\nuv -= f * texelSize;\r\nfloat shadow1 = (\r\n    texture2DCompare( shadowMap, uv, shadowCoord.z ) +\r\n    texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\r\n    texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\r\n    texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\r\n    mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \r\n         texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\r\n         f.x ) +\r\n    mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \r\n         texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\r\n         f.x ) +\r\n    mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \r\n         texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\r\n         f.y ) +\r\n    mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \r\n         texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\r\n         f.y ) +\r\n    mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \r\n              texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\r\n              f.x ),\r\n         mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \r\n              texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\r\n              f.x ),\r\n         f.y )\r\n) * ( 1.0 / 9.0 );\r\nfloat shadow2 = PCSS( shadowMap, shadowCoord );\r\nshadow = shadow1 * (1.0 - blending) + blending * shadow2;\r\n            `"]}},"error":null,"hash":"0ae804e1bf0a3e692f3511e016d44738","cacheData":{"env":{}}}