{"id":"node_modules/@shapediver/viewer.data-engine.sdtf-engine/dist/SDTFEngine.js","dependencies":[{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.sdtf-engine\\dist\\SDTFEngine.js.map","includedInParent":true,"mtime":1706527148398},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.sdtf-engine\\src\\SDTFEngine.ts","includedInParent":true,"mtime":1706527148580},{"name":"D:\\projects\\myProjects\\shapeApp\\package.json","includedInParent":true,"mtime":1706533774939},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.sdtf-engine\\package.json","includedInParent":true,"mtime":1706527148027},{"name":"@shapediver/viewer.shared.node-tree","loc":{"line":13,"column":42,"index":841},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.sdtf-engine\\dist\\SDTFEngine.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.node-tree\\dist\\index.js"},{"name":"@shapediver/viewer.shared.services","loc":{"line":14,"column":41,"index":923},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.sdtf-engine\\dist\\SDTFEngine.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.services\\dist\\index.js"},{"name":"@shapediver/viewer.shared.types","loc":{"line":15,"column":38,"index":1001},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.sdtf-engine\\dist\\SDTFEngine.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.types\\dist\\index.js"},{"name":"@shapediver/sdk.sdtf-v1","loc":{"line":16,"column":30,"index":1068},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.sdtf-engine\\dist\\SDTFEngine.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\sdk.sdtf-v1\\dist\\index.js"},{"name":"@shapediver/sdk.sdtf-primitives","loc":{"line":17,"column":38,"index":1135},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.sdtf-engine\\dist\\SDTFEngine.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\sdk.sdtf-primitives\\dist\\index.js"}],"generated":{"js":"\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SDTFEngine = void 0;\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst sdk_sdtf_v1_1 = require(\"@shapediver/sdk.sdtf-v1\");\r\nconst sdk_sdtf_primitives_1 = require(\"@shapediver/sdk.sdtf-primitives\");\r\nclass SDTFEngine {\r\n    constructor() {\r\n        // #region Properties (3)\r\n        this._logger = viewer_shared_services_1.Logger.instance;\r\n        // #endregion Private Methods (5)\r\n    }\r\n    // #endregion Properties (3)\r\n    // #region Public Static Accessors (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Accessors (1)\r\n    // #region Public Methods (1)\r\n    /**\r\n     * Load the sdtf content into a scene graph node.\r\n     *\r\n     * @param content the geometry content\r\n     * @returns the scene graph node\r\n     */\r\n    loadContent(content, jwtToken) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const node = new viewer_shared_node_tree_1.TreeNode('sdtf');\r\n            // We have to be safe and check if the content is a valid SDTF file\r\n            if (!content || (content && !content.href))\r\n                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('SDTFEngine.loadContent: Invalid content was provided to geometry engine.');\r\n            // create the sdtf sdk\r\n            const sdk = jwtToken ? yield (0, sdk_sdtf_v1_1.create)({ authToken: jwtToken }) : yield (0, sdk_sdtf_v1_1.create)();\r\n            // crete the sdtf parser\r\n            const parser = sdk.createParser();\r\n            // parse the file\r\n            this._parsedFile = yield parser.readFromUrl(content.href);\r\n            // crete the overview and save it in the node data\r\n            node.data.push(yield this.createSDTFOverview());\r\n            // add the loaded chunks to the node\r\n            for (let i = 0; i < this._parsedFile.chunks.length; i++)\r\n                node.children.push(yield this.loadChunk(this._parsedFile.chunks[i], i));\r\n            return node;\r\n        });\r\n    }\r\n    // #endregion Public Methods (1)\r\n    // #region Private Methods (5)\r\n    /**\r\n     * Create an overview of the SDTF file.\r\n     * This overview is used for the data visualization.\r\n     * It is structured as a dictionary with the name as the key and an array of Objects as the value.\r\n     * The array of objects contains the different types that can be found in the SDTF file under the same name.\r\n     *\r\n     * Example:\r\n     * {\r\n     *     \"color\": [\r\n     *         {\r\n     *             typeHint: 'string',\r\n     *             count: 2,\r\n     *             values: [\"red\", \"blue\"]\r\n     *         },\r\n     *         {\r\n     *             typeHint: 'numberArray',\r\n     *             count: 2,\r\n     *             values: [[1,0,0,1], [0,0,1,1]]\r\n     *         },\r\n     *     ]\r\n     * }\r\n     *\r\n     * The overview contains the following information:\r\n     * - name of the attribute + type of the attribute\r\n     * - the count\r\n     * - for numerical attributes, the min and max values\r\n     * - for string attributes, the unique values\r\n     *\r\n     * @returns\r\n     */\r\n    createSDTFOverview() {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const overview = {};\r\n            // go through all attributes\r\n            for (let i = 0; i < this._parsedFile.attributes.length; i++) {\r\n                const attributes = this._parsedFile.attributes[i];\r\n                // go through all entries\r\n                for (let key in attributes.entries) {\r\n                    const dataToCopy = attributes.entries[key];\r\n                    const value = yield dataToCopy.getContent();\r\n                    // create the type hint to use\r\n                    const dataTypehint = dataToCopy.typeHint === undefined ? 'undefined' : dataToCopy.typeHint.name;\r\n                    // check if the attribute is already in the overview\r\n                    const existingEntries = overview[key] ? overview[key].filter(o => o.typeHint === dataTypehint) : [];\r\n                    if (overview[key] && existingEntries.length > 0) {\r\n                        // update the existing entry\r\n                        const entry = existingEntries[0];\r\n                        // update the count\r\n                        entry.count++;\r\n                        // update the values\r\n                        if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isStringType(dataTypehint)) {\r\n                            if (!((_a = entry.values) === null || _a === void 0 ? void 0 : _a.includes(value)))\r\n                                (_b = entry.values) === null || _b === void 0 ? void 0 : _b.push(value);\r\n                        }\r\n                        // update the min and max\r\n                        if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isNumberType(dataTypehint)) {\r\n                            entry.min = Math.min(value, entry.min);\r\n                            entry.max = Math.max(value, entry.max);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // create a new entry, if the name already exists, but the type does not\r\n                        if (overview[key]) {\r\n                            overview[key].push({\r\n                                typeHint: dataTypehint,\r\n                                count: 1,\r\n                            });\r\n                        }\r\n                        // create completely new entry\r\n                        else {\r\n                            overview[key] = [{\r\n                                    typeHint: dataTypehint,\r\n                                    count: 1,\r\n                                }];\r\n                        }\r\n                        // update the values\r\n                        if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isStringType(dataTypehint)) {\r\n                            overview[key][overview[key].length - 1].values = [value];\r\n                        }\r\n                        // update the min and max\r\n                        if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isNumberType(dataTypehint)) {\r\n                            overview[key][overview[key].length - 1].min = value;\r\n                            overview[key][overview[key].length - 1].max = value;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return new viewer_shared_types_1.SDTFOverviewData(overview);\r\n        });\r\n    }\r\n    /**\r\n     * Load the attributes into a SDTFAttributesData data item.\r\n     *\r\n     * @param attributes\r\n     * @returns\r\n     */\r\n    loadAttributes(attributes) {\r\n        var _a, _b, _c, _d;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const data = new viewer_shared_types_1.SDTFAttributesData();\r\n            // go through all attributes entries and save them in data items\r\n            for (let key in attributes.entries) {\r\n                if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isBooleanType((_a = attributes.entries[key].typeHint) === null || _a === void 0 ? void 0 : _a.name) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isColorType((_b = attributes.entries[key].typeHint) === null || _b === void 0 ? void 0 : _b.name) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isNumberType((_c = attributes.entries[key].typeHint) === null || _c === void 0 ? void 0 : _c.name) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isStringType((_d = attributes.entries[key].typeHint) === null || _d === void 0 ? void 0 : _d.name)) {\r\n                    // create the data item and save it in the dictionary\r\n                    const typeHint = attributes.entries[key].typeHint === undefined ? 'undefined' : attributes.entries[key].typeHint.name;\r\n                    data.attributes[key] = new viewer_shared_types_1.SDTFAttributeData(typeHint, yield attributes.entries[key].getContent());\r\n                }\r\n                else {\r\n                    // async data\r\n                    const typeHint = attributes.entries[key].typeHint === undefined ? 'undefined' : attributes.entries[key].typeHint.name;\r\n                    data.attributes[key] = new viewer_shared_types_1.SDTFAttributeData(typeHint, () => __awaiter(this, void 0, void 0, function* () {\r\n                        return yield attributes.entries[key].getContent();\r\n                    }));\r\n                }\r\n            }\r\n            return data;\r\n        });\r\n    }\r\n    /**\r\n     * Load the chunk into a scene graph node.\r\n     *\r\n     * @param chunk\r\n     * @param chunkId\r\n     * @returns\r\n     */\r\n    loadChunk(chunk, chunkId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const chunkDef = new viewer_shared_node_tree_1.TreeNode(chunk.name || 'chunk_' + chunkId);\r\n            // if there are attributes, add them to the chunk as data\r\n            if (chunk.attributes !== undefined) {\r\n                chunkDef.data.push(yield this.loadAttributes(chunk.attributes));\r\n            }\r\n            // if there are items, add them to the chunk as children\r\n            if (chunk.items !== undefined && chunk.items.length > 0) {\r\n                for (let i = 0, len = chunk.items.length; i < len; i++) {\r\n                    // got through all items\r\n                    chunkDef.addChild(yield this.loadItem(chunk.items[i], i));\r\n                }\r\n            }\r\n            // if there are nodes, add them to the chunk as children\r\n            if (chunk.nodes !== undefined && chunk.nodes.length > 0) {\r\n                for (let i = 0, len = chunk.nodes.length; i < len; i++) {\r\n                    // got through all children\r\n                    chunkDef.addChild(yield this.loadNode(chunk.nodes[i], i));\r\n                }\r\n            }\r\n            return chunkDef;\r\n        });\r\n    }\r\n    /**\r\n     * Load the item into a scene graph node.\r\n     *\r\n     * @param item\r\n     * @param itemId\r\n     * @returns\r\n     */\r\n    loadItem(item, itemId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const itemDef = new viewer_shared_node_tree_1.TreeNode(itemId + '');\r\n            // if there are attributes, add them to the item\r\n            let attributes;\r\n            if (item.attributes !== undefined)\r\n                attributes = yield this.loadAttributes(item.attributes);\r\n            // create the typehint\r\n            const typeHint = item.typeHint === undefined ? 'undefined' : item.typeHint.name;\r\n            let itemData;\r\n            // create the data and save it in the item node\r\n            if (sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isBooleanType(typeHint) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isColorType(typeHint) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isNumberType(typeHint) || sdk_sdtf_primitives_1.SdtfPrimitiveTypeGuard.isStringType(typeHint)) {\r\n                itemData = new viewer_shared_types_1.SDTFItemData(typeHint, yield item.getContent(), attributes === null || attributes === void 0 ? void 0 : attributes.attributes);\r\n            }\r\n            else {\r\n                itemData = new viewer_shared_types_1.SDTFItemData(typeHint, () => __awaiter(this, void 0, void 0, function* () {\r\n                    return yield item.getContent();\r\n                }), attributes === null || attributes === void 0 ? void 0 : attributes.attributes);\r\n            }\r\n            itemDef.data.push(itemData);\r\n            return itemDef;\r\n        });\r\n    }\r\n    /**\r\n     * Load the node into a scene graph node.\r\n     *\r\n     * @param node\r\n     * @param nodeId\r\n     * @returns\r\n     */\r\n    loadNode(node, nodeId) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const nodeDef = new viewer_shared_node_tree_1.TreeNode(node.name || 'node_' + nodeId);\r\n            // if there are attributes, add them to the node as data\r\n            if (node.attributes !== undefined) {\r\n                nodeDef.data.push(yield this.loadAttributes(node.attributes));\r\n            }\r\n            // if there are items, add them to the node as children\r\n            if (node.items !== undefined && node.items.length > 0) {\r\n                for (let i = 0, len = node.items.length; i < len; i++) {\r\n                    // got through all items\r\n                    nodeDef.addChild(yield this.loadItem(node.items[i], i));\r\n                }\r\n            }\r\n            // if there are nodes, add them to the node as children\r\n            if (node.nodes !== undefined && node.nodes.length > 0) {\r\n                for (let i = 0, len = node.nodes.length; i < len; i++) {\r\n                    // got through all children\r\n                    nodeDef.addChild(yield this.loadNode(node.nodes[i], i));\r\n                }\r\n            }\r\n            return nodeDef;\r\n        });\r\n    }\r\n}\r\nexports.SDTFEngine = SDTFEngine;\r\n"},"sourceMaps":{"js":{"version":3,"file":"SDTFEngine.js","sourceRoot":"","sources":["../src/SDTFEngine.ts"],"names":[],"mappings":"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","sourcesContent":["import { ITreeNode, TreeNode } from '@shapediver/viewer.shared.node-tree'\r\nimport { Logger, ShapeDiverViewerDataProcessingError } from '@shapediver/viewer.shared.services'\r\nimport { SDTFAttributesData, SDTFAttributeData, SDTFItemData, SDTFOverviewData } from '@shapediver/viewer.shared.types'\r\nimport { ShapeDiverResponseOutputContent } from '@shapediver/sdk.geometry-api-sdk-v2'\r\nimport { create, ISdtfReadableAsset, ISdtfReadableAttributes, ISdtfReadableChunk, ISdtfReadableDataItem, ISdtfReadableNode, SdtfTypeHintName  } from '@shapediver/sdk.sdtf-v1'\r\nimport { SdtfPrimitiveTypeGuard  } from '@shapediver/sdk.sdtf-primitives'\r\n\r\nexport class SDTFEngine {\r\n    // #region Properties (3)\r\n\r\n    private readonly _logger: Logger = Logger.instance;\r\n\r\n    private static _instance: SDTFEngine;\r\n\r\n    private _parsedFile!: ISdtfReadableAsset;\r\n\r\n    // #endregion Properties (3)\r\n\r\n    // #region Public Static Accessors (1)\r\n\r\n    public static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n\r\n    // #endregion Public Static Accessors (1)\r\n\r\n    // #region Public Methods (1)\r\n\r\n    /**\r\n     * Load the sdtf content into a scene graph node.\r\n     * \r\n     * @param content the geometry content\r\n     * @returns the scene graph node \r\n     */\r\n    public async loadContent(content: ShapeDiverResponseOutputContent, jwtToken?: string): Promise<ITreeNode> {\r\n        const node = new TreeNode('sdtf');\r\n\r\n        // We have to be safe and check if the content is a valid SDTF file\r\n        if (!content || (content && !content.href))\r\n            throw new ShapeDiverViewerDataProcessingError('SDTFEngine.loadContent: Invalid content was provided to geometry engine.');\r\n\r\n        // create the sdtf sdk\r\n        const sdk = jwtToken ? await create({ authToken: jwtToken }) : await create();\r\n        // crete the sdtf parser\r\n        const parser = sdk.createParser();\r\n        // parse the file\r\n        this._parsedFile = await parser.readFromUrl(content.href!);\r\n\r\n        // crete the overview and save it in the node data\r\n        node.data.push(await this.createSDTFOverview());\r\n\r\n        // add the loaded chunks to the node\r\n        for (let i = 0; i < this._parsedFile.chunks.length; i++)\r\n            node.children.push(await this.loadChunk(this._parsedFile.chunks[i], i));\r\n\r\n        return node;\r\n    }\r\n\r\n    // #endregion Public Methods (1)\r\n\r\n    // #region Private Methods (5)\r\n\r\n    /**\r\n     * Create an overview of the SDTF file.\r\n     * This overview is used for the data visualization.\r\n     * It is structured as a dictionary with the name as the key and an array of Objects as the value.\r\n     * The array of objects contains the different types that can be found in the SDTF file under the same name.\r\n     * \r\n     * Example:\r\n     * {\r\n     *     \"color\": [\r\n     *         {\r\n     *             typeHint: 'string',\r\n     *             count: 2,\r\n     *             values: [\"red\", \"blue\"]\r\n     *         },\r\n     *         {\r\n     *             typeHint: 'numberArray',\r\n     *             count: 2,\r\n     *             values: [[1,0,0,1], [0,0,1,1]]\r\n     *         },\r\n     *     ]\r\n     * }\r\n     * \r\n     * The overview contains the following information:\r\n     * - name of the attribute + type of the attribute\r\n     * - the count \r\n     * - for numerical attributes, the min and max values\r\n     * - for string attributes, the unique values\r\n     * \r\n     * @returns \r\n     */\r\n    private async createSDTFOverview(): Promise<SDTFOverviewData> {\r\n        const overview: {\r\n            [key: string]: {\r\n                typeHint: SdtfTypeHintName | string;\r\n                count: number;\r\n                values?: string[];\r\n                min?: number;\r\n                max?: number;\r\n            }[];\r\n        } = {};\r\n\r\n        // go through all attributes\r\n        for (let i = 0; i < this._parsedFile.attributes.length; i++) {\r\n            const attributes = this._parsedFile.attributes[i];\r\n\r\n            // go through all entries\r\n            for (let key in attributes.entries) {\r\n                const dataToCopy = attributes.entries[key];\r\n                const value = await dataToCopy.getContent();\r\n\r\n                // create the type hint to use\r\n                const dataTypehint = dataToCopy.typeHint === undefined ? 'undefined' : dataToCopy.typeHint.name;\r\n\r\n                // check if the attribute is already in the overview\r\n                const existingEntries = overview[key] ? overview[key].filter(o => o.typeHint === dataTypehint) : [];\r\n\r\n                if (overview[key] && existingEntries.length > 0) {\r\n                    // update the existing entry\r\n                    const entry = existingEntries[0];\r\n                    // update the count\r\n                    entry.count++;\r\n\r\n                    // update the values\r\n                    if (SdtfPrimitiveTypeGuard.isStringType(dataTypehint)) {\r\n                        if (!entry.values?.includes(<string>value))\r\n                            entry.values?.push(<string>value)\r\n                    }\r\n                    \r\n                    // update the min and max\r\n                    if (SdtfPrimitiveTypeGuard.isNumberType(dataTypehint)) {  \r\n                        entry.min = Math.min(<number>value, entry.min!);\r\n                        entry.max = Math.max(<number>value, entry.max!);\r\n                    }\r\n                } else {\r\n                    // create a new entry, if the name already exists, but the type does not\r\n                    if (overview[key]) {\r\n                        overview[key].push({\r\n                            typeHint: dataTypehint,\r\n                            count: 1,\r\n                        })\r\n                    } \r\n                    // create completely new entry\r\n                    else {\r\n                        overview[key] = [{\r\n                            typeHint: dataTypehint,\r\n                            count: 1,\r\n                        }]\r\n                    }\r\n\r\n                    // update the values\r\n                    if (SdtfPrimitiveTypeGuard.isStringType(dataTypehint)) {\r\n                        overview[key][overview[key].length - 1].values = [<string>value];\r\n                    }\r\n                                        \r\n                    // update the min and max\r\n                    if (SdtfPrimitiveTypeGuard.isNumberType(dataTypehint)) {\r\n                        overview[key][overview[key].length - 1].min = <number>value;\r\n                        overview[key][overview[key].length - 1].max = <number>value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return new SDTFOverviewData(overview);\r\n    }\r\n\r\n    /**\r\n     * Load the attributes into a SDTFAttributesData data item.\r\n     * \r\n     * @param attributes \r\n     * @returns \r\n     */\r\n    private async loadAttributes(attributes: ISdtfReadableAttributes): Promise<SDTFAttributesData> {\r\n        const data = new SDTFAttributesData();\r\n        // go through all attributes entries and save them in data items\r\n        for (let key in attributes.entries) {\r\n            if (SdtfPrimitiveTypeGuard.isBooleanType(attributes.entries[key].typeHint?.name) || SdtfPrimitiveTypeGuard.isColorType(attributes.entries[key].typeHint?.name) || SdtfPrimitiveTypeGuard.isNumberType(attributes.entries[key].typeHint?.name) || SdtfPrimitiveTypeGuard.isStringType(attributes.entries[key].typeHint?.name)) {\r\n                // create the data item and save it in the dictionary\r\n                const typeHint = attributes.entries[key].typeHint === undefined ? 'undefined' : attributes.entries[key].typeHint!.name;\r\n                data.attributes[key] = new SDTFAttributeData(typeHint, await attributes.entries[key].getContent());\r\n            } else {\r\n                // async data\r\n                const typeHint = attributes.entries[key].typeHint === undefined ? 'undefined' : attributes.entries[key].typeHint!.name;\r\n                data.attributes[key] = new SDTFAttributeData(typeHint, async () => { \r\n                    return await attributes.entries[key].getContent(); \r\n                });\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Load the chunk into a scene graph node.\r\n     * \r\n     * @param chunk \r\n     * @param chunkId \r\n     * @returns \r\n     */\r\n    private async loadChunk(chunk: ISdtfReadableChunk, chunkId: number): Promise<TreeNode> {\r\n        const chunkDef = new TreeNode(chunk.name || 'chunk_' + chunkId);\r\n\r\n        // if there are attributes, add them to the chunk as data\r\n        if (chunk.attributes !== undefined) {\r\n            chunkDef.data.push(await this.loadAttributes(chunk.attributes));\r\n        }\r\n\r\n        // if there are items, add them to the chunk as children\r\n        if (chunk.items !== undefined && chunk.items.length > 0) {\r\n            for (let i = 0, len = chunk.items.length; i < len; i++) {\r\n                // got through all items\r\n                chunkDef.addChild(await this.loadItem(chunk.items[i], i));\r\n            }\r\n        }\r\n\r\n        // if there are nodes, add them to the chunk as children\r\n        if (chunk.nodes !== undefined && chunk.nodes.length > 0) {\r\n            for (let i = 0, len = chunk.nodes.length; i < len; i++) {\r\n                // got through all children\r\n                chunkDef.addChild(await this.loadNode(chunk.nodes[i], i));\r\n            }\r\n        }\r\n\r\n        return chunkDef;\r\n    }\r\n\r\n    /**\r\n     * Load the item into a scene graph node.\r\n     * \r\n     * @param item \r\n     * @param itemId \r\n     * @returns \r\n     */\r\n    private async loadItem(item: ISdtfReadableDataItem, itemId: number): Promise<TreeNode> {\r\n        const itemDef = new TreeNode(itemId + '');\r\n\r\n        // if there are attributes, add them to the item\r\n        let attributes;\r\n        if (item.attributes !== undefined)\r\n            attributes = await this.loadAttributes(item.attributes);\r\n\r\n        // create the typehint\r\n        const typeHint = item.typeHint === undefined ? 'undefined' : item.typeHint!.name;\r\n\r\n        let itemData;\r\n        // create the data and save it in the item node\r\n        if (SdtfPrimitiveTypeGuard.isBooleanType(typeHint) || SdtfPrimitiveTypeGuard.isColorType(typeHint) || SdtfPrimitiveTypeGuard.isNumberType(typeHint) || SdtfPrimitiveTypeGuard.isStringType(typeHint)) {\r\n            itemData = new SDTFItemData(typeHint, await item.getContent(), attributes?.attributes!)\r\n        } else {\r\n            itemData = new SDTFItemData(typeHint, async () => { \r\n                return await item.getContent();\r\n            }, attributes?.attributes!);\r\n        }\r\n        itemDef.data.push(itemData)\r\n\r\n        return itemDef;\r\n    }\r\n\r\n    /**\r\n     * Load the node into a scene graph node.\r\n     * \r\n     * @param node \r\n     * @param nodeId \r\n     * @returns \r\n     */\r\n    private async loadNode(node: ISdtfReadableNode, nodeId: number): Promise<TreeNode> {\r\n        const nodeDef = new TreeNode(node.name || 'node_' + nodeId);\r\n\r\n        // if there are attributes, add them to the node as data\r\n        if (node.attributes !== undefined) {\r\n            nodeDef.data.push(await this.loadAttributes(node.attributes));\r\n        }\r\n\r\n        // if there are items, add them to the node as children\r\n        if (node.items !== undefined && node.items.length > 0) {\r\n            for (let i = 0, len = node.items.length; i < len; i++) {\r\n                // got through all items\r\n                nodeDef.addChild(await this.loadItem(node.items[i], i));\r\n            }\r\n        }\r\n\r\n        // if there are nodes, add them to the node as children\r\n        if (node.nodes !== undefined && node.nodes.length > 0) {\r\n            for (let i = 0, len = node.nodes.length; i < len; i++) {\r\n                // got through all children\r\n                nodeDef.addChild(await this.loadNode(node.nodes[i], i));\r\n            }\r\n        }\r\n\r\n        return nodeDef;\r\n    }\r\n\r\n    // #endregion Private Methods (5)\r\n}"]}},"error":null,"hash":"54fd7cd5a31fe0d52bc8309b96bd64ce","cacheData":{"env":{}}}