{"id":"node_modules/@shapediver/viewer.session-engine.session-engine/dist/implementation/OutputLoader.js","dependencies":[{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.session-engine.session-engine\\dist\\implementation\\OutputLoader.js.map","includedInParent":true,"mtime":1706527152580},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.session-engine.session-engine\\src\\implementation\\OutputLoader.ts","includedInParent":true,"mtime":1706527153194},{"name":"D:\\projects\\myProjects\\shapeApp\\package.json","includedInParent":true,"mtime":1706533774939},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.session-engine.session-engine\\package.json","includedInParent":true,"mtime":1706527152247},{"name":"@shapediver/viewer.shared.types","loc":{"line":13,"column":38,"index":839},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.session-engine.session-engine\\dist\\implementation\\OutputLoader.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.types\\dist\\index.js"},{"name":"@shapediver/viewer.data-engine.data-engine","loc":{"line":14,"column":49,"index":925},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.session-engine.session-engine\\dist\\implementation\\OutputLoader.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.data-engine\\dist\\index.js"},{"name":"@shapediver/viewer.shared.node-tree","loc":{"line":15,"column":42,"index":1015},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.session-engine.session-engine\\dist\\implementation\\OutputLoader.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.node-tree\\dist\\index.js"},{"name":"./OutputDelayException","loc":{"line":16,"column":39,"index":1095},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.session-engine.session-engine\\dist\\implementation\\OutputLoader.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.session-engine.session-engine\\dist\\implementation\\OutputDelayException.js"},{"name":"./SessionTreeNode","loc":{"line":17,"column":34,"index":1157},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.session-engine.session-engine\\dist\\implementation\\OutputLoader.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.session-engine.session-engine\\dist\\implementation\\SessionTreeNode.js"},{"name":"./SessionOutputData","loc":{"line":18,"column":36,"index":1216},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.session-engine.session-engine\\dist\\implementation\\OutputLoader.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.session-engine.session-engine\\dist\\implementation\\SessionOutputData.js"},{"name":"@shapediver/viewer.shared.services","loc":{"line":19,"column":41,"index":1282},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.session-engine.session-engine\\dist\\implementation\\OutputLoader.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.services\\dist\\index.js"}],"generated":{"js":"\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.OutputLoader = void 0;\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst viewer_data_engine_data_engine_1 = require(\"@shapediver/viewer.data-engine.data-engine\");\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst OutputDelayException_1 = require(\"./OutputDelayException\");\r\nconst SessionTreeNode_1 = require(\"./SessionTreeNode\");\r\nconst SessionOutputData_1 = require(\"./SessionOutputData\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nclass OutputLoader {\r\n    // #endregion Properties (3)\r\n    // #region Constructors (1)\r\n    /**\r\n     * The output loader takes care of loading the outputs of a session, storing them and returning stored or newly loaded nodes.\r\n     *\r\n     * @param _session the session for this output loader\r\n     */\r\n    constructor(_sessionEngine) {\r\n        this._sessionEngine = _sessionEngine;\r\n        // #region Properties (3)\r\n        this._dataEngine = viewer_data_engine_data_engine_1.DataEngine.instance;\r\n        this._eventEngine = viewer_shared_services_1.EventEngine.instance;\r\n        this._loadedOutputNodes = {};\r\n        this._lastOutputNodes = {};\r\n        this._performanceEvaluator = viewer_shared_services_1.PerformanceEvaluator.instance;\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Methods (1)\r\n    /**\r\n     * Load the outputs and return the scene graph node of the result.\r\n     * In case the outputs have a delay property, it throws an OutputDelayException.\r\n     *\r\n     * @param outputs the outputs to load\r\n     * @returns promise with a scene graph node\r\n     */\r\n    loadOutputs(nodeName, outputs, outputsFreeze, taskEventInfo) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._performanceEvaluator.startSection('outputLoading');\r\n            const node = new SessionTreeNode_1.SessionTreeNode(nodeName);\r\n            let currentNodes = {};\r\n            let outputInfo = {};\r\n            let promises = [];\r\n            let promisesNodes = [];\r\n            let maxDelay = 0;\r\n            let progress = {};\r\n            const outputIDs = Object.keys(outputs);\r\n            const cb = (e) => {\r\n                const taskEvent = e;\r\n                if (outputIDs.includes(taskEvent.id)) {\r\n                    progress[taskEvent.id] = taskEvent.progress;\r\n                    let sum = 0;\r\n                    Object.values(progress).forEach(p => { sum += p; });\r\n                    const outputLoadingProgress = (taskEventInfo.progressRange.max - taskEventInfo.progressRange.min) * (sum / outputIDs.length) + taskEventInfo.progressRange.min;\r\n                    const eventProgressUpdate = { type: taskEventInfo.type, id: taskEventInfo.eventId, progress: outputLoadingProgress, data: taskEventInfo.data, status: 'Output content loading progress.' };\r\n                    this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, eventProgressUpdate);\r\n                }\r\n            };\r\n            let listenerTokens = [];\r\n            listenerTokens.push(this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.TASK.TASK_START, cb));\r\n            listenerTokens.push(this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.TASK.TASK_PROCESS, cb));\r\n            listenerTokens.push(this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.TASK.TASK_CANCEL, cb));\r\n            listenerTokens.push(this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.TASK.TASK_END, cb));\r\n            for (let outputID in outputs) {\r\n                // we store some necessary information as this data may have been changed after the await (see warning below)\r\n                outputInfo[outputID] = {\r\n                    version: outputs[outputID].version,\r\n                    contentFormat: outputs[outputID].content ? outputs[outputID].content.map(c => c.format) : []\r\n                };\r\n                currentNodes[outputID] = {};\r\n                if (!this._loadedOutputNodes[outputID])\r\n                    this._loadedOutputNodes[outputID] = {};\r\n                if (outputsFreeze[outputID]) {\r\n                    currentNodes[outputID][outputInfo[outputID].version] = this._lastOutputNodes[outputID];\r\n                    // no loading necessary, progress done\r\n                    progress[outputID] = 1;\r\n                }\r\n                else if (outputs[outputID].delay) {\r\n                    maxDelay = Math.max(maxDelay, outputs[outputID].delay);\r\n                }\r\n                else if (!this._loadedOutputNodes[outputID][outputInfo[outputID].version]) {\r\n                    currentNodes[outputID][outputInfo[outputID].version] = new SessionTreeNode_1.SessionTreeNode(outputID);\r\n                    currentNodes[outputID][outputInfo[outputID].version].data.push(new SessionOutputData_1.SessionOutputData(outputs[outputID]));\r\n                    if (outputs[outputID].content) {\r\n                        for (let i = 0, len = outputs[outputID].content.length; i < len; i++) {\r\n                            promises.push(this._dataEngine.loadContent(outputs[outputID].content[i], this._sessionEngine.jwtToken, outputID));\r\n                            promisesNodes.push(currentNodes[outputID][outputInfo[outputID].version]);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    currentNodes[outputID][outputInfo[outputID].version] = this._loadedOutputNodes[outputID][outputInfo[outputID].version];\r\n                    // no loading necessary, progress done\r\n                    progress[outputID] = 1;\r\n                }\r\n            }\r\n            if (maxDelay)\r\n                throw new OutputDelayException_1.OutputDelayException(maxDelay);\r\n            /**\r\n             * WARNING: After this point outputs object cannot be used anymore.\r\n             * This can happen when fast consecutive scene updates are done.\r\n             * Therefore, we stored the data in the outputInfo.\r\n             */\r\n            yield Promise.all(promises);\r\n            listenerTokens.forEach(t => this._eventEngine.removeListener(t));\r\n            // all promises are resolved, await in the next lines is just for structural purposes\r\n            for (let i = 0; i < promises.length; i++)\r\n                promisesNodes[i].addChild(yield promises[i]);\r\n            // here we assign all outputs just to the node and return it\r\n            for (let outputID in outputInfo)\r\n                node.addChild(currentNodes[outputID][outputInfo[outputID].version]);\r\n            // save the nodes as the last available version\r\n            for (let outputID in outputInfo) {\r\n                this._loadedOutputNodes[outputID] = {};\r\n                this._loadedOutputNodes[outputID][outputInfo[outputID].version] = currentNodes[outputID][outputInfo[outputID].version];\r\n                this._lastOutputNodes[outputID] = currentNodes[outputID][outputInfo[outputID].version];\r\n            }\r\n            for (let outputID in outputInfo) {\r\n                if (currentNodes[outputID][outputInfo[outputID].version].children.length > 1) {\r\n                    for (let i = 0, len = outputInfo[outputID].contentFormat.length; i < len; i++) {\r\n                        if (outputInfo[outputID].contentFormat[i] === 'sdtf') {\r\n                            this.mergeContentNodes(currentNodes[outputID][outputInfo[outputID].version]);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.assignMaterials(node);\r\n            this._performanceEvaluator.endSection('outputLoading');\r\n            return node;\r\n        });\r\n    }\r\n    // #endregion Public Methods (1)\r\n    // #region Private Methods (2)\r\n    assignMaterials(node) {\r\n        const addMaterialToGeometry = (node, material) => {\r\n            for (let i = 0; i < node.data.length; i++) {\r\n                if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {\r\n                    const geometry = node.data[i];\r\n                    const currentMaterial = geometry.material;\r\n                    if (currentMaterial === null || currentMaterial.materialOutput === true) {\r\n                        geometry.material = material;\r\n                    }\r\n                }\r\n            }\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                const child = node.children[i];\r\n                if (child)\r\n                    addMaterialToGeometry(child, material);\r\n            }\r\n        };\r\n        const getMaterialData = (node, materials = []) => {\r\n            for (let k = 0; k < node.data.length; k++) {\r\n                if (node.data[k] instanceof viewer_shared_types_1.AbstractMaterialData) {\r\n                    const material = node.data[k];\r\n                    material.materialOutput = true;\r\n                    materials.push(material);\r\n                }\r\n            }\r\n            for (let k = 0; k < node.children.length; k++) {\r\n                const child = node.children[k];\r\n                if (!child)\r\n                    continue;\r\n                materials.push(...getMaterialData(child));\r\n            }\r\n            return materials;\r\n        };\r\n        const getGeometryData = (node, geometries = []) => {\r\n            for (let k = 0; k < node.data.length; k++)\r\n                if (node.data[k] instanceof viewer_shared_types_1.GeometryData)\r\n                    geometries.push(node.data[k]);\r\n            for (let k = 0; k < node.children.length; k++) {\r\n                const child = node.children[k];\r\n                if (!child)\r\n                    continue;\r\n                geometries.push(...getGeometryData(child));\r\n            }\r\n            return geometries;\r\n        };\r\n        for (let m = 0; m < node.children.length; m++) {\r\n            // per output node, we go through the material assignment process\r\n            const outputNode = node.children[m];\r\n            if (!outputNode)\r\n                continue;\r\n            // we go through all data properties, normally, there should ony one, but we just make sure\r\n            for (let i = 0; i < outputNode.data.length; i++) {\r\n                if (!(outputNode.data[i] instanceof SessionOutputData_1.SessionOutputData))\r\n                    continue;\r\n                // the session output data contains information about this Output\r\n                // most importantly the SessionOutput property with the material and content in it\r\n                const sessionOutputData = outputNode.data[i];\r\n                // case 1: we have a specific material id defined, let's use that\r\n                if (sessionOutputData.responseOutput.material) {\r\n                    let materialNodes = [];\r\n                    // now we have id\r\n                    // get material with it    \r\n                    for (let n = 0; n < node.children.length; n++) {\r\n                        const materialNode = node.children[n];\r\n                        if (!materialNode)\r\n                            continue;\r\n                        if (materialNode.name === sessionOutputData.responseOutput.material)\r\n                            materialNodes = materialNode.children;\r\n                    }\r\n                    const geometryNodes = outputNode.children;\r\n                    if (materialNodes.length >= geometryNodes.length) {\r\n                        for (let n = 0; n < geometryNodes.length; n++) {\r\n                            addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[n])[0]);\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (materialNodes.length >= 1)\r\n                            for (let n = 0; n < geometryNodes.length; n++) {\r\n                                addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[0])[0]);\r\n                            }\r\n                    }\r\n                }\r\n                // case 2: there is no specific material id defined, maybe in the content we can match geometries to ids\r\n                else {\r\n                    // now we hope that in our content, there are exactly the amount of geometries and material, this will be interesting :)\r\n                    const sessionOutputContent = sessionOutputData.responseOutput.content;\r\n                    if (sessionOutputContent === undefined)\r\n                        continue;\r\n                    const materialNodes = [];\r\n                    const geometryNodes = [];\r\n                    for (let i = 0; i < sessionOutputContent.length; i++) {\r\n                        if (sessionOutputContent[i].format === 'material') {\r\n                            materialNodes.push(outputNode.children[i]);\r\n                        }\r\n                        else {\r\n                            geometryNodes.push(outputNode.children[i]);\r\n                        }\r\n                    }\r\n                    if (materialNodes.length >= geometryNodes.length) {\r\n                        for (let n = 0; n < geometryNodes.length; n++) {\r\n                            addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[n])[0]);\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (materialNodes.length >= 1)\r\n                            for (let n = 0; n < geometryNodes.length; n++) {\r\n                                addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[0])[0]);\r\n                            }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    mergeContentNodes(node) {\r\n        if (!(node.children.length > 1))\r\n            return;\r\n        const children = [];\r\n        while (node.children.length > 0) {\r\n            children.push(...node.children[0].children);\r\n            node.removeChild(node.children[0]);\r\n        }\r\n        const mergeNodes = (node1, node2) => {\r\n            for (let i = 0; i < node1.data.length; i++)\r\n                node2.data.push(node1.data[i]);\r\n            for (let i = 0; i < node1.children.length; i++) {\r\n                let childNode;\r\n                for (let j = 0; j < node2.children.length; j++) {\r\n                    if (node1.children[i].name === node2.children[j].name) {\r\n                        childNode = node2.children[j];\r\n                        break;\r\n                    }\r\n                }\r\n                if (!childNode) {\r\n                    childNode = new viewer_shared_node_tree_1.TreeNode(node1.children[i].name);\r\n                    node2.addChild(childNode);\r\n                }\r\n                mergeNodes(node1.children[i], childNode);\r\n            }\r\n        };\r\n        const newChild = new viewer_shared_node_tree_1.TreeNode('content_array');\r\n        node.addChild(newChild);\r\n        for (let i = 0; i < children.length; i++)\r\n            mergeNodes(children[i], newChild);\r\n    }\r\n}\r\nexports.OutputLoader = OutputLoader;\r\n"},"sourceMaps":{"js":{"version":3,"file":"OutputLoader.js","sourceRoot":"","sources":["../../src/implementation/OutputLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import { IMaterialAbstractData, GeometryData, AbstractMaterialData, ITaskEvent, TASK_TYPE } from '@shapediver/viewer.shared.types'\r\nimport { DataEngine } from '@shapediver/viewer.data-engine.data-engine'\r\nimport { ITreeNode, Tree, TreeNode } from '@shapediver/viewer.shared.node-tree'\r\n\r\nimport { OutputDelayException } from './OutputDelayException'\r\nimport { SessionTreeNode } from './SessionTreeNode'\r\nimport { SessionOutputData } from './SessionOutputData'\r\nimport { EventEngine, EVENTTYPE, IEvent, PerformanceEvaluator, UuidGenerator } from '@shapediver/viewer.shared.services'\r\nimport { ShapeDiverResponseDto, ShapeDiverResponseOutput } from '@shapediver/sdk.geometry-api-sdk-v2'\r\nimport { ISessionTreeNode } from '../interfaces/ISessionTreeNode'\r\nimport { ISessionEngine } from '../interfaces/ISessionEngine'\r\n\r\nexport type OutputLoaderTaskEventInfo = {\r\n    eventId: string,\r\n    type: TASK_TYPE,\r\n    progressRange: {\r\n        min: number,\r\n        max: number\r\n    },\r\n    data: any\r\n}\r\n\r\nexport class OutputLoader {\r\n    // #region Properties (3)\r\n\r\n    private readonly _dataEngine: DataEngine = DataEngine.instance;\r\n    private readonly _eventEngine: EventEngine = EventEngine.instance;\r\n    private readonly _loadedOutputNodes: { \r\n        [key: string]: {\r\n            [key: string]: ISessionTreeNode\r\n        }; \r\n    } = {};\r\n    private readonly _lastOutputNodes: { \r\n        [key: string]: ISessionTreeNode\r\n    } = {};\r\n    private readonly _performanceEvaluator: PerformanceEvaluator = PerformanceEvaluator.instance;\r\n\r\n    // #endregion Properties (3)\r\n\r\n    // #region Constructors (1)\r\n\r\n    /**\r\n     * The output loader takes care of loading the outputs of a session, storing them and returning stored or newly loaded nodes.\r\n     * \r\n     * @param _session the session for this output loader\r\n     */\r\n    constructor(private readonly _sessionEngine: ISessionEngine) {}\r\n\r\n    // #endregion Constructors (1)\r\n\r\n    // #region Public Methods (1)\r\n\r\n    /**\r\n     * Load the outputs and return the scene graph node of the result.\r\n     * In case the outputs have a delay property, it throws an OutputDelayException.\r\n     * \r\n     * @param outputs the outputs to load\r\n     * @returns promise with a scene graph node\r\n     */\r\n     public async loadOutputs(nodeName: string, outputs: { [key: string]: ShapeDiverResponseOutput; }, outputsFreeze: { [key: string]: boolean; }, taskEventInfo: OutputLoaderTaskEventInfo): Promise<SessionTreeNode> {\r\n        this._performanceEvaluator.startSection('outputLoading');\r\n        const node = new SessionTreeNode(nodeName);\r\n        let currentNodes: { \r\n            [key: string]: {\r\n                [key: string]: ISessionTreeNode\r\n            }; \r\n        } = {};\r\n        let outputInfo: { [key: string]: {\r\n            version:string,\r\n            contentFormat: string[],\r\n        } } = {};\r\n        let promises: Promise<ITreeNode>[] = [];\r\n        let promisesNodes: ISessionTreeNode[] = [];\r\n        let maxDelay = 0;\r\n\r\n        let progress: {\r\n            [key: string]: number\r\n        } = {};\r\n\r\n        const outputIDs = Object.keys(outputs);\r\n\r\n        const cb = (e: IEvent) => {\r\n            const taskEvent = e as ITaskEvent;\r\n            if(outputIDs.includes(taskEvent.id)) {\r\n                progress[taskEvent.id] = taskEvent.progress;\r\n\r\n                let sum = 0;\r\n                Object.values(progress).forEach(p => { sum += p; });\r\n\r\n                const outputLoadingProgress = (taskEventInfo.progressRange.max - taskEventInfo.progressRange.min) * (sum / outputIDs.length) + taskEventInfo.progressRange.min;\r\n                const eventProgressUpdate: ITaskEvent = { type: taskEventInfo.type, id: taskEventInfo.eventId, progress: outputLoadingProgress, data: taskEventInfo.data, status: 'Output content loading progress.' };\r\n                this._eventEngine.emitEvent(EVENTTYPE.TASK.TASK_PROCESS, eventProgressUpdate);\r\n            }\r\n        }\r\n        \r\n        let listenerTokens = [];\r\n        listenerTokens.push(this._eventEngine.addListener(EVENTTYPE.TASK.TASK_START, cb));\r\n        listenerTokens.push(this._eventEngine.addListener(EVENTTYPE.TASK.TASK_PROCESS, cb));\r\n        listenerTokens.push(this._eventEngine.addListener(EVENTTYPE.TASK.TASK_CANCEL, cb));\r\n        listenerTokens.push(this._eventEngine.addListener(EVENTTYPE.TASK.TASK_END, cb));\r\n\r\n        for (let outputID in outputs) {\r\n            // we store some necessary information as this data may have been changed after the await (see warning below)\r\n            outputInfo[outputID] = {\r\n                version: outputs[outputID].version,\r\n                contentFormat: outputs[outputID].content ? outputs[outputID].content!.map(c => c.format) : []\r\n            }\r\n\r\n            currentNodes[outputID] = {};\r\n            if(!this._loadedOutputNodes[outputID]) \r\n                this._loadedOutputNodes[outputID] = {};\r\n             \r\n            if(outputsFreeze[outputID]) {\r\n                currentNodes[outputID][outputInfo[outputID].version] = this._lastOutputNodes[outputID];\r\n                // no loading necessary, progress done\r\n                progress[outputID] = 1;\r\n            } else if(outputs[outputID].delay) {\r\n                maxDelay = Math.max(maxDelay, outputs[outputID].delay!);\r\n            } else if(!this._loadedOutputNodes[outputID][outputInfo[outputID].version]) {\r\n                currentNodes[outputID][outputInfo[outputID].version] = new SessionTreeNode(outputID);\r\n                currentNodes[outputID][outputInfo[outputID].version].data.push(new SessionOutputData(outputs[outputID]));\r\n                if(outputs[outputID].content) {\r\n                    for (let i = 0, len = outputs[outputID].content!.length; i < len; i++) {\r\n                        promises.push(this._dataEngine.loadContent(outputs[outputID].content![i], this._sessionEngine.jwtToken, outputID))\r\n                        promisesNodes.push(currentNodes[outputID][outputInfo[outputID].version])\r\n                    }\r\n                }\r\n            } else {\r\n                currentNodes[outputID][outputInfo[outputID].version] = this._loadedOutputNodes[outputID][outputInfo[outputID].version];\r\n                // no loading necessary, progress done\r\n                progress[outputID] = 1;\r\n            }\r\n        }\r\n\r\n        if(maxDelay)\r\n            throw new OutputDelayException(maxDelay);\r\n\r\n        /**\r\n         * WARNING: After this point outputs object cannot be used anymore.\r\n         * This can happen when fast consecutive scene updates are done.\r\n         * Therefore, we stored the data in the outputInfo.\r\n         */\r\n\r\n        await Promise.all(promises);\r\n\r\n        listenerTokens.forEach(t => this._eventEngine.removeListener(t));\r\n\r\n        // all promises are resolved, await in the next lines is just for structural purposes\r\n        for(let i = 0; i < promises.length; i++) \r\n            promisesNodes[i].addChild(await promises[i])\r\n\r\n        // here we assign all outputs just to the node and return it\r\n        for (let outputID in outputInfo)\r\n            node.addChild(currentNodes[outputID][outputInfo[outputID].version]);\r\n\r\n        // save the nodes as the last available version\r\n        for (let outputID in outputInfo) {\r\n            this._loadedOutputNodes[outputID] = {};\r\n            this._loadedOutputNodes[outputID][outputInfo[outputID].version] = currentNodes[outputID][outputInfo[outputID].version];\r\n            this._lastOutputNodes[outputID] = currentNodes[outputID][outputInfo[outputID].version];\r\n        }\r\n\r\n        for (let outputID in outputInfo) {\r\n            if(currentNodes[outputID][outputInfo[outputID].version].children.length > 1) {\r\n                for (let i = 0, len = outputInfo[outputID].contentFormat!.length; i < len; i++) {\r\n                    if(outputInfo[outputID].contentFormat[i] === 'sdtf') {\r\n                        this.mergeContentNodes(currentNodes[outputID][outputInfo[outputID].version])\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.assignMaterials(node);\r\n        this._performanceEvaluator.endSection('outputLoading');\r\n        return node;\r\n    }\r\n\r\n    // #endregion Public Methods (1)\r\n\r\n    // #region Private Methods (2)\r\n\r\n    private assignMaterials(node: ITreeNode) {\r\n        const addMaterialToGeometry = (node: ITreeNode, material: IMaterialAbstractData) => {\r\n            for (let i = 0; i < node.data.length; i++) {\r\n                if (node.data[i] instanceof GeometryData) {\r\n                    const geometry = <GeometryData>node.data[i];\r\n                    const currentMaterial = geometry.material;\r\n                    if(currentMaterial === null || currentMaterial.materialOutput === true) {\r\n                        geometry.material = material;\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                const child = node.children[i];\r\n                if (child) addMaterialToGeometry(child, material);\r\n            }\r\n        };\r\n\r\n        const getMaterialData = (node: ITreeNode, materials: IMaterialAbstractData[] = []): IMaterialAbstractData[] => {\r\n            for (let k = 0; k < node.data.length; k++) {\r\n                if (node.data[k] instanceof AbstractMaterialData) {\r\n                    const material = <IMaterialAbstractData>node.data[k];\r\n                    material.materialOutput = true;\r\n                    materials.push(material);\r\n                }\r\n            }\r\n            \r\n            for (let k = 0; k < node.children.length; k++) {\r\n                const child = node.children[k];\r\n                if(!child) continue;\r\n                materials.push(...getMaterialData(child));\r\n            }\r\n\r\n            return materials;\r\n        }\r\n\r\n        const getGeometryData = (node: ITreeNode, geometries: GeometryData[] = []): GeometryData[] => {\r\n            for (let k = 0; k < node.data.length; k++)\r\n                if (node.data[k] instanceof GeometryData)\r\n                    geometries.push(<GeometryData>node.data[k]);\r\n            \r\n            for (let k = 0; k < node.children.length; k++) {\r\n                const child = node.children[k];\r\n                if(!child) continue;\r\n                geometries.push(...getGeometryData(child));\r\n            }\r\n            return geometries;\r\n        }\r\n\r\n        for (let m = 0; m < node.children.length; m++) {\r\n            // per output node, we go through the material assignment process\r\n            const outputNode = node.children[m];\r\n            if (!outputNode) continue;\r\n\r\n            // we go through all data properties, normally, there should ony one, but we just make sure\r\n            for (let i = 0; i < outputNode.data.length; i++) {\r\n                if (!(outputNode.data[i] instanceof SessionOutputData)) continue;\r\n                \r\n                // the session output data contains information about this Output\r\n                // most importantly the SessionOutput property with the material and content in it\r\n                const sessionOutputData = <SessionOutputData>outputNode.data[i];\r\n\r\n                // case 1: we have a specific material id defined, let's use that\r\n                if(sessionOutputData.responseOutput.material) {\r\n                    let materialNodes: ITreeNode[] = [];\r\n                    // now we have id\r\n                    // get material with it    \r\n                    for (let n = 0; n < node.children.length; n++) {\r\n                        const materialNode = node.children[n];\r\n                        if (!materialNode) continue;\r\n                        if (materialNode.name === sessionOutputData.responseOutput.material)\r\n                            materialNodes = materialNode.children;\r\n                    }\r\n\r\n                    const geometryNodes = outputNode.children;\r\n\r\n                    if(materialNodes.length >= geometryNodes.length) {\r\n                        for (let n = 0; n < geometryNodes.length; n++) {\r\n                            addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[n])[0]);\r\n                        }\r\n                    } else {\r\n                        if (materialNodes.length >= 1)\r\n                            for (let n = 0; n < geometryNodes.length; n++) {\r\n                                addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[0])[0]);\r\n                            }\r\n                    }\r\n                } \r\n                // case 2: there is no specific material id defined, maybe in the content we can match geometries to ids\r\n                else {\r\n                    // now we hope that in our content, there are exactly the amount of geometries and material, this will be interesting :)\r\n\r\n                    const sessionOutputContent = sessionOutputData.responseOutput.content;\r\n                    if(sessionOutputContent === undefined) continue;\r\n\r\n                    const materialNodes = [];\r\n                    const geometryNodes = [];\r\n                    for(let i = 0; i < sessionOutputContent.length; i++) {\r\n                        if(sessionOutputContent[i].format === 'material') {\r\n                            materialNodes.push(outputNode.children[i]);\r\n                        } else {\r\n                            geometryNodes.push(outputNode.children[i]);\r\n                        }\r\n                    }\r\n\r\n                    if(materialNodes.length >= geometryNodes.length) {\r\n                        for (let n = 0; n < geometryNodes.length; n++) {\r\n                            addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[n])[0]);\r\n                        }\r\n                    } else {\r\n                        if (materialNodes.length >= 1)\r\n                            for (let n = 0; n < geometryNodes.length; n++) {\r\n                                addMaterialToGeometry(geometryNodes[n], getMaterialData(materialNodes[0])[0]);\r\n                            }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private mergeContentNodes(node: ISessionTreeNode) {\r\n        if(!(node.children.length > 1)) return;\r\n\r\n        const children = [];\r\n        while(node.children.length > 0) {\r\n            children.push(...node.children[0].children);\r\n            node.removeChild(node.children[0]);\r\n        }\r\n\r\n        const mergeNodes = (node1: ITreeNode, node2: ITreeNode) => {\r\n            for(let i = 0; i < node1.data.length; i++)\r\n                node2.data.push(node1.data[i]);\r\n\r\n            for(let i = 0; i < node1.children.length; i++) {\r\n                let childNode;\r\n                for(let j = 0; j < node2.children.length; j++) {\r\n                    if(node1.children[i].name === node2.children[j].name) {\r\n                        childNode = node2.children[j];\r\n                        break;\r\n                    }\r\n                }\r\n                if(!childNode) {\r\n                    childNode = new TreeNode(node1.children[i].name);\r\n                    node2.addChild(childNode);\r\n                }\r\n\r\n                mergeNodes(node1.children[i], childNode);\r\n            }\r\n        }\r\n\r\n        const newChild = new TreeNode('content_array');\r\n        node.addChild(newChild);\r\n        for(let i = 0; i < children.length; i++) \r\n            mergeNodes(children[i], newChild)\r\n    }\r\n\r\n    // #endregion Private Methods (2)\r\n}"]}},"error":null,"hash":"b0cb33071a9bbd7b2e5c6ee48d611b22","cacheData":{"env":{}}}