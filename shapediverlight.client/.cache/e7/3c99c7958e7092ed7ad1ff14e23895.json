{"id":"node_modules/@shapediver/viewer.utils.texture-unifier/dist/index.js","dependencies":[{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.utils.texture-unifier\\dist\\index.js.map","includedInParent":true,"mtime":1706527147833},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.utils.texture-unifier\\src\\index.ts","includedInParent":true,"mtime":1706527148030},{"name":"D:\\projects\\myProjects\\shapeApp\\package.json","includedInParent":true,"mtime":1706533774939},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.utils.texture-unifier\\package.json","includedInParent":true,"mtime":1706527147652},{"name":"three","loc":{"line":32,"column":35,"index":1717},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.utils.texture-unifier\\dist\\index.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\three\\build\\three.module.js"}],"generated":{"js":"\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.combineTextures = void 0;\r\nconst THREE = __importStar(require(\"three\"));\r\nlet mergeShader;\r\nlet quadCamera;\r\nlet quadScene;\r\nlet quad;\r\nlet renderer;\r\nconst createThreeJsUtils = () => {\r\n    mergeShader = new THREE.ShaderMaterial({\r\n        uniforms: {\r\n            tRed: { value: null },\r\n            activeRed: { value: false },\r\n            defaultRed: { value: 1.0 },\r\n            tGreen: { value: null },\r\n            activeGreen: { value: false },\r\n            defaultGreen: { value: 1.0 },\r\n            tBlue: { value: null },\r\n            activeBlue: { value: false },\r\n            defaultBlue: { value: 1.0 },\r\n        },\r\n        vertexShader: `// @author Michael Oppitz \r\n    \r\n        uniform sampler2D tRed;\r\n        uniform bool activeRed;\r\n        uniform float defaultRed;\r\n        \r\n        uniform sampler2D tGreen;\t\t\r\n        uniform bool activeGreen;\r\n        uniform float defaultGreen;\r\n        \r\n        uniform sampler2D tBlue;\t\t\r\n        uniform bool activeBlue;\r\n        uniform float defaultBlue;\r\n    \r\n        varying vec2 vUv;\r\n        \r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n        fragmentShader: `// @author Michael Oppitz \r\n    \r\n        uniform sampler2D tRed;\r\n        uniform bool activeRed;\r\n        uniform float defaultRed;\r\n        \r\n        uniform sampler2D tGreen;\t\t\r\n        uniform bool activeGreen;\r\n        uniform float defaultGreen;\r\n        \r\n        uniform sampler2D tBlue;\t\t\r\n        uniform bool activeBlue;\r\n        uniform float defaultBlue;\r\n        \r\n        varying vec2 vUv;\r\n        \r\n        void main() {\r\n            vec4 outColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n    \r\n            if(activeRed == true) {\r\n                outColor.r = texture2D(tRed, vUv).r;\r\n            } else {\r\n                outColor.r = defaultRed;\r\n            }\r\n        \r\n            if(activeGreen == true) {\r\n                outColor.g = texture2D(tGreen, vUv).g;\r\n            } else {\r\n                outColor.g = defaultGreen;\r\n            }\r\n        \r\n            if(activeBlue == true) {\r\n                outColor.b = texture2D(tBlue, vUv).b;\r\n            } else {\r\n                outColor.b = defaultBlue;\r\n            }\r\n        \r\n            gl_FragColor = outColor;\r\n        }`\r\n    });\r\n    quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\r\n    quadScene = new THREE.Scene();\r\n    quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mergeShader);\r\n    quadScene.add(quad);\r\n    renderer = new THREE.WebGLRenderer();\r\n};\r\nconst combineTextures = (red, green, blue) => __awaiter(void 0, void 0, void 0, function* () {\r\n    if (!red && !green && !blue)\r\n        throw new Error('No maps supplied.');\r\n    if (!renderer)\r\n        createThreeJsUtils();\r\n    let width = 0, height = 0;\r\n    const textures = [red, green, blue];\r\n    for (let t of textures) {\r\n        if (t) {\r\n            if (width === 0 && height === 0) {\r\n                width = t.width;\r\n                height = t.height;\r\n            }\r\n            else if (t.width !== width && t.height !== height) {\r\n                throw new Error('Maps have different sizes. Combining not supported.');\r\n            }\r\n        }\r\n    }\r\n    if (red) {\r\n        const redTexture = new THREE.Texture(red);\r\n        redTexture.needsUpdate = true;\r\n        mergeShader.uniforms.tRed.value = redTexture;\r\n        mergeShader.uniforms.activeRed.value = true;\r\n    }\r\n    else {\r\n        mergeShader.uniforms.activeRed.value = false;\r\n    }\r\n    if (green) {\r\n        const greenTexture = new THREE.Texture(green);\r\n        greenTexture.needsUpdate = true;\r\n        mergeShader.uniforms.tGreen.value = greenTexture;\r\n        mergeShader.uniforms.activeGreen.value = true;\r\n    }\r\n    else {\r\n        mergeShader.uniforms.activeGreen.value = false;\r\n    }\r\n    if (blue) {\r\n        const blueTexture = new THREE.Texture(blue);\r\n        blueTexture.needsUpdate = true;\r\n        mergeShader.uniforms.tBlue.value = blueTexture;\r\n        mergeShader.uniforms.activeBlue.value = true;\r\n    }\r\n    else {\r\n        mergeShader.uniforms.activeBlue.value = false;\r\n    }\r\n    // The different render targets that are used by the passes\r\n    const renderTarget = new THREE.WebGLRenderTarget(width, height, {\r\n        minFilter: THREE.LinearFilter,\r\n        magFilter: THREE.LinearFilter,\r\n        format: THREE.RGBAFormat\r\n    });\r\n    renderTarget.texture.name = 'target.rt';\r\n    renderer.setRenderTarget(renderTarget);\r\n    renderer.render(quadScene, quadCamera);\r\n    const buffer = new Uint8ClampedArray(4 * width * height);\r\n    renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, buffer);\r\n    let imageData = new ImageData(buffer, width, height);\r\n    var canvas = document.createElement('canvas');\r\n    var ctx = canvas.getContext('2d');\r\n    canvas.width = imageData.width;\r\n    canvas.height = imageData.height;\r\n    ctx.putImageData(imageData, 0, 0);\r\n    const imageOut = new Image();\r\n    const promise = new Promise(resolve => {\r\n        imageOut.onload = () => resolve();\r\n    });\r\n    imageOut.crossOrigin = \"anonymous\";\r\n    imageOut.src = canvas.toDataURL(\"image/jpeg\", 1.0);\r\n    yield promise;\r\n    return imageOut;\r\n});\r\nexports.combineTextures = combineTextures;\r\n"},"sourceMaps":{"js":{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as THREE from \"three\"\r\n\r\nlet mergeShader: THREE.ShaderMaterial;\r\nlet quadCamera: THREE.OrthographicCamera;\r\nlet quadScene: THREE.Scene;\r\nlet quad: THREE.Mesh;\r\nlet renderer: THREE.WebGLRenderer;\r\n\r\nconst createThreeJsUtils = () => {\r\n    mergeShader = new THREE.ShaderMaterial({\r\n        uniforms: {\r\n            tRed: { value: null },\r\n            activeRed: { value: false },\r\n            defaultRed: { value: 1.0 },\r\n            tGreen: { value: null },\r\n            activeGreen: { value: false },\r\n            defaultGreen: { value: 1.0 },\r\n            tBlue: { value: null },\r\n            activeBlue: { value: false },\r\n            defaultBlue: { value: 1.0 },\r\n        },\r\n        vertexShader: `// @author Michael Oppitz \r\n    \r\n        uniform sampler2D tRed;\r\n        uniform bool activeRed;\r\n        uniform float defaultRed;\r\n        \r\n        uniform sampler2D tGreen;\t\t\r\n        uniform bool activeGreen;\r\n        uniform float defaultGreen;\r\n        \r\n        uniform sampler2D tBlue;\t\t\r\n        uniform bool activeBlue;\r\n        uniform float defaultBlue;\r\n    \r\n        varying vec2 vUv;\r\n        \r\n        void main() {\r\n            vUv = uv;\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n        }`,\r\n        fragmentShader: `// @author Michael Oppitz \r\n    \r\n        uniform sampler2D tRed;\r\n        uniform bool activeRed;\r\n        uniform float defaultRed;\r\n        \r\n        uniform sampler2D tGreen;\t\t\r\n        uniform bool activeGreen;\r\n        uniform float defaultGreen;\r\n        \r\n        uniform sampler2D tBlue;\t\t\r\n        uniform bool activeBlue;\r\n        uniform float defaultBlue;\r\n        \r\n        varying vec2 vUv;\r\n        \r\n        void main() {\r\n            vec4 outColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n    \r\n            if(activeRed == true) {\r\n                outColor.r = texture2D(tRed, vUv).r;\r\n            } else {\r\n                outColor.r = defaultRed;\r\n            }\r\n        \r\n            if(activeGreen == true) {\r\n                outColor.g = texture2D(tGreen, vUv).g;\r\n            } else {\r\n                outColor.g = defaultGreen;\r\n            }\r\n        \r\n            if(activeBlue == true) {\r\n                outColor.b = texture2D(tBlue, vUv).b;\r\n            } else {\r\n                outColor.b = defaultBlue;\r\n            }\r\n        \r\n            gl_FragColor = outColor;\r\n        }`\r\n    });\r\n    \r\n    quadCamera = new THREE.OrthographicCamera(- 1, 1, 1, - 1, 0, 1);\r\n    quadScene = new THREE.Scene();\r\n    quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mergeShader);\r\n    quadScene.add(quad);\r\n    \r\n    renderer = new THREE.WebGLRenderer();\r\n}\r\n\r\nexport const combineTextures = async (red?: HTMLImageElement, green?: HTMLImageElement, blue?: HTMLImageElement): Promise<HTMLImageElement> => {\r\n    if (!red && !green && !blue)\r\n        throw new Error('No maps supplied.')\r\n\r\n    if(!renderer)\r\n        createThreeJsUtils()\r\n\r\n    let width = 0, height = 0;\r\n    const textures = [red, green, blue];\r\n    for (let t of textures) {\r\n        if (t) {\r\n            if (width === 0 && height === 0) {\r\n                width = t.width;\r\n                height = t.height;\r\n            } else if (t.width !== width && t.height !== height) {\r\n                throw new Error('Maps have different sizes. Combining not supported.')\r\n            }\r\n        }\r\n    }\r\n\r\n    if (red) {\r\n        const redTexture = new THREE.Texture(red);\r\n        redTexture.needsUpdate = true;\r\n        mergeShader.uniforms.tRed.value = redTexture;\r\n        mergeShader.uniforms.activeRed.value = true;\r\n    } else {\r\n        mergeShader.uniforms.activeRed.value = false;\r\n    }\r\n\r\n    if (green) {\r\n        const greenTexture = new THREE.Texture(green);\r\n        greenTexture.needsUpdate = true;\r\n        mergeShader.uniforms.tGreen.value = greenTexture;\r\n        mergeShader.uniforms.activeGreen.value = true;\r\n    } else {\r\n        mergeShader.uniforms.activeGreen.value = false;\r\n    }\r\n\r\n    if (blue) {\r\n        const blueTexture = new THREE.Texture(blue);\r\n        blueTexture.needsUpdate = true;\r\n        mergeShader.uniforms.tBlue.value = blueTexture;\r\n        mergeShader.uniforms.activeBlue.value = true;\r\n    } else {\r\n        mergeShader.uniforms.activeBlue.value = false;\r\n    }\r\n\r\n    // The different render targets that are used by the passes\r\n    const renderTarget = new THREE.WebGLRenderTarget(width, height, {\r\n        minFilter: THREE.LinearFilter,\r\n        magFilter: THREE.LinearFilter,\r\n        format: THREE.RGBAFormat\r\n    });\r\n    renderTarget.texture.name = 'target.rt';\r\n    renderer.setRenderTarget(renderTarget)\r\n\r\n    renderer.render(quadScene, quadCamera);\r\n\r\n    const buffer = new Uint8ClampedArray(4 * width * height);\r\n    renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, buffer)\r\n\r\n    let imageData = new ImageData(buffer, width, height);\r\n    var canvas = document.createElement('canvas');\r\n    var ctx = <CanvasRenderingContext2D>canvas.getContext('2d');\r\n    canvas.width = imageData.width;\r\n    canvas.height = imageData.height;\r\n    ctx.putImageData(imageData, 0, 0);\r\n\r\n    const imageOut = new Image();\r\n    const promise = new Promise<void>(resolve => {\r\n        imageOut.onload = () => resolve();\r\n    })\r\n    imageOut.crossOrigin = \"anonymous\";\r\n    imageOut.src = canvas.toDataURL(\"image/jpeg\", 1.0);\r\n\r\n    await promise;\r\n\r\n    return imageOut;\r\n}"]}},"error":null,"hash":"b8f073e5e9b2bb2f1be1ed3a8bd339c0","cacheData":{"env":{}}}