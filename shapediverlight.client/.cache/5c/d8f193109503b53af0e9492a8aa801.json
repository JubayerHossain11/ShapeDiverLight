{"id":"node_modules/@shapediver/viewer.rendering-engine-threejs.standard/dist/three/shaders/DepthLimitedBlurShader.js","dependencies":[{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\dist\\three\\shaders\\DepthLimitedBlurShader.js.map","includedInParent":true,"mtime":1706527153157},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\src\\three\\shaders\\DepthLimitedBlurShader.js","includedInParent":true,"mtime":1706527151682},{"name":"D:\\projects\\myProjects\\shapeApp\\package.json","includedInParent":true,"mtime":1706533774939},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\package.json","includedInParent":true,"mtime":1706527152875},{"name":"three","loc":{"line":4,"column":24,"index":171},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.rendering-engine-threejs.standard\\dist\\three\\shaders\\DepthLimitedBlurShader.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\three\\build\\three.module.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BlurShaderUtils = exports.DepthLimitedBlurShader = void 0;\r\nconst three_1 = require(\"three\");\r\n/**\r\n * TODO\r\n */\r\nconst DepthLimitedBlurShader = {\r\n    defines: {\r\n        'KERNEL_RADIUS': 4,\r\n        'DEPTH_PACKING': 1,\r\n        'PERSPECTIVE_CAMERA': 1\r\n    },\r\n    uniforms: {\r\n        'tDiffuse': { value: null },\r\n        'size': { value: new three_1.Vector2(512, 512) },\r\n        'sampleUvOffsets': { value: [new three_1.Vector2(0, 0)] },\r\n        'sampleWeights': { value: [1.0] },\r\n        'tDepth': { value: null },\r\n        'cameraNear': { value: 10 },\r\n        'cameraFar': { value: 1000 },\r\n        'depthCutoff': { value: 10 },\r\n    },\r\n    vertexShader: /* glsl */ `\r\n\r\n\t\t#include <common>\r\n\r\n\t\tuniform vec2 size;\r\n\r\n\t\tvarying vec2 vUv;\r\n\t\tvarying vec2 vInvSize;\r\n\r\n\t\tvoid main() {\r\n\t\t\tvUv = uv;\r\n\t\t\tvInvSize = 1.0 / size;\r\n\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t}`,\r\n    fragmentShader: /* glsl */ `\r\n\r\n\t\t#include <common>\r\n\t\t#include <packing>\r\n\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\tuniform sampler2D tDepth;\r\n\r\n\t\tuniform float cameraNear;\r\n\t\tuniform float cameraFar;\r\n\t\tuniform float depthCutoff;\r\n\r\n\t\tuniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\r\n\t\tuniform float sampleWeights[ KERNEL_RADIUS + 1 ];\r\n\r\n\t\tvarying vec2 vUv;\r\n\t\tvarying vec2 vInvSize;\r\n\r\n\t\tfloat getDepth( const in vec2 screenPosition ) {\r\n\t\t\t#if DEPTH_PACKING == 1\r\n\t\t\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\r\n\t\t\t#else\r\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\r\n\t\t\t#endif\r\n\t\t}\r\n\r\n\t\tfloat getViewZ( const in float depth ) {\r\n\t\t\t#if PERSPECTIVE_CAMERA == 1\r\n\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\r\n\t\t\t#else\r\n\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\r\n\t\t\t#endif\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\t\t\tfloat depth = getDepth( vUv );\r\n\t\t\tif( depth >= ( 1.0 - EPSILON ) ) {\r\n\t\t\t\tdiscard;\r\n\t\t\t}\r\n\r\n\t\t\tfloat centerViewZ = -getViewZ( depth );\r\n\t\t\tbool rBreak = false, lBreak = false;\r\n\r\n\t\t\tfloat weightSum = sampleWeights[0];\r\n\t\t\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\r\n\r\n\t\t\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\r\n\r\n\t\t\t\tfloat sampleWeight = sampleWeights[i];\r\n\t\t\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\r\n\r\n\t\t\t\tvec2 sampleUv = vUv + sampleUvOffset;\r\n\t\t\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\r\n\r\n\t\t\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\r\n\r\n\t\t\t\tif( ! rBreak ) {\r\n\t\t\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\r\n\t\t\t\t\tweightSum += sampleWeight;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsampleUv = vUv - sampleUvOffset;\r\n\t\t\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\r\n\r\n\t\t\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\r\n\r\n\t\t\t\tif( ! lBreak ) {\r\n\t\t\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\r\n\t\t\t\t\tweightSum += sampleWeight;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl_FragColor = diffuseSum / weightSum;\r\n\t\t}`\r\n};\r\nexports.DepthLimitedBlurShader = DepthLimitedBlurShader;\r\nconst BlurShaderUtils = {\r\n    createSampleWeights: function (kernelRadius, stdDev) {\r\n        const weights = [];\r\n        for (let i = 0; i <= kernelRadius; i++) {\r\n            weights.push(gaussian(i, stdDev));\r\n        }\r\n        return weights;\r\n    },\r\n    createSampleOffsets: function (kernelRadius, uvIncrement) {\r\n        const offsets = [];\r\n        for (let i = 0; i <= kernelRadius; i++) {\r\n            offsets.push(uvIncrement.clone().multiplyScalar(i));\r\n        }\r\n        return offsets;\r\n    },\r\n    configure: function (material, kernelRadius, stdDev, uvIncrement) {\r\n        material.defines['KERNEL_RADIUS'] = kernelRadius;\r\n        material.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\r\n        material.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\r\n        material.needsUpdate = true;\r\n    }\r\n};\r\nexports.BlurShaderUtils = BlurShaderUtils;\r\nfunction gaussian(x, stdDev) {\r\n    return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);\r\n}\r\n"},"sourceMaps":{"js":{"version":3,"file":"DepthLimitedBlurShader.js","sourceRoot":"","sources":["../../../src/three/shaders/DepthLimitedBlurShader.js"],"names":[],"mappings":";;;AAAA,iCAEe;AAEf;;GAEG;AAEH,MAAM,sBAAsB,GAAG;IAC9B,OAAO,EAAE;QACR,eAAe,EAAE,CAAC;QAClB,eAAe,EAAE,CAAC;QAClB,oBAAoB,EAAE,CAAC;KACvB;IACD,QAAQ,EAAE;QACT,UAAU,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE;QAC3B,MAAM,EAAE,EAAE,KAAK,EAAE,IAAI,eAAO,CAAE,GAAG,EAAE,GAAG,CAAE,EAAE;QAC1C,iBAAiB,EAAE,EAAE,KAAK,EAAE,CAAE,IAAI,eAAO,CAAE,CAAC,EAAE,CAAC,CAAE,CAAE,EAAE;QACrD,eAAe,EAAE,EAAE,KAAK,EAAE,CAAE,GAAG,CAAE,EAAE;QACnC,QAAQ,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE;QACzB,YAAY,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE;QAC3B,WAAW,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE;QAC5B,aAAa,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE;KAC5B;IACD,YAAY,EAAE,UAAU,CAAA;;;;;;;;;;;;;;IAcrB;IAEH,cAAc,EAAE,UAAU,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA0EvB;CAEH,CAAC;AAiDO,wDAAsB;AA/C/B,MAAM,eAAe,GAAG;IAEvB,mBAAmB,EAAE,UAAW,YAAY,EAAE,MAAM;QAEnD,MAAM,OAAO,GAAG,EAAE,CAAC;QAEnB,KAAM,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,YAAY,EAAE,CAAC,EAAG,EAAG;YAE1C,OAAO,CAAC,IAAI,CAAE,QAAQ,CAAE,CAAC,EAAE,MAAM,CAAE,CAAE,CAAC;SAEtC;QAED,OAAO,OAAO,CAAC;IAEhB,CAAC;IAED,mBAAmB,EAAE,UAAW,YAAY,EAAE,WAAW;QAExD,MAAM,OAAO,GAAG,EAAE,CAAC;QAEnB,KAAM,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,YAAY,EAAE,CAAC,EAAG,EAAG;YAE1C,OAAO,CAAC,IAAI,CAAE,WAAW,CAAC,KAAK,EAAE,CAAC,cAAc,CAAE,CAAC,CAAE,CAAE,CAAC;SAExD;QAED,OAAO,OAAO,CAAC;IAEhB,CAAC;IAED,SAAS,EAAE,UAAW,QAAQ,EAAE,YAAY,EAAE,MAAM,EAAE,WAAW;QAEhE,QAAQ,CAAC,OAAO,CAAE,eAAe,CAAE,GAAG,YAAY,CAAC;QACnD,QAAQ,CAAC,QAAQ,CAAE,iBAAiB,CAAE,CAAC,KAAK,GAAG,eAAe,CAAC,mBAAmB,CAAE,YAAY,EAAE,WAAW,CAAE,CAAC;QAChH,QAAQ,CAAC,QAAQ,CAAE,eAAe,CAAE,CAAC,KAAK,GAAG,eAAe,CAAC,mBAAmB,CAAE,YAAY,EAAE,MAAM,CAAE,CAAC;QACzG,QAAQ,CAAC,WAAW,GAAG,IAAI,CAAC;IAE7B,CAAC;CAED,CAAC;AAQ+B,0CAAe;AANhD,SAAS,QAAQ,CAAE,CAAC,EAAE,MAAM;IAE3B,OAAO,IAAI,CAAC,GAAG,CAAE,CAAE,CAAE,CAAC,GAAG,CAAC,CAAE,GAAG,CAAE,GAAG,GAAG,CAAE,MAAM,GAAG,MAAM,CAAE,CAAE,CAAE,GAAG,CAAE,IAAI,CAAC,IAAI,CAAE,GAAG,GAAG,IAAI,CAAC,EAAE,CAAE,GAAG,MAAM,CAAE,CAAC;AAE1G,CAAC","sourcesContent":["import {\r\n\tVector2\r\n} from 'three';\r\n\r\n/**\r\n * TODO\r\n */\r\n\r\nconst DepthLimitedBlurShader = {\r\n\tdefines: {\r\n\t\t'KERNEL_RADIUS': 4,\r\n\t\t'DEPTH_PACKING': 1,\r\n\t\t'PERSPECTIVE_CAMERA': 1\r\n\t},\r\n\tuniforms: {\r\n\t\t'tDiffuse': { value: null },\r\n\t\t'size': { value: new Vector2( 512, 512 ) },\r\n\t\t'sampleUvOffsets': { value: [ new Vector2( 0, 0 ) ] },\r\n\t\t'sampleWeights': { value: [ 1.0 ] },\r\n\t\t'tDepth': { value: null },\r\n\t\t'cameraNear': { value: 10 },\r\n\t\t'cameraFar': { value: 1000 },\r\n\t\t'depthCutoff': { value: 10 },\r\n\t},\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\t#include <common>\r\n\r\n\t\tuniform vec2 size;\r\n\r\n\t\tvarying vec2 vUv;\r\n\t\tvarying vec2 vInvSize;\r\n\r\n\t\tvoid main() {\r\n\t\t\tvUv = uv;\r\n\t\t\tvInvSize = 1.0 / size;\r\n\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\t#include <common>\r\n\t\t#include <packing>\r\n\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\tuniform sampler2D tDepth;\r\n\r\n\t\tuniform float cameraNear;\r\n\t\tuniform float cameraFar;\r\n\t\tuniform float depthCutoff;\r\n\r\n\t\tuniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\r\n\t\tuniform float sampleWeights[ KERNEL_RADIUS + 1 ];\r\n\r\n\t\tvarying vec2 vUv;\r\n\t\tvarying vec2 vInvSize;\r\n\r\n\t\tfloat getDepth( const in vec2 screenPosition ) {\r\n\t\t\t#if DEPTH_PACKING == 1\r\n\t\t\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\r\n\t\t\t#else\r\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\r\n\t\t\t#endif\r\n\t\t}\r\n\r\n\t\tfloat getViewZ( const in float depth ) {\r\n\t\t\t#if PERSPECTIVE_CAMERA == 1\r\n\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\r\n\t\t\t#else\r\n\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\r\n\t\t\t#endif\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\t\t\tfloat depth = getDepth( vUv );\r\n\t\t\tif( depth >= ( 1.0 - EPSILON ) ) {\r\n\t\t\t\tdiscard;\r\n\t\t\t}\r\n\r\n\t\t\tfloat centerViewZ = -getViewZ( depth );\r\n\t\t\tbool rBreak = false, lBreak = false;\r\n\r\n\t\t\tfloat weightSum = sampleWeights[0];\r\n\t\t\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\r\n\r\n\t\t\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\r\n\r\n\t\t\t\tfloat sampleWeight = sampleWeights[i];\r\n\t\t\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\r\n\r\n\t\t\t\tvec2 sampleUv = vUv + sampleUvOffset;\r\n\t\t\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\r\n\r\n\t\t\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\r\n\r\n\t\t\t\tif( ! rBreak ) {\r\n\t\t\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\r\n\t\t\t\t\tweightSum += sampleWeight;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsampleUv = vUv - sampleUvOffset;\r\n\t\t\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\r\n\r\n\t\t\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\r\n\r\n\t\t\t\tif( ! lBreak ) {\r\n\t\t\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\r\n\t\t\t\t\tweightSum += sampleWeight;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl_FragColor = diffuseSum / weightSum;\r\n\t\t}`\r\n\r\n};\r\n\r\nconst BlurShaderUtils = {\r\n\r\n\tcreateSampleWeights: function ( kernelRadius, stdDev ) {\r\n\r\n\t\tconst weights = [];\r\n\r\n\t\tfor ( let i = 0; i <= kernelRadius; i ++ ) {\r\n\r\n\t\t\tweights.push( gaussian( i, stdDev ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn weights;\r\n\r\n\t},\r\n\r\n\tcreateSampleOffsets: function ( kernelRadius, uvIncrement ) {\r\n\r\n\t\tconst offsets = [];\r\n\r\n\t\tfor ( let i = 0; i <= kernelRadius; i ++ ) {\r\n\r\n\t\t\toffsets.push( uvIncrement.clone().multiplyScalar( i ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn offsets;\r\n\r\n\t},\r\n\r\n\tconfigure: function ( material, kernelRadius, stdDev, uvIncrement ) {\r\n\r\n\t\tmaterial.defines[ 'KERNEL_RADIUS' ] = kernelRadius;\r\n\t\tmaterial.uniforms[ 'sampleUvOffsets' ].value = BlurShaderUtils.createSampleOffsets( kernelRadius, uvIncrement );\r\n\t\tmaterial.uniforms[ 'sampleWeights' ].value = BlurShaderUtils.createSampleWeights( kernelRadius, stdDev );\r\n\t\tmaterial.needsUpdate = true;\r\n\r\n\t}\r\n\r\n};\r\n\r\nfunction gaussian( x, stdDev ) {\r\n\r\n\treturn Math.exp( - ( x * x ) / ( 2.0 * ( stdDev * stdDev ) ) ) / ( Math.sqrt( 2.0 * Math.PI ) * stdDev );\r\n\r\n}\r\n\r\nexport { DepthLimitedBlurShader, BlurShaderUtils };\r\n"]}},"error":null,"hash":"d80fcd6a8d81cc8c76f7b3a84ab12d61","cacheData":{"env":{}}}