{"id":"node_modules/@shapediver/viewer.data-engine.html-element-anchor-engine/dist/HTMLElementAnchorEngine.js","dependencies":[{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.html-element-anchor-engine\\dist\\HTMLElementAnchorEngine.js.map","includedInParent":true,"mtime":1706527148259},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.html-element-anchor-engine\\src\\HTMLElementAnchorEngine.ts","includedInParent":true,"mtime":1706527148487},{"name":"D:\\projects\\myProjects\\shapeApp\\package.json","includedInParent":true,"mtime":1706533774939},{"name":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.html-element-anchor-engine\\package.json","includedInParent":true,"mtime":1706527147993},{"name":"@shapediver/viewer.shared.types","loc":{"line":13,"column":38,"index":850},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.html-element-anchor-engine\\dist\\HTMLElementAnchorEngine.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.types\\dist\\index.js"},{"name":"@shapediver/viewer.shared.node-tree","loc":{"line":14,"column":42,"index":929},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.html-element-anchor-engine\\dist\\HTMLElementAnchorEngine.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.node-tree\\dist\\index.js"},{"name":"@shapediver/viewer.shared.services","loc":{"line":15,"column":41,"index":1011},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.html-element-anchor-engine\\dist\\HTMLElementAnchorEngine.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.services\\dist\\index.js"},{"name":"@shapediver/viewer.shared.math","loc":{"line":16,"column":37,"index":1088},"parent":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.data-engine.html-element-anchor-engine\\dist\\HTMLElementAnchorEngine.js","resolved":"D:\\projects\\myProjects\\shapeApp\\node_modules\\@shapediver\\viewer.shared.math\\dist\\index.js"}],"generated":{"js":"\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HTMLElementAnchorEngine = void 0;\r\nconst viewer_shared_types_1 = require(\"@shapediver/viewer.shared.types\");\r\nconst viewer_shared_node_tree_1 = require(\"@shapediver/viewer.shared.node-tree\");\r\nconst viewer_shared_services_1 = require(\"@shapediver/viewer.shared.services\");\r\nconst viewer_shared_math_1 = require(\"@shapediver/viewer.shared.math\");\r\nclass HTMLElementAnchorEngine {\r\n    constructor() {\r\n        // #region Properties (4)\r\n        this._converter = viewer_shared_services_1.Converter.instance;\r\n        this._inputValidator = viewer_shared_services_1.InputValidator.instance;\r\n        this._logger = viewer_shared_services_1.Logger.instance;\r\n        // #endregion Public Methods (1)\r\n    }\r\n    // #endregion Properties (4)\r\n    // #region Public Static Accessors (1)\r\n    static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n    // #endregion Public Static Accessors (1)\r\n    // #region Public Methods (1)\r\n    /**\r\n     * Load the material content into a scene graph node.\r\n     *\r\n     * @param content the material content\r\n     * @returns the scene graph node\r\n     */\r\n    loadContent(content) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const node = new viewer_shared_node_tree_1.TreeNode('htmlElementAnchors');\r\n                if (content.format === 'tag2d') {\r\n                    const data = content.data;\r\n                    data.forEach((element) => {\r\n                        // we need a location and a text, otherwise this doesn't make sense\r\n                        if (!element.location || !element.text) {\r\n                            this._logger.warn('HTMLElementAnchorEngine.load: One of the specified Tag2D elements did not have all necessary properties.');\r\n                            return;\r\n                        }\r\n                        const cleanedText = this._inputValidator.sanitize(element.text);\r\n                        node.data.push(new viewer_shared_types_1.HTMLElementAnchorTextData({\r\n                            location: this._converter.toVec3(element.location),\r\n                            data: { color: element.color || '#000000', text: cleanedText }\r\n                        }));\r\n                    });\r\n                }\r\n                else if (content.format === 'anchor') {\r\n                    const data = content.data;\r\n                    data.forEach((element) => {\r\n                        if (!element.location || !element.data) {\r\n                            this._logger.warn('HTMLElementAnchorEngine.load: One of the specified Anchor elements did not have all necessary properties.');\r\n                            return;\r\n                        }\r\n                        let position;\r\n                        if (element.data.position)\r\n                            position = {\r\n                                vertical: element.data.position.vertical,\r\n                                horizontal: element.data.position.horizontal\r\n                            };\r\n                        let intersectionTarget;\r\n                        if (element.intersectionTarget) {\r\n                            if (typeof element.intersectionTarget === 'string' || Array.isArray(element.intersectionTarget)) {\r\n                                intersectionTarget = element.intersectionTarget;\r\n                            }\r\n                            else if (element.intersectionTarget.min && element.intersectionTarget.max) {\r\n                                intersectionTarget = new viewer_shared_math_1.Box(this._converter.toVec3(element.intersectionTarget.min), this._converter.toVec3(element.intersectionTarget.max));\r\n                            }\r\n                        }\r\n                        if (!element.format || (element.format === 'text')) {\r\n                            if (!element.data.text) {\r\n                                this._logger.warn('HTMLElementAnchorEngine.load: The text property for an Anchor element is missing.');\r\n                                return;\r\n                            }\r\n                            const textData = element.data;\r\n                            const cleanedText = this._inputValidator.sanitize(textData.text);\r\n                            node.data.push(new viewer_shared_types_1.HTMLElementAnchorTextData({\r\n                                location: this._converter.toVec3(element.location),\r\n                                data: {\r\n                                    color: textData.color || '#000000',\r\n                                    text: cleanedText,\r\n                                    hidden: textData.hidden,\r\n                                    textAlign: textData.textAlign,\r\n                                    position\r\n                                },\r\n                                hideable: element.hideable,\r\n                                viewports: element.viewports,\r\n                                intersectionTarget\r\n                            }));\r\n                        }\r\n                        else if (element.format === 'image') {\r\n                            if (!element.data.src || !element.data.width || !element.data.height || !element.data.alt) {\r\n                                this._logger.warn('HTMLElementAnchorEngine.load: One of the specified Anchor elements did not have all necessary properties.');\r\n                                return;\r\n                            }\r\n                            const imageData = element.data;\r\n                            node.data.push(new viewer_shared_types_1.HTMLElementAnchorImageData({\r\n                                location: this._converter.toVec3(element.location),\r\n                                data: {\r\n                                    alt: imageData.alt,\r\n                                    height: typeof imageData.height === 'string' ? +imageData.height : imageData.height,\r\n                                    width: typeof imageData.width === 'string' ? +imageData.width : imageData.width,\r\n                                    src: imageData.src,\r\n                                    hidden: imageData.hidden,\r\n                                    position\r\n                                },\r\n                                hideable: element.hideable,\r\n                                viewports: element.viewports,\r\n                                intersectionTarget\r\n                            }));\r\n                        }\r\n                        this._logger.warn(`HTMLElementAnchorEngine.load: The Anchor does not have a recognized format: ${element.format}`);\r\n                    });\r\n                }\r\n                return node;\r\n            }\r\n            catch (e) {\r\n                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('HTMLElementAnchorEngine.load: Loading of anchors failed.');\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.HTMLElementAnchorEngine = HTMLElementAnchorEngine;\r\n"},"sourceMaps":{"js":{"version":3,"file":"HTMLElementAnchorEngine.js","sourceRoot":"","sources":["../src/HTMLElementAnchorEngine.ts"],"names":[],"mappings":"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","sourcesContent":["import { HTMLElementAnchorData, HTMLElementAnchorTextData, HTMLElementAnchorImageData, IAnchorDataText, IAnchorDataImage } from '@shapediver/viewer.shared.types'\r\nimport { ITreeNode, TreeNode } from '@shapediver/viewer.shared.node-tree'\r\nimport { Logger, Converter, ShapeDiverViewerDataProcessingError, InputValidator } from '@shapediver/viewer.shared.services'\r\nimport { vec3, vec4 } from 'gl-matrix'\r\nimport { Box } from '@shapediver/viewer.shared.math'\r\nimport { ShapeDiverResponseOutputContent } from '@shapediver/sdk.geometry-api-sdk-v2'\r\nimport { IAnchor, ITag2D } from '@shapediver/viewer.data-engine.shared-types'\r\n\r\nexport class HTMLElementAnchorEngine {\r\n    // #region Properties (4)\r\n\r\n    private readonly _converter: Converter = Converter.instance;\r\n    private readonly _inputValidator: InputValidator = InputValidator.instance;\r\n    private readonly _logger: Logger = Logger.instance;\r\n\r\n    private static _instance: HTMLElementAnchorEngine;\r\n\r\n    // #endregion Properties (4)\r\n\r\n    // #region Public Static Accessors (1)\r\n\r\n    public static get instance() {\r\n        return this._instance || (this._instance = new this());\r\n    }\r\n\r\n    // #endregion Public Static Accessors (1)\r\n\r\n    // #region Public Methods (1)\r\n\r\n    /**\r\n     * Load the material content into a scene graph node.\r\n     * \r\n     * @param content the material content\r\n     * @returns the scene graph node \r\n     */\r\n    public async loadContent(content: ShapeDiverResponseOutputContent): Promise<ITreeNode> {\r\n        try {\r\n            const node = new TreeNode('htmlElementAnchors');\r\n            if (content.format === 'tag2d') {\r\n                const data: ITag2D[] = content.data;\r\n                data.forEach((element: ITag2D) => {\r\n                    // we need a location and a text, otherwise this doesn't make sense\r\n                    if (!element.location || !element.text) {\r\n                        this._logger.warn('HTMLElementAnchorEngine.load: One of the specified Tag2D elements did not have all necessary properties.');\r\n                        return;\r\n                    }\r\n                    const cleanedText = this._inputValidator.sanitize(element.text);\r\n                    node.data.push(new HTMLElementAnchorTextData({\r\n                        location: this._converter.toVec3(element.location),\r\n                        data: { color: element.color || '#000000', text: cleanedText }\r\n                    }))\r\n                });\r\n            } else if (content.format === 'anchor') {\r\n                const data: IAnchor[] = content.data;\r\n                data.forEach((element: IAnchor) => {\r\n                    if (!element.location || !element.data) {\r\n                        this._logger.warn('HTMLElementAnchorEngine.load: One of the specified Anchor elements did not have all necessary properties.');\r\n                        return;\r\n                    }\r\n\r\n                    let position\r\n                    if (element.data.position)\r\n                        position = {\r\n                            vertical: element.data.position.vertical,\r\n                            horizontal: element.data.position.horizontal\r\n                        }\r\n\r\n                    let intersectionTarget;\r\n                    if (element.intersectionTarget) {\r\n                        if (typeof element.intersectionTarget === 'string' || Array.isArray(element.intersectionTarget)) {\r\n                            intersectionTarget = element.intersectionTarget;\r\n                        } else if (element.intersectionTarget.min && element.intersectionTarget.max) {\r\n                            intersectionTarget = new Box(this._converter.toVec3(element.intersectionTarget.min), this._converter.toVec3(element.intersectionTarget.max))\r\n                        }\r\n                    }\r\n\r\n                    if (!element.format || (element.format === 'text')) {\r\n                        if (!(<IAnchorDataText>element.data).text) {\r\n                            this._logger.warn('HTMLElementAnchorEngine.load: The text property for an Anchor element is missing.');\r\n                            return;\r\n                        }\r\n                        const textData = <IAnchorDataText>element.data;\r\n                        const cleanedText = this._inputValidator.sanitize(textData.text);\r\n\r\n                        node.data.push(new HTMLElementAnchorTextData({\r\n                            location: this._converter.toVec3(element.location),\r\n                            data: {\r\n                                color: textData.color || '#000000',\r\n                                text: cleanedText,\r\n                                hidden: textData.hidden,\r\n                                textAlign: textData.textAlign,\r\n                                position\r\n                            },\r\n                            hideable: element.hideable,\r\n                            viewports: element.viewports,\r\n                            intersectionTarget\r\n                        }));\r\n\r\n                    } else if (element.format === 'image') {\r\n                        if (!(<IAnchorDataImage>element.data).src || !(<IAnchorDataImage>element.data).width || !(<IAnchorDataImage>element.data).height || !(<IAnchorDataImage>element.data).alt) {\r\n                            this._logger.warn('HTMLElementAnchorEngine.load: One of the specified Anchor elements did not have all necessary properties.');\r\n                            return;\r\n                        }\r\n                        const imageData = <IAnchorDataImage>element.data;\r\n                        node.data.push(new HTMLElementAnchorImageData({\r\n                            location: this._converter.toVec3(element.location),\r\n                            data: {\r\n                                alt: imageData.alt,\r\n                                height: typeof imageData.height === 'string' ? +imageData.height : imageData.height,\r\n                                width: typeof imageData.width === 'string' ? +imageData.width : imageData.width,\r\n                                src: imageData.src,\r\n                                hidden: imageData.hidden,\r\n                                position\r\n                            },\r\n                            hideable: element.hideable,\r\n                            viewports: element.viewports,\r\n                            intersectionTarget\r\n                        }));\r\n                    }\r\n                    this._logger.warn(`HTMLElementAnchorEngine.load: The Anchor does not have a recognized format: ${element.format}`);\r\n                });\r\n            }\r\n            return node;\r\n        } catch (e) {\r\n            throw new ShapeDiverViewerDataProcessingError('HTMLElementAnchorEngine.load: Loading of anchors failed.');\r\n        }\r\n    }\r\n\r\n    // #endregion Public Methods (1)\r\n}"]}},"error":null,"hash":"536b22b65a7dbe11fa17217cb1a2fcb5","cacheData":{"env":{}}}