{"id":"node_modules/@shapediver/viewer.rendering-engine.camera-engine/dist/implementation/controls/perspective/CameraControlsLogic.js","dependencies":[{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.camera-engine\\dist\\implementation\\controls\\perspective\\CameraControlsLogic.js.map","includedInParent":true,"mtime":1706542086491},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.camera-engine\\src\\implementation\\controls\\perspective\\CameraControlsLogic.ts","includedInParent":true,"mtime":1706542087016},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\package.json","includedInParent":true,"mtime":1706542184022},{"name":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.camera-engine\\package.json","includedInParent":true,"mtime":1706542086292},{"name":"gl-matrix","loc":{"line":4,"column":28,"index":146},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.camera-engine\\dist\\implementation\\controls\\perspective\\CameraControlsLogic.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\gl-matrix\\esm\\index.js"},{"name":"@shapediver/viewer.shared.math","loc":{"line":5,"column":37,"index":198},"parent":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.rendering-engine.camera-engine\\dist\\implementation\\controls\\perspective\\CameraControlsLogic.js","resolved":"F:\\UpworkProjects\\ShapeDiverLight\\ShapeDiverLight\\shapediverlight.client\\node_modules\\@shapediver\\viewer.shared.math\\dist\\index.js"}],"generated":{"js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CameraControlsLogic = void 0;\r\nconst gl_matrix_1 = require(\"gl-matrix\");\r\nconst viewer_shared_math_1 = require(\"@shapediver/viewer.shared.math\");\r\nclass CameraControlsLogic {\r\n    // #endregion Properties (15)\r\n    // #region Constructors (1)\r\n    constructor(_controls) {\r\n        this._controls = _controls;\r\n        // #region Properties (15)\r\n        this._adjustedSettings = {\r\n            autoRotationSpeed: () => this._controls.autoRotationSpeed * this._settingsAdjustments.autoRotationSpeed,\r\n            damping: () => this._controls.damping * this._settingsAdjustments.damping,\r\n            movementSmoothness: () => this._controls.movementSmoothness * this._settingsAdjustments.movementSmoothness,\r\n            panSpeed: () => this._controls.panSpeed * this._settingsAdjustments.panSpeed,\r\n            rotationSpeed: () => this._controls.rotationSpeed * this._settingsAdjustments.rotationSpeed,\r\n            zoomSpeed: () => this._controls.zoomSpeed * this._settingsAdjustments.zoomSpeed,\r\n        };\r\n        this._damping = {\r\n            rotation: {\r\n                time: 0,\r\n                duration: 0,\r\n                theta: 0,\r\n                phi: 0\r\n            },\r\n            zoom: {\r\n                time: 0,\r\n                duration: 0,\r\n                delta: 0\r\n            },\r\n            pan: {\r\n                time: 0,\r\n                duration: 0,\r\n                offset: gl_matrix_1.vec3.create()\r\n            },\r\n        };\r\n        this._dollyDelta = 0;\r\n        this._dollyEnd = 0;\r\n        this._dollyStart = 0;\r\n        this._panDelta = gl_matrix_1.vec2.create();\r\n        this._panEnd = gl_matrix_1.vec2.create();\r\n        this._panStart = gl_matrix_1.vec2.create();\r\n        this._rotateDelta = gl_matrix_1.vec2.create();\r\n        this._rotateEnd = gl_matrix_1.vec2.create();\r\n        this._rotateStart = gl_matrix_1.vec2.create();\r\n        this._settingsAdjustments = {\r\n            autoRotationSpeed: 2 * Math.PI / 60 / 60,\r\n            damping: 1.0,\r\n            movementSmoothness: 1.0,\r\n            panSpeed: 2.0,\r\n            rotationSpeed: Math.PI,\r\n            zoomSpeed: 0.025,\r\n        };\r\n        this._touchAdjustments = {\r\n            autoRotationSpeed: 1.0,\r\n            damping: 1.0,\r\n            movementSmoothness: 1.0,\r\n            panSpeed: 1.5,\r\n            rotationSpeed: 2.0,\r\n            zoomSpeed: 100.0,\r\n        };\r\n        this._quat = gl_matrix_1.quat.fromValues(-Math.sin(Math.PI / 4), 0, 0, Math.sin(Math.PI / 4));\r\n        this._quatInverse = gl_matrix_1.quat.fromValues(Math.sin(Math.PI / 4), 0, 0, Math.sin(Math.PI / 4));\r\n    }\r\n    // #endregion Constructors (1)\r\n    // #region Public Methods (7)\r\n    isWithinRestrictions(position, target) {\r\n        let pBox = new viewer_shared_math_1.Box(this._controls.cubePositionRestriction.min, this._controls.cubePositionRestriction.max), pSphere = new viewer_shared_math_1.Sphere(this._controls.spherePositionRestriction.center, this._controls.spherePositionRestriction.radius), tBox = new viewer_shared_math_1.Box(this._controls.cubeTargetRestriction.min, this._controls.cubeTargetRestriction.max), tSphere = new viewer_shared_math_1.Sphere(this._controls.sphereTargetRestriction.center, this._controls.sphereTargetRestriction.radius);\r\n        if (!(pBox.containsPoint(position) && pSphere.containsPoint(position)))\r\n            return false;\r\n        if (!(tBox.containsPoint(target) && tSphere.containsPoint(target)))\r\n            return false;\r\n        let currentDistance = gl_matrix_1.vec3.distance(position, target);\r\n        if (currentDistance > this._controls.zoomRestriction.maxDistance || currentDistance < this._controls.zoomRestriction.minDistance)\r\n            return false;\r\n        let minPolarAngle = this._controls.rotationRestriction.minPolarAngle * (Math.PI / 180), maxPolarAngle = this._controls.rotationRestriction.maxPolarAngle * (Math.PI / 180), minAzimuthAngle = this._controls.rotationRestriction.minAzimuthAngle * (Math.PI / 180), maxAzimuthAngle = this._controls.rotationRestriction.maxAzimuthAngle * (Math.PI / 180);\r\n        if (minAzimuthAngle !== -Infinity ||\r\n            maxAzimuthAngle !== Infinity ||\r\n            minPolarAngle !== 0 ||\r\n            maxPolarAngle !== 180) {\r\n            let offset = gl_matrix_1.vec3.sub(gl_matrix_1.vec3.create(), position, target);\r\n            gl_matrix_1.vec3.transformQuat(offset, offset, this._quat);\r\n            const spherical = new viewer_shared_math_1.Spherical().fromVec3(offset);\r\n            if (spherical.theta < minAzimuthAngle ||\r\n                spherical.theta > maxAzimuthAngle ||\r\n                spherical.phi < minPolarAngle ||\r\n                spherical.phi > maxPolarAngle) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    pan(x, y, active, touch) {\r\n        if (touch) {\r\n            x = x / window.devicePixelRatio;\r\n            y = y / window.devicePixelRatio;\r\n        }\r\n        if (!active) {\r\n            this._panStart = gl_matrix_1.vec2.fromValues(x, y);\r\n        }\r\n        else {\r\n            this._panEnd = gl_matrix_1.vec2.fromValues(x, y);\r\n            gl_matrix_1.vec2.sub(this._panDelta, this._panEnd, this._panStart);\r\n            if (this._panDelta[0] === 0 && this._panDelta[1] === 0)\r\n                return;\r\n            gl_matrix_1.vec2.copy(this._panStart, this._panEnd);\r\n            const adjustedPanSpeed = this._adjustedSettings.panSpeed() * (touch ? this._touchAdjustments.panSpeed : 1.0);\r\n            let offset = this.panDeltaToOffset(gl_matrix_1.vec2.mul(gl_matrix_1.vec2.create(), this._panDelta, gl_matrix_1.vec2.fromValues(adjustedPanSpeed, adjustedPanSpeed)));\r\n            if (this._damping.pan.duration > 0) {\r\n                if (offset[0] < 0) {\r\n                    offset[0] = Math.min(offset[0], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[0]);\r\n                }\r\n                else {\r\n                    offset[0] = Math.max(offset[0], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[0]);\r\n                }\r\n                if (offset[1] < 0) {\r\n                    offset[1] = Math.min(offset[1], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[1]);\r\n                }\r\n                else {\r\n                    offset[1] = Math.max(offset[1], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[1]);\r\n                }\r\n                if (offset[2] < 0) {\r\n                    offset[2] = Math.min(offset[2], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[2]);\r\n                }\r\n                else {\r\n                    offset[2] = Math.max(offset[2], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[2]);\r\n                }\r\n            }\r\n            let damping = 1 - Math.max(0.01, Math.min(0.99, this._adjustedSettings.damping()));\r\n            let framesOffsetX = (Math.log(1 / Math.abs(offset[0])) - 5 * Math.log(10)) / (Math.log(damping));\r\n            let framesOffsetY = (Math.log(1 / Math.abs(offset[1])) - 5 * Math.log(10)) / (Math.log(damping));\r\n            let framesOffsetZ = (Math.log(1 / Math.abs(offset[2])) - 5 * Math.log(10)) / (Math.log(damping));\r\n            this._damping.pan.time = 0;\r\n            this._damping.pan.duration = Math.max(framesOffsetX, Math.max(framesOffsetY, framesOffsetZ)) * 16.6666;\r\n            this._damping.pan.offset = gl_matrix_1.vec3.clone(offset);\r\n            this._damping.rotation.duration = 0;\r\n            this._damping.zoom.duration = 0;\r\n            this._controls.applyTargetVector(offset, true);\r\n            this._controls.applyPositionVector(offset, true);\r\n        }\r\n    }\r\n    reset() {\r\n        this._damping = {\r\n            rotation: {\r\n                time: 0,\r\n                duration: 0,\r\n                theta: 0,\r\n                phi: 0\r\n            },\r\n            zoom: {\r\n                time: 0,\r\n                duration: 0,\r\n                delta: 0\r\n            },\r\n            pan: {\r\n                time: 0,\r\n                duration: 0,\r\n                offset: gl_matrix_1.vec3.create()\r\n            },\r\n        };\r\n        this._dollyDelta = 0;\r\n        this._dollyEnd = 0;\r\n        this._dollyStart = 0;\r\n        this._panDelta = gl_matrix_1.vec2.create();\r\n        this._panEnd = gl_matrix_1.vec2.create();\r\n        this._panStart = gl_matrix_1.vec2.create();\r\n        this._rotateDelta = gl_matrix_1.vec2.create();\r\n        this._rotateEnd = gl_matrix_1.vec2.create();\r\n        this._rotateStart = gl_matrix_1.vec2.create();\r\n    }\r\n    restrict(position, target) {\r\n        let pBox = new viewer_shared_math_1.Box(this._controls.cubePositionRestriction.min, this._controls.cubePositionRestriction.max), pSphere = new viewer_shared_math_1.Sphere(this._controls.spherePositionRestriction.center, this._controls.spherePositionRestriction.radius), tBox = new viewer_shared_math_1.Box(this._controls.cubeTargetRestriction.min, this._controls.cubeTargetRestriction.max), tSphere = new viewer_shared_math_1.Sphere(this._controls.sphereTargetRestriction.center, this._controls.sphereTargetRestriction.radius);\r\n        if (!pBox.containsPoint(position))\r\n            position = pBox.clampPoint(position);\r\n        if (!pSphere.containsPoint(position))\r\n            position = pSphere.clampPoint(position);\r\n        if (!tBox.containsPoint(target))\r\n            target = tBox.clampPoint(target);\r\n        if (!tSphere.containsPoint(target))\r\n            target = tSphere.clampPoint(target);\r\n        // zoom restrictions\r\n        let currentDistance = gl_matrix_1.vec3.distance(position, target);\r\n        if (currentDistance > this._controls.zoomRestriction.maxDistance || currentDistance < this._controls.zoomRestriction.minDistance) {\r\n            let direction = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), position, target));\r\n            let distance = Math.max(this._controls.zoomRestriction.minDistance, Math.min(this._controls.zoomRestriction.maxDistance, currentDistance));\r\n            gl_matrix_1.vec3.add(position, gl_matrix_1.vec3.multiply(position, direction, gl_matrix_1.vec3.fromValues(distance, distance, distance)), target);\r\n        }\r\n        // angle restrictions\r\n        let minPolarAngle = this._controls.rotationRestriction.minPolarAngle * (Math.PI / 180), maxPolarAngle = this._controls.rotationRestriction.maxPolarAngle * (Math.PI / 180), minAzimuthAngle = this._controls.rotationRestriction.minAzimuthAngle * (Math.PI / 180), maxAzimuthAngle = this._controls.rotationRestriction.maxAzimuthAngle * (Math.PI / 180);\r\n        if (minAzimuthAngle !== -Infinity ||\r\n            maxAzimuthAngle !== Infinity ||\r\n            minPolarAngle !== 0 ||\r\n            maxPolarAngle !== 180) {\r\n            let offset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), position, target);\r\n            gl_matrix_1.vec3.transformQuat(offset, offset, this._quat);\r\n            const spherical = new viewer_shared_math_1.Spherical().fromVec3(offset);\r\n            if (spherical.theta < minAzimuthAngle ||\r\n                spherical.theta > maxAzimuthAngle ||\r\n                spherical.phi < minPolarAngle ||\r\n                spherical.phi > maxPolarAngle) {\r\n                spherical.theta = Math.max(minAzimuthAngle, Math.min(maxAzimuthAngle, spherical.theta));\r\n                spherical.phi = Math.max(minPolarAngle, Math.min(maxPolarAngle, spherical.phi));\r\n                spherical.makeSafe();\r\n                offset = spherical.toVec3();\r\n                gl_matrix_1.vec3.transformQuat(offset, offset, this._quatInverse);\r\n                gl_matrix_1.vec3.add(position, offset, target);\r\n            }\r\n        }\r\n        return { position, target };\r\n    }\r\n    rotate(x, y, active, touch) {\r\n        if (touch) {\r\n            x = x / window.devicePixelRatio;\r\n            y = y / window.devicePixelRatio;\r\n        }\r\n        if (!active) {\r\n            this._rotateStart = gl_matrix_1.vec2.fromValues(x, y);\r\n        }\r\n        else {\r\n            this._rotateEnd = gl_matrix_1.vec2.fromValues(x, y);\r\n            gl_matrix_1.vec2.subtract(this._rotateDelta, this._rotateEnd, this._rotateStart);\r\n            gl_matrix_1.vec2.copy(this._rotateStart, this._rotateEnd);\r\n            if (!this._controls.canvas)\r\n                return;\r\n            if (this._controls.canvas.clientWidth == 0 || this._controls.canvas.clientHeight == 0)\r\n                return;\r\n            const spherical = new viewer_shared_math_1.Spherical();\r\n            let rotationSpeed = this._adjustedSettings.rotationSpeed() * (touch ? this._touchAdjustments.rotationSpeed : 1.0);\r\n            spherical.theta -= rotationSpeed * this._rotateDelta[0];\r\n            spherical.phi -= rotationSpeed * this._rotateDelta[1];\r\n            if (this._damping.rotation.duration > 0) {\r\n                let thetaDelta = this._damping.rotation.theta - spherical.theta;\r\n                spherical.theta += thetaDelta * this._adjustedSettings.movementSmoothness();\r\n                let phiDelta = this._damping.rotation.phi - spherical.phi;\r\n                spherical.phi += phiDelta * this._adjustedSettings.movementSmoothness();\r\n            }\r\n            let offset = this.rotationSphericalToOffset(spherical);\r\n            let damping = 1 - Math.max(0.01, Math.min(1, this._adjustedSettings.damping()));\r\n            let framesTheta = (Math.log(1 / Math.abs(spherical.theta)) - 5 * Math.log(10)) / (Math.log(damping));\r\n            let framesPhi = (Math.log(1 / Math.abs(spherical.phi)) - 5 * Math.log(10)) / (Math.log(damping));\r\n            this._damping.rotation.time = 0;\r\n            this._damping.rotation.duration = Math.max(framesTheta, framesPhi) * 16.6666;\r\n            this._damping.rotation.theta = spherical.theta;\r\n            this._damping.rotation.phi = spherical.phi;\r\n            this._damping.pan.duration = 0;\r\n            this._damping.zoom.duration = 0;\r\n            this._controls.applyPositionVector(offset, true);\r\n        }\r\n    }\r\n    update(time, manualInteraction) {\r\n        if (manualInteraction === true) {\r\n            this._damping.zoom.duration = 0;\r\n            this._damping.pan.duration = 0;\r\n            this._damping.rotation.duration = 0;\r\n        }\r\n        let damping = 1 - Math.max(0.01, Math.min(1, this._adjustedSettings.damping()));\r\n        if (this._damping.pan.duration > 0) {\r\n            if (this._damping.pan.time + time > this._damping.pan.duration) {\r\n                this._damping.pan.time = this._damping.pan.duration;\r\n                this._damping.pan.duration = 0;\r\n            }\r\n            else {\r\n                this._damping.pan.time += time;\r\n                let frameSinceStart = this._damping.pan.time / 16.6666;\r\n                let dampingFrames = Math.pow(damping, frameSinceStart);\r\n                let offset = gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), this._damping.pan.offset, gl_matrix_1.vec3.fromValues(dampingFrames, dampingFrames, dampingFrames));\r\n                this._controls.applyTargetVector(offset);\r\n                this._controls.applyPositionVector(offset);\r\n            }\r\n        }\r\n        else {\r\n            this._damping.pan.time = 0;\r\n        }\r\n        if (this._damping.rotation.duration > 0) {\r\n            if (this._damping.rotation.time + time > this._damping.rotation.duration) {\r\n                this._damping.rotation.time = this._damping.rotation.duration;\r\n                this._damping.rotation.duration = 0;\r\n            }\r\n            else {\r\n                this._damping.rotation.time += time;\r\n                let frameSinceStart = this._damping.rotation.time / 16.6666;\r\n                let spherical = new viewer_shared_math_1.Spherical();\r\n                spherical.theta = this._damping.rotation.theta * Math.pow(damping, frameSinceStart);\r\n                spherical.phi = this._damping.rotation.phi * Math.pow(damping, frameSinceStart);\r\n                let offset = this.rotationSphericalToOffset(spherical);\r\n                this._controls.applyPositionVector(offset);\r\n            }\r\n        }\r\n        else {\r\n            this._damping.rotation.time = 0;\r\n        }\r\n        if (this._damping.zoom.duration > 0) {\r\n            if (this._damping.zoom.time + time > this._damping.zoom.duration) {\r\n                this._damping.zoom.time = this._damping.zoom.duration;\r\n                this._damping.zoom.duration = 0;\r\n            }\r\n            else {\r\n                this._damping.zoom.time += time;\r\n                let frameSinceStart = this._damping.zoom.time / 16.6666;\r\n                let delta = this._damping.zoom.delta * Math.pow(damping, frameSinceStart);\r\n                let offset = this.zoomDistanceToOffset(delta);\r\n                this._controls.applyPositionVector(offset);\r\n            }\r\n        }\r\n        else {\r\n            this._damping.zoom.time = 0;\r\n        }\r\n        if (this._controls.enableAutoRotation) {\r\n            let spherical = new viewer_shared_math_1.Spherical(1.0, 0.0, -this._adjustedSettings.autoRotationSpeed());\r\n            let offset = this.rotationSphericalToOffset(spherical);\r\n            this._controls.applyPositionVector(offset);\r\n        }\r\n    }\r\n    zoom(x, y, active, touch) {\r\n        var distance = Math.sqrt(x * x + y * y);\r\n        if (touch)\r\n            distance = distance / window.devicePixelRatio;\r\n        if (!active) {\r\n            this._dollyStart = distance;\r\n        }\r\n        else {\r\n            this._dollyEnd = distance;\r\n            this._dollyDelta = this._dollyEnd - this._dollyStart;\r\n            this._dollyStart = this._dollyEnd;\r\n            if (this._damping.zoom.duration > 0) {\r\n                if (this._dollyDelta < 0) {\r\n                    this._dollyDelta = Math.min(this._dollyDelta, this._adjustedSettings.movementSmoothness() * this._damping.zoom.delta);\r\n                }\r\n                else {\r\n                    this._dollyDelta = Math.max(this._dollyDelta, this._adjustedSettings.movementSmoothness() * this._damping.zoom.delta);\r\n                }\r\n            }\r\n            let delta = -this._dollyDelta * this._adjustedSettings.zoomSpeed() * (touch ? this._touchAdjustments.zoomSpeed : 1.0);\r\n            let damping = 1 - Math.max(0.01, Math.min(1, this._adjustedSettings.damping()));\r\n            let framesDelta = (Math.log(1 / Math.abs(this._dollyDelta)) - 5 * Math.log(10)) / (Math.log(damping));\r\n            this._damping.zoom.time = 0;\r\n            this._damping.zoom.duration = framesDelta * 16.6666;\r\n            this._damping.zoom.delta = delta;\r\n            this._damping.rotation.duration = 0;\r\n            this._damping.pan.duration = 0;\r\n            let offset = this.zoomDistanceToOffset(delta);\r\n            this._controls.applyPositionVector(offset, true);\r\n        }\r\n    }\r\n    // #endregion Public Methods (7)\r\n    // #region Private Methods (3)\r\n    panDeltaToOffset(panDelta) {\r\n        let offset = gl_matrix_1.vec3.create();\r\n        let panOffset = gl_matrix_1.vec3.create();\r\n        // perspective\r\n        gl_matrix_1.vec3.subtract(offset, this._controls.getPositionWithManualUpdates(), this._controls.getTargetWithManualUpdates());\r\n        var targetDistance = gl_matrix_1.vec3.length(offset);\r\n        // half of the fov is center to top of screen\r\n        targetDistance *= Math.tan(((this._controls.camera.fov / 2) * Math.PI) / 180.0);\r\n        // we use only clientHeight here so aspect ratio does not distort speed\r\n        // left\r\n        const mat = gl_matrix_1.mat4.targetTo(gl_matrix_1.mat4.create(), this._controls.camera.position, this._controls.camera.target, gl_matrix_1.vec3.fromValues(0, 0, 1));\r\n        const v1 = gl_matrix_1.vec3.fromValues(mat[0], mat[1], mat[2]);\r\n        const scalar1 = -(2 * panDelta[0] * targetDistance);\r\n        gl_matrix_1.vec3.multiply(v1, v1, gl_matrix_1.vec3.fromValues(scalar1, scalar1, scalar1));\r\n        gl_matrix_1.vec3.add(panOffset, panOffset, v1);\r\n        // // up\r\n        const v2 = gl_matrix_1.vec3.fromValues(mat[4], mat[5], mat[6]);\r\n        const scalar2 = 2 * panDelta[1] * targetDistance;\r\n        gl_matrix_1.vec3.multiply(v2, v2, gl_matrix_1.vec3.fromValues(scalar2, scalar2, scalar2));\r\n        gl_matrix_1.vec3.add(panOffset, panOffset, v2);\r\n        return gl_matrix_1.vec3.clone(panOffset);\r\n    }\r\n    rotationSphericalToOffset(s) {\r\n        let offset = gl_matrix_1.vec3.create();\r\n        gl_matrix_1.vec3.subtract(offset, this._controls.getPositionWithManualUpdates(), this._controls.getTargetWithManualUpdates());\r\n        gl_matrix_1.vec3.transformQuat(offset, offset, this._quat);\r\n        let spherical = new viewer_shared_math_1.Spherical().fromVec3(offset);\r\n        spherical.theta += s.theta;\r\n        spherical.phi += s.phi;\r\n        let minAzimuthAngle = this._controls.rotationRestriction.minAzimuthAngle * (Math.PI / 180), maxAzimuthAngle = this._controls.rotationRestriction.maxAzimuthAngle * (Math.PI / 180);\r\n        if (spherical.theta > Math.PI) {\r\n            spherical.theta -= 2 * Math.PI;\r\n            if (minAzimuthAngle > spherical.theta) {\r\n                spherical.theta += 2 * Math.PI;\r\n            }\r\n        }\r\n        else if (spherical.theta < -Math.PI) {\r\n            spherical.theta += 2 * Math.PI;\r\n            if (maxAzimuthAngle < spherical.theta) {\r\n                spherical.theta -= 2 * Math.PI;\r\n            }\r\n        }\r\n        spherical.makeSafe();\r\n        offset = spherical.toVec3();\r\n        offset = gl_matrix_1.vec3.transformQuat(gl_matrix_1.vec3.create(), offset, this._quatInverse);\r\n        offset = gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), offset, this._controls.getTargetWithManualUpdates());\r\n        offset = gl_matrix_1.vec3.subtract(gl_matrix_1.vec3.create(), offset, this._controls.getPositionWithManualUpdates());\r\n        return gl_matrix_1.vec3.clone(offset);\r\n    }\r\n    zoomDistanceToOffset(distance) {\r\n        let offset = gl_matrix_1.vec3.create();\r\n        gl_matrix_1.vec3.subtract(offset, this._controls.getPositionWithManualUpdates(), this._controls.getTargetWithManualUpdates());\r\n        return gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), offset, gl_matrix_1.vec3.fromValues(distance, distance, distance));\r\n    }\r\n}\r\nexports.CameraControlsLogic = CameraControlsLogic;\r\n;\r\n"},"sourceMaps":{"js":{"version":3,"file":"CameraControlsLogic.js","sourceRoot":"","sources":["../../../../src/implementation/controls/perspective/CameraControlsLogic.ts"],"names":[],"mappings":"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","sourcesContent":["import { mat4, quat, vec2, vec3 } from 'gl-matrix'\r\nimport { Box, Sphere, Spherical } from '@shapediver/viewer.shared.math'\r\n\r\nimport { PerspectiveCameraControls } from '../PerspectiveCameraControls'\r\nimport { ICameraControlsLogic } from '../../../interfaces/controls/ICameraControlsLogic'\r\nimport { PerspectiveCamera } from '../../camera/PerspectiveCamera'\r\n\r\nexport class CameraControlsLogic implements ICameraControlsLogic {\r\n    // #region Properties (15)\r\n\r\n    private _adjustedSettings = {\r\n        autoRotationSpeed: () => this._controls.autoRotationSpeed * this._settingsAdjustments.autoRotationSpeed,\r\n        damping: () => this._controls.damping * this._settingsAdjustments.damping,\r\n        movementSmoothness: () => this._controls.movementSmoothness * this._settingsAdjustments.movementSmoothness,\r\n        panSpeed: () => this._controls.panSpeed * this._settingsAdjustments.panSpeed,\r\n        rotationSpeed: () => this._controls.rotationSpeed * this._settingsAdjustments.rotationSpeed,\r\n        zoomSpeed: () => this._controls.zoomSpeed * this._settingsAdjustments.zoomSpeed,\r\n    };\r\n    private _damping = {\r\n        rotation: {\r\n            time: 0,\r\n            duration: 0,\r\n            theta: 0,\r\n            phi: 0\r\n        },\r\n        zoom: {\r\n            time: 0,\r\n            duration: 0,\r\n            delta: 0\r\n        },\r\n        pan: {\r\n            time: 0,\r\n            duration: 0,\r\n            offset: vec3.create()\r\n        },\r\n    };\r\n    private _dollyDelta = 0;\r\n    private _dollyEnd = 0;\r\n    private _dollyStart = 0;\r\n    private _panDelta = vec2.create();\r\n    private _panEnd = vec2.create();\r\n    private _panStart = vec2.create();\r\n    private _quat: quat;\r\n    private _quatInverse: quat;\r\n    private _rotateDelta = vec2.create();\r\n    private _rotateEnd = vec2.create();\r\n    private _rotateStart = vec2.create();\r\n    private _settingsAdjustments = {\r\n        autoRotationSpeed: 2 * Math.PI / 60 / 60,\r\n        damping: 1.0,\r\n        movementSmoothness: 1.0,\r\n        panSpeed: 2.0,\r\n        rotationSpeed: Math.PI,\r\n        zoomSpeed: 0.025,\r\n    };\r\n    private _touchAdjustments = {\r\n        autoRotationSpeed: 1.0,\r\n        damping: 1.0,\r\n        movementSmoothness: 1.0,\r\n        panSpeed: 1.5,\r\n        rotationSpeed: 2.0,\r\n        zoomSpeed: 100.0,\r\n    };\r\n\r\n    // #endregion Properties (15)\r\n\r\n    // #region Constructors (1)\r\n\r\n    constructor(private readonly _controls: PerspectiveCameraControls) {\r\n        this._quat = quat.fromValues(-Math.sin(Math.PI / 4), 0, 0, Math.sin(Math.PI / 4));\r\n        this._quatInverse = quat.fromValues(Math.sin(Math.PI / 4), 0, 0, Math.sin(Math.PI / 4));\r\n    }\r\n\r\n    // #endregion Constructors (1)\r\n\r\n    // #region Public Methods (7)\r\n\r\n    public isWithinRestrictions(position: vec3, target: vec3): boolean {\r\n        let pBox = new Box(this._controls.cubePositionRestriction.min, this._controls.cubePositionRestriction.max),\r\n            pSphere = new Sphere(this._controls.spherePositionRestriction.center, this._controls.spherePositionRestriction.radius),\r\n            tBox = new Box(this._controls.cubeTargetRestriction.min, this._controls.cubeTargetRestriction.max),\r\n            tSphere = new Sphere(this._controls.sphereTargetRestriction.center, this._controls.sphereTargetRestriction.radius);\r\n\r\n        if (!(pBox.containsPoint(position) && pSphere.containsPoint(position))) return false;\r\n        if (!(tBox.containsPoint(target) && tSphere.containsPoint(target))) return false;\r\n\r\n        let currentDistance = vec3.distance(position, target);\r\n        if (currentDistance > this._controls.zoomRestriction.maxDistance || currentDistance < this._controls.zoomRestriction.minDistance) return false;\r\n\r\n        let minPolarAngle = this._controls.rotationRestriction.minPolarAngle * (Math.PI / 180),\r\n            maxPolarAngle = this._controls.rotationRestriction.maxPolarAngle * (Math.PI / 180),\r\n            minAzimuthAngle = this._controls.rotationRestriction.minAzimuthAngle * (Math.PI / 180),\r\n            maxAzimuthAngle = this._controls.rotationRestriction.maxAzimuthAngle * (Math.PI / 180);\r\n\r\n        if (minAzimuthAngle !== -Infinity ||\r\n            maxAzimuthAngle !== Infinity ||\r\n            minPolarAngle !== 0 ||\r\n            maxPolarAngle !== 180) {\r\n            let offset = vec3.sub(vec3.create(), position, target);\r\n            vec3.transformQuat(offset, offset, this._quat);\r\n            const spherical = new Spherical().fromVec3(offset);\r\n\r\n            if (spherical.theta < minAzimuthAngle ||\r\n                spherical.theta > maxAzimuthAngle ||\r\n                spherical.phi < minPolarAngle ||\r\n                spherical.phi > maxPolarAngle) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public pan(x: number, y: number, active: boolean, touch: boolean): void {\r\n        if (touch) {\r\n            x = x / window.devicePixelRatio;\r\n            y = y / window.devicePixelRatio;\r\n        }\r\n\r\n        if (!active) {\r\n            this._panStart = vec2.fromValues(x, y);\r\n        } else {\r\n            this._panEnd = vec2.fromValues(x, y);\r\n            vec2.sub(this._panDelta, this._panEnd, this._panStart);\r\n            if (this._panDelta[0] === 0 && this._panDelta[1] === 0) return;\r\n\r\n            vec2.copy(this._panStart, this._panEnd);\r\n\r\n            const adjustedPanSpeed = this._adjustedSettings.panSpeed() * (touch ? this._touchAdjustments.panSpeed : 1.0);\r\n            let offset = this.panDeltaToOffset(vec2.mul(vec2.create(), this._panDelta, vec2.fromValues(adjustedPanSpeed, adjustedPanSpeed)));\r\n\r\n            if (this._damping.pan.duration > 0) {\r\n                if (offset[0] < 0) {\r\n                    offset[0] = Math.min(offset[0], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[0]);\r\n                } else {\r\n                    offset[0] = Math.max(offset[0], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[0]);\r\n                }\r\n                if (offset[1] < 0) {\r\n                    offset[1] = Math.min(offset[1], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[1]);\r\n                } else {\r\n                    offset[1] = Math.max(offset[1], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[1]);\r\n                }\r\n                if (offset[2] < 0) {\r\n                    offset[2] = Math.min(offset[2], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[2]);\r\n                } else {\r\n                    offset[2] = Math.max(offset[2], this._adjustedSettings.movementSmoothness() * this._damping.pan.offset[2]);\r\n                }\r\n            }\r\n\r\n            let damping = 1 - Math.max(0.01, Math.min(0.99, this._adjustedSettings.damping()));\r\n\r\n            let framesOffsetX = (Math.log(1 / Math.abs(offset[0])) - 5 * Math.log(10)) / (Math.log(damping));\r\n            let framesOffsetY = (Math.log(1 / Math.abs(offset[1])) - 5 * Math.log(10)) / (Math.log(damping));\r\n            let framesOffsetZ = (Math.log(1 / Math.abs(offset[2])) - 5 * Math.log(10)) / (Math.log(damping));\r\n            this._damping.pan.time = 0;\r\n            this._damping.pan.duration = Math.max(framesOffsetX, Math.max(framesOffsetY, framesOffsetZ)) * 16.6666;\r\n            this._damping.pan.offset = vec3.clone(offset);\r\n\r\n            this._damping.rotation.duration = 0;\r\n            this._damping.zoom.duration = 0;\r\n\r\n            this._controls.applyTargetVector(offset, true);\r\n            this._controls.applyPositionVector(offset, true);\r\n        }\r\n    }\r\n\r\n    public reset() {\r\n        this._damping = {\r\n            rotation: {\r\n                time: 0,\r\n                duration: 0,\r\n                theta: 0,\r\n                phi: 0\r\n            },\r\n            zoom: {\r\n                time: 0,\r\n                duration: 0,\r\n                delta: 0\r\n            },\r\n            pan: {\r\n                time: 0,\r\n                duration: 0,\r\n                offset: vec3.create()\r\n            },\r\n        };\r\n        this._dollyDelta = 0;\r\n        this._dollyEnd = 0;\r\n        this._dollyStart = 0;\r\n        this._panDelta = vec2.create();\r\n        this._panEnd = vec2.create();\r\n        this._panStart = vec2.create();\r\n        this._rotateDelta = vec2.create();\r\n        this._rotateEnd = vec2.create();\r\n        this._rotateStart = vec2.create();\r\n    }\r\n\r\n    public restrict(position: vec3, target: vec3): { position: vec3, target: vec3 } {\r\n        let pBox = new Box(this._controls.cubePositionRestriction.min, this._controls.cubePositionRestriction.max),\r\n            pSphere = new Sphere(this._controls.spherePositionRestriction.center, this._controls.spherePositionRestriction.radius),\r\n            tBox = new Box(this._controls.cubeTargetRestriction.min, this._controls.cubeTargetRestriction.max),\r\n            tSphere = new Sphere(this._controls.sphereTargetRestriction.center, this._controls.sphereTargetRestriction.radius);\r\n\r\n        if (!pBox.containsPoint(position))\r\n            position = pBox.clampPoint(position);\r\n\r\n        if (!pSphere.containsPoint(position))\r\n            position = pSphere.clampPoint(position);\r\n\r\n        if (!tBox.containsPoint(target))\r\n            target = tBox.clampPoint(target);\r\n\r\n        if (!tSphere.containsPoint(target))\r\n            target = tSphere.clampPoint(target);\r\n\r\n        // zoom restrictions\r\n        let currentDistance = vec3.distance(position, target);\r\n        if (currentDistance > this._controls.zoomRestriction.maxDistance || currentDistance < this._controls.zoomRestriction.minDistance) {\r\n            let direction = vec3.normalize(vec3.create(), vec3.subtract(vec3.create(), position, target))\r\n            let distance = Math.max(this._controls.zoomRestriction.minDistance, Math.min(this._controls.zoomRestriction.maxDistance, currentDistance));\r\n            vec3.add(position, vec3.multiply(position, direction, vec3.fromValues(distance, distance, distance)), target);\r\n        }\r\n\r\n        // angle restrictions\r\n        let minPolarAngle = this._controls.rotationRestriction.minPolarAngle * (Math.PI / 180),\r\n            maxPolarAngle = this._controls.rotationRestriction.maxPolarAngle * (Math.PI / 180),\r\n            minAzimuthAngle = this._controls.rotationRestriction.minAzimuthAngle * (Math.PI / 180),\r\n            maxAzimuthAngle = this._controls.rotationRestriction.maxAzimuthAngle * (Math.PI / 180);\r\n\r\n        if (minAzimuthAngle !== -Infinity ||\r\n            maxAzimuthAngle !== Infinity ||\r\n            minPolarAngle !== 0 ||\r\n            maxPolarAngle !== 180) {\r\n            let offset = vec3.subtract(vec3.create(), position, target);\r\n            vec3.transformQuat(offset, offset, this._quat);\r\n\r\n            const spherical = new Spherical().fromVec3(offset);\r\n\r\n            if (spherical.theta < minAzimuthAngle ||\r\n                spherical.theta > maxAzimuthAngle ||\r\n                spherical.phi < minPolarAngle ||\r\n                spherical.phi > maxPolarAngle) {\r\n                spherical.theta = Math.max(minAzimuthAngle, Math.min(maxAzimuthAngle, spherical.theta));\r\n                spherical.phi = Math.max(minPolarAngle, Math.min(maxPolarAngle, spherical.phi));\r\n                spherical.makeSafe();\r\n                offset = spherical.toVec3();\r\n                vec3.transformQuat(offset, offset, this._quatInverse);\r\n                vec3.add(position, offset, target);\r\n            }\r\n        }\r\n\r\n        return { position, target };\r\n    }\r\n\r\n    public rotate(x: number, y: number, active: boolean, touch: boolean): void {\r\n        if (touch) {\r\n            x = x / window.devicePixelRatio;\r\n            y = y / window.devicePixelRatio;\r\n        }\r\n\r\n        if (!active) {\r\n            this._rotateStart = vec2.fromValues(x, y)\r\n        } else {\r\n            this._rotateEnd = vec2.fromValues(x, y)\r\n            vec2.subtract(this._rotateDelta, this._rotateEnd, this._rotateStart)\r\n            vec2.copy(this._rotateStart, this._rotateEnd)\r\n\r\n            if (!this._controls.canvas) return;\r\n            if (this._controls.canvas.clientWidth == 0 || this._controls.canvas.clientHeight == 0) return;\r\n\r\n            const spherical = new Spherical();\r\n            let rotationSpeed = this._adjustedSettings.rotationSpeed() * (touch ? this._touchAdjustments.rotationSpeed : 1.0);\r\n            spherical.theta -= rotationSpeed * this._rotateDelta[0];\r\n            spherical.phi -= rotationSpeed * this._rotateDelta[1];\r\n\r\n            if (this._damping.rotation.duration > 0) {\r\n                let thetaDelta = this._damping.rotation.theta - spherical.theta;\r\n                spherical.theta += thetaDelta * this._adjustedSettings.movementSmoothness();\r\n\r\n                let phiDelta = this._damping.rotation.phi - spherical.phi;\r\n                spherical.phi += phiDelta * this._adjustedSettings.movementSmoothness();\r\n            }\r\n\r\n            let offset = this.rotationSphericalToOffset(spherical);\r\n\r\n            let damping = 1 - Math.max(0.01, Math.min(1, this._adjustedSettings.damping()));\r\n            let framesTheta = (Math.log(1 / Math.abs(spherical.theta)) - 5 * Math.log(10)) / (Math.log(damping));\r\n            let framesPhi = (Math.log(1 / Math.abs(spherical.phi)) - 5 * Math.log(10)) / (Math.log(damping));\r\n\r\n            this._damping.rotation.time = 0;\r\n            this._damping.rotation.duration = Math.max(framesTheta, framesPhi) * 16.6666;\r\n            this._damping.rotation.theta = spherical.theta;\r\n            this._damping.rotation.phi = spherical.phi;\r\n\r\n            this._damping.pan.duration = 0;\r\n            this._damping.zoom.duration = 0;\r\n\r\n            this._controls.applyPositionVector(offset, true);\r\n        }\r\n    }\r\n\r\n    public update(time: number, manualInteraction: boolean): void {\r\n        if (manualInteraction === true) {\r\n            this._damping.zoom.duration = 0;\r\n            this._damping.pan.duration = 0;\r\n            this._damping.rotation.duration = 0;\r\n        }\r\n\r\n        let damping = 1 - Math.max(0.01, Math.min(1, this._adjustedSettings.damping()));\r\n\r\n        if (this._damping.pan.duration > 0) {\r\n            if (this._damping.pan.time + time > this._damping.pan.duration) {\r\n                this._damping.pan.time = this._damping.pan.duration;\r\n                this._damping.pan.duration = 0;\r\n            } else {\r\n                this._damping.pan.time += time;\r\n\r\n                let frameSinceStart = this._damping.pan.time / 16.6666;\r\n                let dampingFrames = Math.pow(damping, frameSinceStart);\r\n                let offset = vec3.multiply(vec3.create(), this._damping.pan.offset, vec3.fromValues(dampingFrames, dampingFrames, dampingFrames));\r\n                this._controls.applyTargetVector(offset);\r\n                this._controls.applyPositionVector(offset);\r\n            }\r\n        } else {\r\n            this._damping.pan.time = 0;\r\n        }\r\n\r\n        if (this._damping.rotation.duration > 0) {\r\n            if (this._damping.rotation.time + time > this._damping.rotation.duration) {\r\n                this._damping.rotation.time = this._damping.rotation.duration;\r\n                this._damping.rotation.duration = 0;\r\n            } else {\r\n                this._damping.rotation.time += time;\r\n\r\n                let frameSinceStart = this._damping.rotation.time / 16.6666;\r\n                let spherical = new Spherical();\r\n                spherical.theta = this._damping.rotation.theta * Math.pow(damping, frameSinceStart);\r\n                spherical.phi = this._damping.rotation.phi * Math.pow(damping, frameSinceStart);\r\n                let offset = this.rotationSphericalToOffset(spherical);\r\n                this._controls.applyPositionVector(offset);\r\n            }\r\n        } else {\r\n            this._damping.rotation.time = 0;\r\n        }\r\n\r\n        if (this._damping.zoom.duration > 0) {\r\n            if (this._damping.zoom.time + time > this._damping.zoom.duration) {\r\n                this._damping.zoom.time = this._damping.zoom.duration;\r\n                this._damping.zoom.duration = 0;\r\n            } else {\r\n                this._damping.zoom.time += time;\r\n\r\n                let frameSinceStart = this._damping.zoom.time / 16.6666;\r\n                let delta = this._damping.zoom.delta * Math.pow(damping, frameSinceStart);\r\n                let offset = this.zoomDistanceToOffset(delta);\r\n                this._controls.applyPositionVector(offset);\r\n            }\r\n        } else {\r\n            this._damping.zoom.time = 0;\r\n        }\r\n\r\n        if (this._controls.enableAutoRotation) {\r\n            let spherical = new Spherical(1.0, 0.0, -this._adjustedSettings.autoRotationSpeed());\r\n            let offset = this.rotationSphericalToOffset(spherical);\r\n            this._controls.applyPositionVector(offset);\r\n        }\r\n    }\r\n\r\n    public zoom(x: number, y: number, active: boolean, touch: boolean): void {\r\n        var distance = Math.sqrt(x * x + y * y);\r\n\r\n        if (touch)\r\n            distance = distance / window.devicePixelRatio;\r\n\r\n        if (!active) {\r\n            this._dollyStart = distance;\r\n        } else {\r\n            this._dollyEnd = distance;\r\n            this._dollyDelta = this._dollyEnd - this._dollyStart;\r\n            this._dollyStart = this._dollyEnd;\r\n\r\n            if (this._damping.zoom.duration > 0) {\r\n                if (this._dollyDelta < 0) {\r\n                    this._dollyDelta = Math.min(this._dollyDelta, this._adjustedSettings.movementSmoothness() * this._damping.zoom.delta);\r\n                } else {\r\n                    this._dollyDelta = Math.max(this._dollyDelta, this._adjustedSettings.movementSmoothness() * this._damping.zoom.delta);\r\n                }\r\n            }\r\n\r\n            let delta = - this._dollyDelta * this._adjustedSettings.zoomSpeed() * (touch ? this._touchAdjustments.zoomSpeed : 1.0);\r\n\r\n            let damping = 1 - Math.max(0.01, Math.min(1, this._adjustedSettings.damping()));\r\n            let framesDelta = (Math.log(1 / Math.abs(this._dollyDelta)) - 5 * Math.log(10)) / (Math.log(damping));\r\n            this._damping.zoom.time = 0;\r\n            this._damping.zoom.duration = framesDelta * 16.6666;\r\n            this._damping.zoom.delta = delta;\r\n\r\n            this._damping.rotation.duration = 0;\r\n            this._damping.pan.duration = 0;\r\n\r\n            let offset = this.zoomDistanceToOffset(delta);\r\n            this._controls.applyPositionVector(offset, true);\r\n        }\r\n    }\r\n\r\n    // #endregion Public Methods (7)\r\n\r\n    // #region Private Methods (3)\r\n\r\n    private panDeltaToOffset(panDelta: vec2): vec3 {\r\n        let offset = vec3.create();\r\n        let panOffset = vec3.create();\r\n\r\n        // perspective\r\n        vec3.subtract(offset, this._controls.getPositionWithManualUpdates(), this._controls.getTargetWithManualUpdates());\r\n        var targetDistance = vec3.length(offset);\r\n\r\n        // half of the fov is center to top of screen\r\n        targetDistance *= Math.tan((((<PerspectiveCamera>this._controls.camera).fov / 2) * Math.PI) / 180.0);\r\n\r\n        // we use only clientHeight here so aspect ratio does not distort speed\r\n        // left\r\n        const mat = mat4.targetTo(mat4.create(), this._controls.camera.position, this._controls.camera.target, vec3.fromValues(0, 0, 1));\r\n\r\n        const v1 = vec3.fromValues(mat[0], mat[1], mat[2]);\r\n        const scalar1 = -(2 * panDelta[0] * targetDistance);\r\n        vec3.multiply(v1, v1, vec3.fromValues(scalar1, scalar1, scalar1));\r\n        vec3.add(panOffset, panOffset, v1);\r\n\r\n        // // up\r\n        const v2 = vec3.fromValues(mat[4], mat[5], mat[6])\r\n        const scalar2 = 2 * panDelta[1] * targetDistance;\r\n        vec3.multiply(v2, v2, vec3.fromValues(scalar2, scalar2, scalar2));\r\n        vec3.add(panOffset, panOffset, v2);\r\n\r\n        return vec3.clone(panOffset);\r\n    }\r\n\r\n    private rotationSphericalToOffset(s: Spherical): vec3 {\r\n        let offset = vec3.create();\r\n        vec3.subtract(offset, this._controls.getPositionWithManualUpdates(), this._controls.getTargetWithManualUpdates());\r\n        vec3.transformQuat(offset, offset, this._quat);\r\n        let spherical = new Spherical().fromVec3(offset);\r\n\r\n        spherical.theta += s.theta;\r\n        spherical.phi += s.phi;\r\n\r\n        let minAzimuthAngle = this._controls.rotationRestriction.minAzimuthAngle * (Math.PI / 180),\r\n        maxAzimuthAngle = this._controls.rotationRestriction.maxAzimuthAngle * (Math.PI / 180);\r\n\r\n        if (spherical.theta > Math.PI) {\r\n            spherical.theta -= 2 * Math.PI;\r\n            if (minAzimuthAngle > spherical.theta) {\r\n                spherical.theta += 2 * Math.PI;\r\n            }\r\n        } else if (spherical.theta < -Math.PI) {\r\n            spherical.theta += 2 * Math.PI;\r\n            if (maxAzimuthAngle < spherical.theta) {\r\n                spherical.theta -= 2 * Math.PI;\r\n            }\r\n        }\r\n\r\n        spherical.makeSafe();\r\n        offset = spherical.toVec3();\r\n        offset = vec3.transformQuat(vec3.create(), offset, this._quatInverse);\r\n        offset = vec3.add(vec3.create(), offset, this._controls.getTargetWithManualUpdates())\r\n        offset = vec3.subtract(vec3.create(), offset, this._controls.getPositionWithManualUpdates());\r\n        return vec3.clone(offset);\r\n\r\n    }\r\n\r\n    private zoomDistanceToOffset(distance: number): vec3 {\r\n        let offset = vec3.create();\r\n        vec3.subtract(offset, this._controls.getPositionWithManualUpdates(), this._controls.getTargetWithManualUpdates());\r\n        return vec3.multiply(vec3.create(), offset, vec3.fromValues(distance, distance, distance));\r\n    }\r\n\r\n    // #endregion Private Methods (3)\r\n};"]}},"error":null,"hash":"460b80beaa8f58baa9717aeb5a745cff","cacheData":{"env":{}}}